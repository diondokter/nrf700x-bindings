/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const NRF_WIFI_LOG_LEVEL_ERR: u32 = 1;
pub const NRF_WIFI_LOG_LEVEL_INF: u32 = 3;
pub const NRF_WIFI_LOG_LEVEL_DBG: u32 = 4;
pub const RPU_ADDR_SPI_START: u32 = 0;
pub const RPU_ADDR_GRAM_START: u32 = 3070230528;
pub const RPU_ADDR_GRAM_END: u32 = 3070296575;
pub const RPU_ADDR_SBUS_START: u32 = 2751463424;
pub const RPU_ADDR_SBUS_END: u32 = 2751496191;
pub const RPU_ADDR_PBUS_START: u32 = 2768240640;
pub const RPU_ADDR_PBUS_END: u32 = 2768502783;
pub const RPU_ADDR_BEV_START: u32 = 3217031168;
pub const RPU_ADDR_BEV_END: u32 = 3218079743;
pub const RPU_ADDR_PKTRAM_START: u32 = 2952790016;
pub const RPU_ADDR_PKTRAM_END: u32 = 2952990719;
pub const RPU_ADDR_LMAC_CORE_RET_START: u32 = 2147745792;
pub const RPU_ADDR_UMAC_CORE_RET_START: u32 = 2148007936;
pub const RPU_ADDR_MASK_BASE: u32 = 4278190080;
pub const RPU_ADDR_MASK_OFFSET: u32 = 16777215;
pub const RPU_ADDR_MASK_BEV_OFFSET: u32 = 1048575;
pub const RPU_REG_INT_FROM_RPU_CTRL: u32 = 2751464448;
pub const RPU_REG_BIT_INT_FROM_RPU_CTRL: u32 = 17;
pub const RPU_REG_INT_TO_MCU_CTRL: u32 = 2751464576;
pub const RPU_REG_INT_FROM_MCU_ACK: u32 = 2751464584;
pub const RPU_REG_BIT_INT_FROM_MCU_ACK: u32 = 31;
pub const RPU_REG_INT_FROM_MCU_CTRL: u32 = 2751464596;
pub const RPU_REG_BIT_INT_FROM_MCU_CTRL: u32 = 31;
pub const RPU_REG_UCC_SLEEP_CTRL_DATA_0: u32 = 2751474732;
pub const RPU_REG_UCC_SLEEP_CTRL_DATA_1: u32 = 2751474736;
pub const RPU_REG_MIPS_MCU_CONTROL: u32 = 2751463424;
pub const RPU_REG_BIT_MIPS_MCU_LATCH_SOFT_RESET: u32 = 1;
pub const RPU_REG_MIPS_MCU2_CONTROL: u32 = 2751463680;
pub const RPU_REG_MIPS_MCU_UCCP_INT_STATUS: u32 = 2751463428;
pub const RPU_REG_BIT_MIPS_UCCP_INT_STATUS: u32 = 0;
pub const RPU_REG_BIT_MIPS_WATCHDOG_INT_STATUS: u32 = 1;
pub const RPU_REG_MIPS_MCU_TIMER_CONTROL: u32 = 2751463496;
pub const RPU_REG_MIPS_MCU_SYS_CORE_MEM_CTRL: u32 = 2751463472;
pub const RPU_REG_MIPS_MCU_SYS_CORE_MEM_WDATA: u32 = 2751463476;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_0: u32 = 2751463504;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_1: u32 = 2751463508;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_2: u32 = 2751463512;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_3: u32 = 2751463516;
pub const RPU_REG_MIPS_MCU2_SYS_CORE_MEM_CTRL: u32 = 2751463728;
pub const RPU_REG_MIPS_MCU2_SYS_CORE_MEM_WDATA: u32 = 2751463732;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_0: u32 = 2751463760;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_1: u32 = 2751463764;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_2: u32 = 2751463768;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_3: u32 = 2751463772;
pub const RPU_REG_MCP_SYS_CSTRCTRL: u32 = 2751468032;
pub const RPU_REG_MCP_SYS_CSTRDAT32: u32 = 2751468056;
pub const RPU_REG_MCP2_SYS_CSTRCTRL: u32 = 2751476224;
pub const RPU_REG_MCP2_SYS_CSTRDAT32: u32 = 2751476248;
pub const RPU_REG_MCP3_SYS_CSTRCTRL: u32 = 2751480320;
pub const RPU_REG_MCP3_SYS_CSTRDAT32: u32 = 2751480344;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_00: u32 = 2751578624;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_01: u32 = 2751578628;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_02: u32 = 2751578632;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_04: u32 = 2751578640;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_16: u32 = 2751578720;
pub const RPU_REG_RFCTL_SPI_CMD_DATA_TABLE_0: u32 = 2751578880;
pub const RPU_REG_RFCTL_SPI_CMD_DATA_TABLE_1: u32 = 2751578884;
pub const RPU_REG_RFCTL_SPI_CMD_DATA_TABLE_2: u32 = 2751578888;
pub const RPU_REG_RFCTL_SPI_READ_DATA_TABLE_0: u32 = 2751579008;
pub const PWR_CTRL1_SYSDEF: u32 = 4160;
pub const PWR_COUNTERSTART_SYSDEF: u32 = 4440;
pub const PWR_COUNTERCYCLES_SYSDEF: u32 = 4441;
pub const PWR_COUNTERSTATUS0_SYSDEF: u32 = 4444;
pub const PWR_COUNTERSTATUS1_SYSDEF: u32 = 4445;
pub const PWR_COUNTERSTATUS2_SYSDEF: u32 = 4446;
pub const PWR_COUNTERSTATUS3_SYSDEF: u32 = 4447;
pub const WL_PWR_MON_SYSDEF: u32 = 324;
pub const WL_PWR_AUX_SYSDEF: u32 = 325;
pub const PWR_BREAKTIMER90_SYSDEF: u32 = 4708;
pub const PWR_BREAKCOND2_SYSDEF: u32 = 4437;
pub const PWR_BREAK3_SYSDEF: u32 = 4432;
pub const PWR_BREAKCOND3_SYSDEF: u32 = 4438;
pub const PWR_BREAK5_SYSDEF: u32 = 4434;
pub const SPI_PAGESELECT: u32 = 124;
pub const SPI_DIGREFCLOCKCTRL: u32 = 125;
pub const RPU_REG_BIT_HARDRST_CTRL: u32 = 8;
pub const RPU_REG_BIT_PS_CTRL: u32 = 0;
pub const RPU_REG_BIT_PS_STATE: u32 = 1;
pub const RPU_REG_BIT_READY_STATE: u32 = 2;
pub const RPU_MEM_RX_CMD_BASE: u32 = 3070233944;
pub const RPU_MEM_HPQ_INFO: u32 = 2952790052;
pub const RPU_MEM_TX_CMD_BASE: u32 = 2952790200;
pub const RPU_MEM_OTP_INFO: u32 = 2952790108;
pub const RPU_MEM_OTP_FT_PROG_VERSION: u32 = 2952810456;
pub const RPU_MEM_OTP_INFO_FLAGS: u32 = 2952810460;
pub const RPU_MEM_LMAC_IF_INFO: u32 = 2952810464;
pub const RPU_MEM_PKT_BASE: u32 = 2952810496;
pub const RPU_CMD_START_MAGIC: u32 = 57005;
pub const RPU_DATA_CMD_SIZE_MAX_RX: u32 = 8;
pub const RPU_DATA_CMD_SIZE_MAX_TX: u32 = 148;
pub const RPU_EVENT_COMMON_SIZE_MAX: u32 = 128;
pub const EVENT_POOL_NUM_ELEMS: u32 = 7;
pub const MAX_EVENT_POOL_LEN: u32 = 1000;
pub const MAX_NUM_OF_RX_QUEUES: u32 = 3;
pub const NRF_WIFI_RPU_PWR_DATA_TYPE_LFC_ERR: u32 = 0;
pub const NRF_WIFI_RPU_PWR_DATA_TYPE_VBAT_MON: u32 = 1;
pub const NRF_WIFI_RPU_PWR_DATA_TYPE_TEMP: u32 = 2;
pub const NRF_WIFI_RPU_PWR_DATA_TYPE_ALL: u32 = 3;
pub const NRF_WIFI_RPU_PWR_DATA_TYPE_MAX: u32 = 4;
pub const NRF_WIFI_RPU_RF_CLK_TYPE_20: u32 = 0;
pub const NRF_WIFI_RPU_RF_CLK_TYPE_40: u32 = 1;
pub const NRF_WIFI_RPU_RF_CLK_TYPE_MAX: u32 = 2;
pub const RPU_PKTRAM_SIZE: u32 = 180224;
pub const REGION_PROTECT: u32 = 64;
pub const PRODTEST_FT_PROGVERSION: u32 = 29;
pub const PRODTEST_TRIM0: u32 = 32;
pub const PRODTEST_TRIM1: u32 = 33;
pub const PRODTEST_TRIM2: u32 = 34;
pub const PRODTEST_TRIM3: u32 = 35;
pub const PRODTEST_TRIM4: u32 = 36;
pub const PRODTEST_TRIM5: u32 = 37;
pub const PRODTEST_TRIM6: u32 = 38;
pub const PRODTEST_TRIM7: u32 = 39;
pub const PRODTEST_TRIM8: u32 = 40;
pub const PRODTEST_TRIM9: u32 = 41;
pub const PRODTEST_TRIM10: u32 = 42;
pub const PRODTEST_TRIM11: u32 = 43;
pub const PRODTEST_TRIM12: u32 = 44;
pub const PRODTEST_TRIM13: u32 = 45;
pub const PRODTEST_TRIM14: u32 = 46;
pub const PRODCTRL_DISABLE5GHZ: u32 = 47;
pub const INFO_PART: u32 = 48;
pub const INFO_VARIANT: u32 = 49;
pub const INFO_UUID: u32 = 52;
pub const QSPI_KEY: u32 = 68;
pub const MAC0_ADDR: u32 = 72;
pub const MAC1_ADDR: u32 = 74;
pub const CALIB_XO: u32 = 76;
pub const CALIB_PDADJM7: u32 = 77;
pub const CALIB_PDADJM0: u32 = 78;
pub const CALIB_PWR2G: u32 = 79;
pub const CALIB_PWR5GM7: u32 = 80;
pub const CALIB_PWR5GM0: u32 = 81;
pub const CALIB_RXGNOFF: u32 = 82;
pub const CALIB_TXPOWBACKOFFT: u32 = 83;
pub const CALIB_TXPOWBACKOFFV: u32 = 84;
pub const REGION_DEFAULTS: u32 = 85;
pub const PRODRETEST_PROGVERSION: u32 = 86;
pub const PRODRETEST_TRIM0: u32 = 87;
pub const PRODRETEST_TRIM1: u32 = 88;
pub const PRODRETEST_TRIM2: u32 = 89;
pub const PRODRETEST_TRIM3: u32 = 90;
pub const PRODRETEST_TRIM4: u32 = 91;
pub const PRODRETEST_TRIM5: u32 = 92;
pub const PRODRETEST_TRIM6: u32 = 93;
pub const PRODRETEST_TRIM7: u32 = 94;
pub const PRODRETEST_TRIM8: u32 = 95;
pub const PRODRETEST_TRIM9: u32 = 96;
pub const PRODRETEST_TRIM10: u32 = 97;
pub const PRODRETEST_TRIM11: u32 = 98;
pub const PRODRETEST_TRIM12: u32 = 99;
pub const PRODRETEST_TRIM13: u32 = 100;
pub const PRODRETEST_TRIM14: u32 = 101;
pub const OTP_MAX_WORD_LEN: u32 = 128;
pub const QSPI_KEY_LENGTH_BYTES: u32 = 16;
pub const RETRIM_LEN: u32 = 15;
pub const OTP_SZ_CALIB_XO: u32 = 1;
pub const OTP_SZ_CALIB_PDADJM7: u32 = 4;
pub const OTP_SZ_CALIB_PDADJM0: u32 = 4;
pub const OTP_SZ_CALIB_PWR2G: u32 = 1;
pub const OTP_SZ_CALIB_PWR2GM0M7: u32 = 2;
pub const OTP_SZ_CALIB_PWR5GM7: u32 = 3;
pub const OTP_SZ_CALIB_PWR5GM0: u32 = 3;
pub const OTP_SZ_CALIB_RXGNOFF: u32 = 4;
pub const OTP_SZ_CALIB_TXP_BOFF_2GH: u32 = 1;
pub const OTP_SZ_CALIB_TXP_BOFF_2GL: u32 = 1;
pub const OTP_SZ_CALIB_TXP_BOFF_5GH: u32 = 1;
pub const OTP_SZ_CALIB_TXP_BOFF_5GL: u32 = 1;
pub const OTP_SZ_CALIB_TXP_BOFF_V: u32 = 4;
pub const OTP_OFF_CALIB_XO: u32 = 0;
pub const OTP_OFF_CALIB_PDADJM7: u32 = 4;
pub const OTP_OFF_CALIB_PDADJM0: u32 = 8;
pub const OTP_OFF_CALIB_PWR2G: u32 = 12;
pub const OTP_OFF_CALIB_PWR2GM0M7: u32 = 13;
pub const OTP_OFF_CALIB_PWR5GM7: u32 = 16;
pub const OTP_OFF_CALIB_PWR5GM0: u32 = 20;
pub const OTP_OFF_CALIB_RXGNOFF: u32 = 24;
pub const OTP_OFF_CALIB_TXP_BOFF_2GH: u32 = 28;
pub const OTP_OFF_CALIB_TXP_BOFF_2GL: u32 = 29;
pub const OTP_OFF_CALIB_TXP_BOFF_5GH: u32 = 30;
pub const OTP_OFF_CALIB_TXP_BOFF_5GL: u32 = 31;
pub const OTP_OFF_CALIB_TXP_BOFF_V: u32 = 32;
pub const QSPI_KEY_FLAG_MASK: i32 = -2;
pub const MAC0_ADDR_FLAG_MASK: i32 = -3;
pub const MAC1_ADDR_FLAG_MASK: i32 = -5;
pub const CALIB_XO_FLAG_MASK: i32 = -9;
pub const CALIB_PDADJM7_FLAG_MASK: i32 = -17;
pub const CALIB_PDADJM0_FLAG_MASK: i32 = -33;
pub const CALIB_PWR2G_FLAG_MASK: i32 = -65;
pub const CALIB_PWR5GM7_FLAG_MASK: i32 = -129;
pub const CALIB_PWR5GM0_FLAG_MASK: i32 = -257;
pub const CALIB_RXGNOFF_FLAG_MASK: i32 = -513;
pub const CALIB_TXPOWBACKOFFT_FLAG_MASK: i32 = -1025;
pub const CALIB_TXPOWBACKOFFV_FLAG_MASK: i32 = -2049;
pub const OTP_VOLTCTRL_ADDR: u32 = 102404;
pub const OTP_VOLTCTRL_2V5: u32 = 59;
pub const OTP_VOLTCTRL_1V8: u32 = 11;
pub const OTP_POLL_ADDR: u32 = 112644;
pub const OTP_WR_DONE: u32 = 1;
pub const OTP_READ_VALID: u32 = 2;
pub const OTP_READY: u32 = 4;
pub const OTP_RWSBMODE_ADDR: u32 = 112640;
pub const OTP_STANDBY_MODE: u32 = 0;
pub const OTP_READ_MODE: u32 = 1;
pub const OTP_BYTE_WRITE_MODE: u32 = 66;
pub const OTP_RDENABLE_ADDR: u32 = 112656;
pub const OTP_READREG_ADDR: u32 = 112660;
pub const OTP_WRENABLE_ADDR: u32 = 112648;
pub const OTP_WRITEREG_ADDR: u32 = 112652;
pub const OTP_TIMING_REG1_ADDR: u32 = 112672;
pub const OTP_TIMING_REG1_VAL: u32 = 0;
pub const OTP_TIMING_REG2_ADDR: u32 = 112676;
pub const OTP_TIMING_REG2_VAL: u32 = 200075;
pub const PRODTEST_TRIM_LEN: u32 = 15;
pub const OTP_FRESH_FROM_FAB: u32 = 4294967295;
pub const OTP_PROGRAMMED: u32 = 0;
pub const OTP_ENABLE_PATTERN: u32 = 1358582010;
pub const OTP_INVALID: u32 = 3735928559;
pub const FT_PROG_VER_MASK: u32 = 983040;
pub const BT_INIT: u32 = 1;
pub const BT_MODE: u32 = 2;
pub const BT_CTRL: u32 = 4;
pub const BT_COEX_DISABLE: u32 = 0;
pub const BT_COEX_ENABLE: u32 = 1;
pub const SLAVE: u32 = 0;
pub const MASTER: u32 = 1;
pub const RPU_MEM_UMAC_BOOT_SIG: u32 = 2952790016;
pub const RPU_MEM_UMAC_VER: u32 = 2952790020;
pub const RPU_MEM_UMAC_PEND_Q_BMP: u32 = 2952790024;
pub const RPU_MEM_UMAC_CMD_ADDRESS: u32 = 2952791976;
pub const RPU_MEM_UMAC_EVENT_ADDRESS: u32 = 2952793640;
pub const RPU_MEM_UMAC_PATCH_BIN: u32 = 2148057088;
pub const RPU_MEM_UMAC_PATCH_BIMG: u32 = 2148111360;
pub const NRF_WIFI_UMAC_BOOT_SIG: u32 = 1515870810;
pub const NRF_WIFI_UMAC_ROM_PATCH_OFFSET: u32 = 103424;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_0: u32 = 1008369664;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_1: u32 = 660209664;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_2: u32 = 54525960;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_3: u32 = 0;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_VO: u32 = 1;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_VI: u32 = 2;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_BE: u32 = 4;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_BK: u32 = 8;
pub const NRF_WIFI_RF_PARAMS_SIZE: u32 = 200;
pub const NRF_WIFI_RF_PARAMS_CONF_SIZE: u32 = 42;
pub const NRF_WIFI_DEF_RF_PARAMS : & [u8 ; 311] = b"0000000000002A0000000003030303544040343430383430000000004307FC00F8FCFCF800FC00000000007077003F032424001000002800323500000CF008087D8105010071630300EED501001F6F00003B350100F52E0000E35E0000B7B6000066EFFEFFB5F60000896200007A840200E28FFCFF080808080408120100000000A1A10178000000080050003B020726181818181A120A140E0600\0" ;
pub const NRF_WIFI_RF_PARAMS_OFF_RESV_1: u32 = 0;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_X0: u32 = 6;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_PDADJM7: u32 = 7;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_PDADJM0: u32 = 11;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_PWR2G: u32 = 15;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_PWR2GM0M7: u32 = 16;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_PWR5GM7: u32 = 18;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_PWR5GM0: u32 = 21;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_RXGNOFF: u32 = 24;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_MAX_TEMP: u32 = 28;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_MIN_TEMP: u32 = 29;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_TXP_BOFF_2GH: u32 = 30;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_TXP_BOFF_2GL: u32 = 31;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_TXP_BOFF_5GH: u32 = 32;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_TXP_BOFF_5GL: u32 = 33;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_TXP_BOFF_V: u32 = 34;
pub const NRF_WIFI_RF_PARAMS_OFF_CALIB_RESV_2: u32 = 37;
pub const NRF_WIFI_PHY_CALIB_FLAG_RXDC: u32 = 1;
pub const NRF_WIFI_PHY_CALIB_FLAG_TXDC: u32 = 2;
pub const NRF_WIFI_PHY_CALIB_FLAG_TXPOW: u32 = 0;
pub const NRF_WIFI_PHY_CALIB_FLAG_TXIQ: u32 = 8;
pub const NRF_WIFI_PHY_CALIB_FLAG_RXIQ: u32 = 16;
pub const NRF_WIFI_PHY_CALIB_FLAG_DPD: u32 = 32;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_RXDC: u32 = 65536;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_TXDC: u32 = 131072;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_TXPOW: u32 = 0;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_TXIQ: u32 = 0;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_RXIQ: u32 = 0;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_DPD: u32 = 0;
pub const NRF_WIFI_DEF_PHY_CALIB: u32 = 196667;
pub const NRF_WIFI_DEF_PHY_TEMP_CALIB: u32 = 59;
pub const NRF_WIFI_TEMP_CALIB_PERIOD: u32 = 1048576;
pub const NRF_WIFI_TEMP_CALIB_THRESHOLD: u32 = 40;
pub const NRF_WIFI_TEMP_CALIB_ENABLE: u32 = 1;
pub const NRF_WIFI_DEF_PHY_VBAT_CALIB: u32 = 32;
pub const NRF_WIFI_VBAT_VERYLOW: u32 = 8;
pub const NRF_WIFI_VBAT_LOW: u32 = 12;
pub const NRF_WIFI_VBAT_HIGH: u32 = 14;
pub const FT_PROG_VER1_2G_DSSS_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_2G_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_5G_LOW_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_5G_MID_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_5G_HIGH_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_2G_DSSS_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_2G_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_5G_LOW_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_5G_MID_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_5G_HIGH_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_2G_DSSS_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_2G_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_5G_LOW_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_5G_MID_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_5G_HIGH_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const RPU_MEM_LMAC_BOOT_SIG: u32 = 3070233936;
pub const RPU_MEM_LMAC_VER: u32 = 3070233940;
pub const RPU_MEM_LMAC_PATCH_BIN: u32 = 2147762176;
pub const RPU_MEM_LMAC_PATCH_BIMG: u32 = 2147790848;
pub const NRF_WIFI_LMAC_BOOT_SIG: u32 = 1515870810;
pub const NRF_WIFI_LMAC_ROM_PATCH_OFFSET: u32 = 45056;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_0: u32 = 1008369664;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_1: u32 = 660209664;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_2: u32 = 54525960;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_3: u32 = 0;
pub const NRF_WIFI_LMAC_MAX_RX_BUFS: u32 = 256;
pub const HW_SLEEP_ENABLE: u32 = 2;
pub const SW_SLEEP_ENABLE: u32 = 1;
pub const SLEEP_DISABLE: u32 = 0;
pub const HW_DELAY: u32 = 7350;
pub const SW_DELAY: u32 = 5000;
pub const BCN_TIMEOUT: u32 = 40000;
pub const CALIB_SLEEP_CLOCK_ENABLE: u32 = 1;
pub const ACTIVE_SCAN_DURATION: u32 = 50;
pub const PASSIVE_SCAN_DURATION: u32 = 130;
pub const WORKING_CH_SCAN_DURATION: u32 = 50;
pub const CHNL_PROBE_CNT: u32 = 2;
pub const PKT_TYPE_MPDU: u32 = 0;
pub const PKT_TYPE_MSDU_WITH_MAC: u32 = 1;
pub const PKT_TYPE_MSDU: u32 = 2;
pub const NRF_WIFI_RPU_PWR_STATUS_SUCCESS: u32 = 0;
pub const NRF_WIFI_RPU_PWR_STATUS_FAIL: i32 = -1;
pub const MAX_RSSI_SAMPLES: u32 = 10;
pub const FREQ_2_4_GHZ: u32 = 1;
pub const FREQ_5_GHZ: u32 = 2;
pub const NUM_32_QUEUES: u32 = 4;
pub const USE_PROTECTION_NONE: u32 = 0;
pub const USE_PROTECTION_RTS: u32 = 1;
pub const USE_PROTECTION_CTS2SELF: u32 = 2;
pub const USE_SHORT_PREAMBLE: u32 = 0;
pub const DONT_USE_SHORT_PREAMBLE: u32 = 1;
pub const MARK_RATE_AS_MCS_INDEX: u32 = 128;
pub const MARK_RATE_AS_RATE: u32 = 0;
pub const ENABLE_GREEN_FIELD: u32 = 1;
pub const ENABLE_CHNL_WIDTH_40MHZ: u32 = 2;
pub const ENABLE_SGI: u32 = 4;
pub const ENABLE_11N_FORMAT: u32 = 8;
pub const ENABLE_VHT_FORMAT: u32 = 16;
pub const ENABLE_CHNL_WIDTH_80MHZ: u32 = 32;
pub const MAX_TX_AGG_SIZE: u32 = 16;
pub const MAX_RX_BUFS_PER_EVNT: u32 = 64;
pub const MAX_MGMT_BUFS: u32 = 16;
pub const MAX_RF_CALIB_DATA: u32 = 900;
pub const NRF_WIFI_ETH_ADDR_LEN: u32 = 6;
pub const PHY_THRESHOLD_NORMAL: i32 = -65;
pub const PHY_THRESHOLD_PROD_MODE: i32 = -93;
pub const MAX_TX_STREAMS: u32 = 1;
pub const MAX_RX_STREAMS: u32 = 1;
pub const MAX_NUM_VIFS: u32 = 2;
pub const MAX_NUM_STAS: u32 = 2;
pub const MAX_NUM_APS: u32 = 1;
pub const NRF_WIFI_COUNTRY_CODE_LEN: u32 = 2;
pub const NRF_WIFI_FEATURE_DISABLE: u32 = 0;
pub const NRF_WIFI_FEATURE_ENABLE: u32 = 1;
pub const TWT_EXTEND_SP_EDCA: u32 = 1;
pub const NRF_WIFI_HE_GI_800NS: u32 = 0;
pub const NRF_WIFI_HE_GI_1600NS: u32 = 1;
pub const NRF_WIFI_HE_GI_3200NS: u32 = 2;
pub const NRF_WIFI_HE_LTF_3200NS: u32 = 0;
pub const NRF_WIFI_HE_LTF_6400NS: u32 = 1;
pub const NRF_WIFI_HE_LTF_12800NS: u32 = 2;
pub const NRF_WIFI_DISABLE: u32 = 0;
pub const NRF_WIFI_ENABLE: u32 = 1;
pub const TX_BUF_HEADROOM: u32 = 52;
pub const DSCP_TOS_MASK: u32 = 65535;
pub const DSCP_OR_TOS_TWT_EMERGENCY_TX: u32 = 2147483648;
pub const NRF_WIFI_TX_STATUS_SUCCESS: u32 = 0;
pub const NRF_WIFI_TX_STATUS_FAILED: u32 = 1;
pub const NRF_WIFI_CLIENT_ACTIVE: u32 = 0;
pub const NRF_WIFI_CLIENT_PS_MODE: u32 = 1;
pub const MAX_NRF_WIFI_UMAC_CMD_SIZE: u32 = 400;
pub const NRF_WIFI_MAX_SSID_LEN: u32 = 32;
pub const NRF_WIFI_MAX_IE_LEN: u32 = 400;
pub const NRF_WIFI_MAX_SEQ_LENGTH: u32 = 256;
pub const NRF_WIFI_MAX_KEY_LENGTH: u32 = 256;
pub const NRF_WIFI_MAX_SAE_DATA_LENGTH: u32 = 256;
pub const NRF_WIFI_MAX_FRAME_LEN: u32 = 400;
pub const NRF_WIFI_INDEX_IDS_WDEV_ID_VALID: u32 = 1;
pub const NRF_WIFI_INDEX_IDS_IFINDEX_VALID: u32 = 2;
pub const NRF_WIFI_INDEX_IDS_WIPHY_IDX_VALID: u32 = 4;
pub const NRF_WIFI_SUPP_RATES_BAND_VALID: u32 = 1;
pub const NRF_WIFI_MAX_SUPP_RATES: u32 = 60;
pub const NRF_WIFI_SCAN_MAX_NUM_SSIDS: u32 = 2;
pub const NRF_WIFI_SCAN_MAX_NUM_FREQUENCIES: u32 = 64;
pub const NRF_WIFI_SCAN_BAND_2GHZ: u32 = 1;
pub const NRF_WIFI_SCAN_BAND_5GHZ: u32 = 2;
pub const NRF_WIFI_SCAN_BAND_6GHZ: u32 = 4;
pub const NRF_WIFI_HT_CAPABILITY_VALID: u32 = 1;
pub const NRF_WIFI_HT_CAPABILITY_MASK_VALID: u32 = 2;
pub const NRF_WIFI_VHT_CAPABILITY_VALID: u32 = 4;
pub const NRF_WIFI_VHT_CAPABILITY_MASK_VALID: u32 = 8;
pub const NRF_WIFI_CMD_HT_VHT_CAPABILITY_DISABLE_HT: u32 = 1;
pub const NRF_WIFI_HT_VHT_CAPABILITY_MAX_SIZE: u32 = 256;
pub const NRF_WIFI_SIGNAL_TYPE_NONE: u32 = 1;
pub const NRF_WIFI_SIGNAL_TYPE_MBM: u32 = 2;
pub const NRF_WIFI_SIGNAL_TYPE_UNSPEC: u32 = 3;
pub const NRF_WIFI_WPA_VERSION_1: u32 = 1;
pub const NRF_WIFI_WPA_VERSION_2: u32 = 2;
pub const NRF_WIFI_CONNECT_COMMON_INFO_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CONNECT_COMMON_INFO_MAC_ADDR_HINT_VALID: u32 = 2;
pub const NRF_WIFI_CONNECT_COMMON_INFO_FREQ_VALID: u32 = 4;
pub const NRF_WIFI_CONNECT_COMMON_INFO_FREQ_HINT_VALID: u32 = 8;
pub const NRF_WIFI_CONNECT_COMMON_INFO_BG_SCAN_PERIOD_VALID: u32 = 16;
pub const NRF_WIFI_CONNECT_COMMON_INFO_SSID_VALID: u32 = 32;
pub const NRF_WIFI_CONNECT_COMMON_INFO_WPA_IE_VALID: u32 = 64;
pub const NRF_WIFI_CONNECT_COMMON_INFO_WPA_VERSIONS_VALID: u32 = 128;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CIPHER_SUITES_PAIRWISE_VALID: u32 = 256;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CIPHER_SUITE_GROUP_VALID: u32 = 512;
pub const NRF_WIFI_CONNECT_COMMON_INFO_AKM_SUITES_VALID: u32 = 1024;
pub const NRF_WIFI_CONNECT_COMMON_INFO_USE_MFP_VALID: u32 = 2048;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CONTROL_PORT_ETHER_TYPE: u32 = 4096;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CONTROL_PORT_NO_ENCRYPT: u32 = 8192;
pub const NRF_WIFI_MAX_NR_AKM_SUITES: u32 = 2;
pub const NRF_WIFI_CMD_CONNECT_COMMON_INFO_USE_RRM: u32 = 16384;
pub const NRF_WIFI_CONNECT_COMMON_INFO_PREV_BSSID: u32 = 32768;
pub const NRF_WIFI_BEACON_DATA_MAX_HEAD_LEN: u32 = 256;
pub const NRF_WIFI_BEACON_DATA_MAX_TAIL_LEN: u32 = 512;
pub const NRF_WIFI_BEACON_DATA_MAX_PROBE_RESP_LEN: u32 = 400;
pub const NRF_WIFI_STA_FLAG_INVALID: u32 = 1;
pub const NRF_WIFI_STA_FLAG_AUTHORIZED: u32 = 2;
pub const NRF_WIFI_STA_FLAG_SHORT_PREAMBLE: u32 = 4;
pub const NRF_WIFI_STA_FLAG_WME: u32 = 8;
pub const NRF_WIFI_STA_FLAG_MFP: u32 = 16;
pub const NRF_WIFI_STA_FLAG_AUTHENTICATED: u32 = 32;
pub const NRF_WIFI_STA_FLAG_TDLS_PEER: u32 = 64;
pub const NRF_WIFI_STA_FLAG_ASSOCIATED: u32 = 128;
pub const NRF_WIFI_RATE_INFO_BITRATE_VALID: u32 = 1;
pub const NRF_WIFI_RATE_INFO_BITRATE_COMPAT_VALID: u32 = 2;
pub const NRF_WIFI_RATE_INFO_BITRATE_MCS_VALID: u32 = 4;
pub const NRF_WIFI_RATE_INFO_BITRATE_VHT_MCS_VALID: u32 = 8;
pub const NRF_WIFI_RATE_INFO_BITRATE_VHT_NSS_VALID: u32 = 16;
pub const NRF_WIFI_RATE_INFO_0_MHZ_WIDTH: u32 = 1;
pub const NRF_WIFI_RATE_INFO_5_MHZ_WIDTH: u32 = 2;
pub const NRF_WIFI_RATE_INFO_10_MHZ_WIDTH: u32 = 4;
pub const NRF_WIFI_RATE_INFO_40_MHZ_WIDTH: u32 = 8;
pub const NRF_WIFI_RATE_INFO_80_MHZ_WIDTH: u32 = 16;
pub const NRF_WIFI_RATE_INFO_160_MHZ_WIDTH: u32 = 32;
pub const NRF_WIFI_RATE_INFO_SHORT_GI: u32 = 64;
pub const NRF_WIFI_RATE_INFO_80P80_MHZ_WIDTH: u32 = 128;
pub const NRF_WIFI_BSS_PARAM_FLAGS_CTS_PROT: u32 = 1;
pub const NRF_WIFI_BSS_PARAM_FLAGS_SHORT_PREAMBLE: u32 = 2;
pub const NRF_WIFI_BSS_PARAM_FLAGS_SHORT_SLOT_TIME: u32 = 4;
pub const NRF_WIFI_STA_INFO_CONNECTED_TIME_VALID: u32 = 1;
pub const NRF_WIFI_STA_INFO_INACTIVE_TIME_VALID: u32 = 2;
pub const NRF_WIFI_STA_INFO_RX_BYTES_VALID: u32 = 4;
pub const NRF_WIFI_STA_INFO_TX_BYTES_VALID: u32 = 8;
pub const NRF_WIFI_STA_INFO_CHAIN_SIGNAL_VALID: u32 = 16;
pub const NRF_WIFI_STA_INFO_CHAIN_SIGNAL_AVG_VALID: u32 = 32;
pub const NRF_WIFI_STA_INFO_TX_BITRATE_VALID: u32 = 64;
pub const NRF_WIFI_STA_INFO_RX_BITRATE_VALID: u32 = 128;
pub const NRF_WIFI_STA_INFO_STA_FLAGS_VALID: u32 = 256;
pub const NRF_WIFI_STA_INFO_LLID_VALID: u32 = 512;
pub const NRF_WIFI_STA_INFO_PLID_VALID: u32 = 1024;
pub const NRF_WIFI_STA_INFO_PLINK_STATE_VALID: u32 = 2048;
pub const NRF_WIFI_STA_INFO_SIGNAL_VALID: u32 = 4096;
pub const NRF_WIFI_STA_INFO_SIGNAL_AVG_VALID: u32 = 8192;
pub const NRF_WIFI_STA_INFO_RX_PACKETS_VALID: u32 = 16384;
pub const NRF_WIFI_STA_INFO_TX_PACKETS_VALID: u32 = 32768;
pub const NRF_WIFI_STA_INFO_TX_RETRIES_VALID: u32 = 65536;
pub const NRF_WIFI_STA_INFO_TX_FAILED_VALID: u32 = 131072;
pub const NRF_WIFI_STA_INFO_EXPECTED_THROUGHPUT_VALID: u32 = 262144;
pub const NRF_WIFI_STA_INFO_BEACON_LOSS_COUNT_VALID: u32 = 524288;
pub const NRF_WIFI_STA_INFO_LOCAL_PM_VALID: u32 = 1048576;
pub const NRF_WIFI_STA_INFO_PEER_PM_VALID: u32 = 2097152;
pub const NRF_WIFI_STA_INFO_NONPEER_PM_VALID: u32 = 4194304;
pub const NRF_WIFI_STA_INFO_T_OFFSET_VALID: u32 = 8388608;
pub const NRF_WIFI_STA_INFO_RX_DROPPED_MISC_VALID: u32 = 16777216;
pub const NRF_WIFI_STA_INFO_RX_BEACON_VALID: u32 = 33554432;
pub const NRF_WIFI_STA_INFO_RX_BEACON_SIGNAL_AVG_VALID: u32 = 67108864;
pub const NRF_WIFI_STA_INFO_STA_BSS_PARAMS_VALID: u32 = 134217728;
pub const NRF_WIFI_IEEE80211_MAX_CHAINS: u32 = 4;
pub const NRF_WIFI_KEY_VALID: u32 = 1;
pub const NRF_WIFI_KEY_TYPE_VALID: u32 = 2;
pub const NRF_WIFI_KEY_IDX_VALID: u32 = 4;
pub const NRF_WIFI_SEQ_VALID: u32 = 8;
pub const NRF_WIFI_CIPHER_SUITE_VALID: u32 = 16;
pub const NRF_WIFI_KEY_INFO_VALID: u32 = 32;
pub const NRF_WIFI_KEY_DEFAULT: u32 = 1;
pub const NRF_WIFI_KEY_DEFAULT_TYPES: u32 = 2;
pub const NRF_WIFI_KEY_DEFAULT_MGMT: u32 = 4;
pub const NRF_WIFI_KEY_DEFAULT_TYPE_UNICAST: u32 = 8;
pub const NRF_WIFI_KEY_DEFAULT_TYPE_MULTICAST: u32 = 16;
pub const MCAST_ADDR_ADD: u32 = 0;
pub const MCAST_ADDR_DEL: u32 = 1;
pub const NRF_WIFI_CMD_AUTHENTICATE_KEY_INFO_VALID: u32 = 1;
pub const NRF_WIFI_CMD_AUTHENTICATE_BSSID_VALID: u32 = 2;
pub const NRF_WIFI_CMD_AUTHENTICATE_FREQ_VALID: u32 = 4;
pub const NRF_WIFI_CMD_AUTHENTICATE_SSID_VALID: u32 = 8;
pub const NRF_WIFI_CMD_AUTHENTICATE_IE_VALID: u32 = 16;
pub const NRF_WIFI_CMD_AUTHENTICATE_SAE_VALID: u32 = 32;
pub const NRF_WIFI_CMD_AUTHENTICATE_LOCAL_STATE_CHANGE: u32 = 1;
pub const NRF_WIFI_CMD_ASSOCIATE_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_MLME_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_MLME_LOCAL_STATE_CHANGE: u32 = 1;
pub const NRF_WIFI_CMD_NEW_INTERFACE_USE_4ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_NEW_INTERFACE_MAC_ADDR_VALID: u32 = 2;
pub const NRF_WIFI_CMD_NEW_INTERFACE_IFTYPE_VALID: u32 = 4;
pub const NRF_WIFI_CMD_NEW_INTERFACE_IFNAME_VALID: u32 = 8;
pub const NRF_WIFI_FRAME_MATCH_MAX_LEN: u32 = 8;
pub const NRF_WIFI_CMD_KEY_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_BSS_CTS_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_BSS_PREAMBLE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_BSS_SLOT_VALID: u32 = 4;
pub const NRF_WIFI_CMD_SET_BSS_HT_OPMODE_VALID: u32 = 8;
pub const NRF_WIFI_CMD_SET_BSS_AP_ISOLATE_VALID: u32 = 16;
pub const NRF_WIFI_CMD_SET_BSS_P2P_CTWINDOW_VALID: u32 = 32;
pub const NRF_WIFI_CMD_SET_BSS_P2P_OPPPS_VALID: u32 = 64;
pub const NRF_WIFI_BASIC_MAX_SUPP_RATES: u32 = 32;
pub const NRF_WIFI_SET_FREQ_PARAMS_FREQ_VALID: u32 = 1;
pub const NRF_WIFI_SET_FREQ_PARAMS_CHANNEL_WIDTH_VALID: u32 = 2;
pub const NRF_WIFI_SET_FREQ_PARAMS_CENTER_FREQ1_VALID: u32 = 4;
pub const NRF_WIFI_SET_FREQ_PARAMS_CENTER_FREQ2_VALID: u32 = 8;
pub const NRF_WIFI_SET_FREQ_PARAMS_CHANNEL_TYPE_VALID: u32 = 16;
pub const NRF_WIFI_TX_POWER_SETTING_TYPE_VALID: u32 = 1;
pub const NRF_WIFI_TX_POWER_SETTING_TX_POWER_LEVEL_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_WIPHY_FREQ_PARAMS_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_WIPHY_TXQ_PARAMS_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_WIPHY_RTS_THRESHOLD_VALID: u32 = 4;
pub const NRF_WIFI_CMD_SET_WIPHY_FRAG_THRESHOLD_VALID: u32 = 8;
pub const NRF_WIFI_CMD_SET_WIPHY_TX_POWER_SETTING_VALID: u32 = 16;
pub const NRF_WIFI_CMD_SET_WIPHY_ANTENNA_TX_VALID: u32 = 32;
pub const NRF_WIFI_CMD_SET_WIPHY_ANTENNA_RX_VALID: u32 = 64;
pub const NRF_WIFI_CMD_SET_WIPHY_RETRY_SHORT_VALID: u32 = 128;
pub const NRF_WIFI_CMD_SET_WIPHY_RETRY_LONG_VALID: u32 = 256;
pub const NRF_WIFI_CMD_SET_WIPHY_COVERAGE_CLASS_VALID: u32 = 512;
pub const NRF_WIFI_CMD_SET_WIPHY_WIPHY_NAME_VALID: u32 = 1024;
pub const NRF_WIFI_CMD_DEL_STATION_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_DEL_STATION_MGMT_SUBTYPE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_DEL_STATION_REASON_CODE_VALID: u32 = 4;
pub const NRF_WIFI_EXT_CAPABILITY_MAX_LEN: u32 = 32;
pub const NRF_WIFI_SUPPORTED_CHANNELS_MAX_LEN: u32 = 64;
pub const NRF_WIFI_OPER_CLASSES_MAX_LEN: u32 = 64;
pub const NRF_WIFI_STA_FLAGS2_MAX_LEN: u32 = 64;
pub const NRF_WIFI_CMD_SET_STATION_SUPP_RATES_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_STATION_AID_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_STATION_PEER_AID_VALID: u32 = 4;
pub const NRF_WIFI_CMD_SET_STATION_STA_CAPABILITY_VALID: u32 = 8;
pub const NRF_WIFI_CMD_SET_STATION_EXT_CAPABILITY_VALID: u32 = 16;
pub const NRF_WIFI_CMD_SET_STATION_STA_VLAN_VALID: u32 = 32;
pub const NRF_WIFI_CMD_SET_STATION_HT_CAPABILITY_VALID: u32 = 64;
pub const NRF_WIFI_CMD_SET_STATION_VHT_CAPABILITY_VALID: u32 = 128;
pub const NRF_WIFI_CMD_SET_STATION_OPMODE_NOTIF_VALID: u32 = 512;
pub const NRF_WIFI_CMD_SET_STATION_SUPPORTED_CHANNELS_VALID: u32 = 1024;
pub const NRF_WIFI_CMD_SET_STATION_SUPPORTED_OPER_CLASSES_VALID: u32 = 2048;
pub const NRF_WIFI_CMD_SET_STATION_STA_FLAGS2_VALID: u32 = 4096;
pub const NRF_WIFI_CMD_SET_STATION_STA_WME_UAPSD_QUEUES_VALID: u32 = 8192;
pub const NRF_WIFI_CMD_SET_STATION_STA_WME_MAX_SP_VALID: u32 = 16384;
pub const NRF_WIFI_CMD_SET_STATION_LISTEN_INTERVAL_VALID: u32 = 32768;
pub const NRF_WIFI_CMD_NEW_STATION_SUPP_RATES_VALID: u32 = 1;
pub const NRF_WIFI_CMD_NEW_STATION_AID_VALID: u32 = 2;
pub const NRF_WIFI_CMD_NEW_STATION_PEER_AID_VALID: u32 = 4;
pub const NRF_WIFI_CMD_NEW_STATION_STA_CAPABILITY_VALID: u32 = 8;
pub const NRF_WIFI_CMD_NEW_STATION_EXT_CAPABILITY_VALID: u32 = 16;
pub const NRF_WIFI_CMD_NEW_STATION_STA_VLAN_VALID: u32 = 32;
pub const NRF_WIFI_CMD_NEW_STATION_HT_CAPABILITY_VALID: u32 = 64;
pub const NRF_WIFI_CMD_NEW_STATION_VHT_CAPABILITY_VALID: u32 = 128;
pub const NRF_WIFI_CMD_NEW_STATION_OPMODE_NOTIF_VALID: u32 = 512;
pub const NRF_WIFI_CMD_NEW_STATION_SUPPORTED_CHANNELS_VALID: u32 = 1024;
pub const NRF_WIFI_CMD_NEW_STATION_SUPPORTED_OPER_CLASSES_VALID: u32 = 2048;
pub const NRF_WIFI_CMD_NEW_STATION_STA_FLAGS2_VALID: u32 = 4096;
pub const NRF_WIFI_CMD_NEW_STATION_STA_WME_UAPSD_QUEUES_VALID: u32 = 8192;
pub const NRF_WIFI_CMD_NEW_STATION_STA_WME_MAX_SP_VALID: u32 = 16384;
pub const NRF_WIFI_CMD_NEW_STATION_LISTEN_INTERVAL_VALID: u32 = 32768;
pub const NRF_WIFI_CMD_BEACON_INFO_BEACON_INTERVAL_VALID: u32 = 1;
pub const NRF_WIFI_CMD_BEACON_INFO_AUTH_TYPE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_BEACON_INFO_VERSIONS_VALID: u32 = 4;
pub const NRF_WIFI_CMD_BEACON_INFO_CIPHER_SUITE_GROUP_VALID: u32 = 8;
pub const NRF_WIFI_CMD_BEACON_INFO_INACTIVITY_TIMEOUT_VALID: u32 = 16;
pub const NRF_WIFI_CMD_BEACON_INFO_FREQ_PARAMS_VALID: u32 = 32;
pub const NRF_WIFI_CMD_BEACON_INFO_PRIVACY: u32 = 1;
pub const NRF_WIFI_CMD_BEACON_INFO_CONTROL_PORT_NO_ENCRYPT: u32 = 2;
pub const NRF_WIFI_CMD_BEACON_INFO_P2P_CTWINDOW_VALID: u32 = 64;
pub const NRF_WIFI_CMD_BEACON_INFO_P2P_OPPPS_VALID: u32 = 128;
pub const NRF_WIFI_SET_INTERFACE_IFTYPE_VALID: u32 = 1;
pub const NRF_WIFI_SET_INTERFACE_USE_4ADDR_VALID: u32 = 2;
pub const IFACENAMSIZ: u32 = 16;
pub const NRF_WIFI_CMD_FRAME_FREQ_VALID: u32 = 1;
pub const NRF_WIFI_CMD_FRAME_DURATION_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_FRAME_FREQ_PARAMS_VALID: u32 = 4;
pub const NRF_WIFI_CMD_FRAME_OFFCHANNEL_TX_OK: u32 = 1;
pub const NRF_WIFI_CMD_FRAME_TX_NO_CCK_RATE: u32 = 2;
pub const NRF_WIFI_CMD_FRAME_DONT_WAIT_FOR_ACK: u32 = 4;
pub const NRF_WIFI_TWT_NEGOTIATION_TYPE_INDIVIDUAL: u32 = 0;
pub const NRF_WIFI_TWT_NEGOTIATION_TYPE_BROADCAST: u32 = 2;
pub const NRF_WIFI_TWT_FLOW_TYPE_ANNOUNCED: u32 = 0;
pub const NRF_WIFI_TWT_FLOW_TYPE_UNANNOUNCED: u32 = 1;
pub const NRF_WIFI_TWT_RESP_RECEIVED: u32 = 0;
pub const NRF_WIFI_TWT_RESP_NOT_RECEIVED: u32 = 1;
pub const NRF_WIFI_INVALID_TWT_WAKE_INTERVAL: u32 = 3;
pub const INVALID_TIME: u32 = 1;
pub const TRIGGER_NOT_RECEIVED: u32 = 2;
pub const TWT_BLOCK_TX: u32 = 0;
pub const TWT_UNBLOCK_TX: u32 = 1;
pub const UAPSD_Q_MIN: u32 = 0;
pub const UAPSD_Q_MAX: u32 = 15;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_IES_TSF_VALID: u32 = 2;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_IES_VALID: u32 = 4;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BEACON_IES_TSF_VALID: u32 = 8;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BEACON_IES_VALID: u32 = 16;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BEACON_INTERVAL_VALID: u32 = 32;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_SIGNAL_VALID: u32 = 64;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_STATUS_VALID: u32 = 128;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BSS_PRESP_DATA: u32 = 256;
pub const NRF_WIFI_NEW_SCAN_RESULTS_BSS_PRESP_DATA: u32 = 1;
pub const NRF_WIFI_802_11A: u32 = 1;
pub const NRF_WIFI_802_11B: u32 = 2;
pub const NRF_WIFI_802_11G: u32 = 4;
pub const NRF_WIFI_802_11N: u32 = 8;
pub const NRF_WIFI_802_11AC: u32 = 16;
pub const NRF_WIFI_802_11AX: u32 = 32;
pub const NRF_WIFI_MFP_REQUIRED: u32 = 1;
pub const NRF_WIFI_MFP_CAPABLE: u32 = 2;
pub const DISPLAY_BSS_TOHOST_PEREVNT: u32 = 8;
pub const NRF_WIFI_EVENT_MLME_FRAME_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_MLME_MAC_ADDR_VALID: u32 = 2;
pub const NRF_WIFI_EVENT_MLME_FREQ_VALID: u32 = 4;
pub const NRF_WIFI_EVENT_MLME_COOKIE_VALID: u32 = 8;
pub const NRF_WIFI_EVENT_MLME_RX_SIGNAL_DBM_VALID: u32 = 16;
pub const NRF_WIFI_EVENT_MLME_WME_UAPSD_QUEUES_VALID: u32 = 32;
pub const NRF_WIFI_EVENT_MLME_RXMGMT_FLAGS_VALID: u32 = 64;
pub const NRF_WIFI_EVENT_MLME_IE_VALID: u32 = 128;
pub const NRF_WIFI_EVENT_MLME_TIMED_OUT: u32 = 1;
pub const NRF_WIFI_EVENT_MLME_ACK: u32 = 2;
pub const NRF_WIFI_CMD_SEND_STATION_ASSOC_REQ_IES_VALID: u32 = 1;
pub const NRF_WIFI_CMD_COOKIE_RSP_COOKIE_VALID: u32 = 1;
pub const NRF_WIFI_CMD_COOKIE_RSP_MAC_ADDR_VALID: u32 = 2;
pub const NRF_WIFI_MAX_TWT_FLOWS: u32 = 8;
pub const NRF_WIFI_PS_MODE_LEGACY: u32 = 0;
pub const NRF_WIFI_PS_MODE_WMM: u32 = 1;
pub const NRF_WIFI_LISTEN_INTERVAL_MIN: u32 = 3;
pub const NRF_WIFI_EVENT_TRIGGER_SCAN_IE_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_TRIGGER_SCAN_SCAN_FLAGS_VALID: u32 = 2;
pub const NRF_WIFI_CMD_ROC_FREQ_PARAMS_VALID: u32 = 1;
pub const NRF_WIFI_CMD_ROC_DURATION_VALID: u32 = 2;
pub const NRF_WIFI_CMD_CANCEL_ROC_COOKIE_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_ROC_FREQ_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_ROC_COOKIE_VALID: u32 = 2;
pub const NRF_WIFI_EVENT_ROC_DURATION_VALID: u32 = 4;
pub const NRF_WIFI_EVENT_ROC_CH_TYPE_VALID: u32 = 8;
pub const NRF_WIFI_INTERFACE_INFO_CHAN_DEF_VALID: u32 = 1;
pub const NRF_WIFI_INTERFACE_INFO_SSID_VALID: u32 = 2;
pub const NRF_WIFI_INTERFACE_INFO_IFNAME_VALID: u32 = 4;
pub const NRF_WIFI_HT_MCS_MASK_LEN: u32 = 10;
pub const NRF_WIFI_HT_MCS_RES_LEN: u32 = 3;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_IR: u32 = 1;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_IBSS: u32 = 2;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_RADAR: u32 = 4;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_HT40_MINUS: u32 = 8;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_HT40_PLUS: u32 = 16;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_80MHZ: u32 = 32;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_160MHZ: u32 = 64;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_INDOOR_ONLY: u32 = 128;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_GO_CONCURRENT: u32 = 256;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_20MHZ: u32 = 512;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_10MHZ: u32 = 1024;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_DISABLED: u32 = 2048;
pub const NRF_WIFI_CHAN_DFS_VALID: u32 = 4096;
pub const NRF_WIFI_CHAN_DFS_CAC_TIME_VALID: u32 = 8192;
pub const NRF_WIFI_EVENT_GET_WIPHY_FLAG_RATE_SHORT_PREAMBLE: u32 = 1;
pub const NRF_WIFI_EVENT_GET_WIPHY_VALID_RADAR_DETECT_WIDTHS: u32 = 1;
pub const NRF_WIFI_EVENT_GET_WIPHY_VALID_RADAR_DETECT_REGIONS: u32 = 2;
pub const NRF_WIFI_EVENT_GET_WIPHY_VALID_: u32 = 4;
pub const NRF_WIFI_EVENT_GET_WIPHY_IBSS_RSN: u32 = 1;
pub const NRF_WIFI_EVENT_GET_WIPHY_MESH_AUTH: u32 = 2;
pub const NRF_WIFI_EVENT_GET_WIPHY_AP_UAPSD: u32 = 4;
pub const NRF_WIFI_EVENT_GET_WIPHY_SUPPORTS_FW_ROAM: u32 = 8;
pub const NRF_WIFI_EVENT_GET_WIPHY_SUPPORTS_TDLS: u32 = 16;
pub const NRF_WIFI_EVENT_GET_WIPHY_TDLS_EXTERNAL_SETUP: u32 = 32;
pub const NRF_WIFI_EVENT_GET_WIPHY_CONTROL_PORT_ETHERTYPE: u32 = 64;
pub const NRF_WIFI_EVENT_GET_WIPHY_OFFCHANNEL_TX_OK: u32 = 128;
pub const NRF_WIFI_GET_WIPHY_VALID_PROBE_RESP_OFFLOAD: u32 = 1;
pub const NRF_WIFI_GET_WIPHY_VALID_TX_ANT: u32 = 2;
pub const NRF_WIFI_GET_WIPHY_VALID_RX_ANT: u32 = 4;
pub const NRF_WIFI_GET_WIPHY_VALID_MAX_NUM_SCAN_SSIDS: u32 = 8;
pub const NRF_WIFI_GET_WIPHY_VALID_NUM_SCHED_SCAN_SSIDS: u32 = 16;
pub const NRF_WIFI_GET_WIPHY_VALID_MAX_MATCH_SETS: u32 = 32;
pub const NRF_WIFI_GET_WIPHY_VALID_MAC_ACL_MAX: u32 = 64;
pub const NRF_WIFI_GET_WIPHY_VALID_HAVE_AP_SME: u32 = 128;
pub const NRF_WIFI_GET_WIPHY_VALID_EXTENDED_CAPABILITIES: u32 = 256;
pub const NRF_WIFI_GET_WIPHY_VALID_MAX_AP_ASSOC_STA: u32 = 512;
pub const NRF_WIFI_GET_WIPHY_VALID_WIPHY_NAME: u32 = 1024;
pub const NRF_WIFI_GET_WIPHY_VALID_EXTENDED_FEATURES: u32 = 2048;
pub const NRF_WIFI_EVENT_GET_WIPHY_MAX_CIPHER_COUNT: u32 = 30;
pub const NRF_WIFI_INDEX_IDS_WIPHY_NAME: u32 = 32;
pub const NRF_WIFI_EVENT_GET_WIPHY_NUM_BANDS: u32 = 2;
pub const EXTENDED_FEATURE_LEN: u32 = 60;
pub const REG_RULE_FLAGS_VALID: u32 = 1;
pub const FREQ_RANGE_START_VALID: u32 = 2;
pub const FREQ_RANGE_END_VALID: u32 = 4;
pub const FREQ_RANGE_MAX_BW_VALID: u32 = 8;
pub const POWER_RULE_MAX_EIRP_VALID: u32 = 16;
pub const NRF_WIFI_RULE_FLAGS_NO_OFDM: u32 = 1;
pub const NRF_WIFI_RULE_FLAGS_NO_CCK: u32 = 2;
pub const NRF_WIFI_RULE_FLAGS_NO_INDOOR: u32 = 4;
pub const NRF_WIFI_RULE_FLAGS_NO_OUTDOOR: u32 = 8;
pub const NRF_WIFI_RULE_FLAGS_DFS: u32 = 16;
pub const NRF_WIFI_RULE_FLAGS_PTP_ONLY: u32 = 32;
pub const NRF_WIFI_RULE_FLAGS_PTMP_ONLY: u32 = 64;
pub const NRF_WIFI_RULE_FLAGS_NO_IR: u32 = 128;
pub const NRF_WIFI_RULE_FLAGS_IBSS: u32 = 256;
pub const NRF_WIFI_RULE_FLAGS_AUTO_BW: u32 = 2048;
pub const NRF_WIFI_RULE_FLAGS_IR_CONCURRENT: u32 = 4096;
pub const NRF_WIFI_RULE_FLAGS_NO_HT40MINUS: u32 = 8192;
pub const NRF_WIFI_RULE_FLAGS_NO_HT40PLUS: u32 = 16384;
pub const NRF_WIFI_RULE_FLAGS_NO_80MHZ: u32 = 32768;
pub const NRF_WIFI_RULE_FLAGS_NO_160MHZ: u32 = 65536;
pub const NRF_WIFI_CMD_SET_REG_ALPHA2_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_REG_RULES_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_REG_DFS_REGION_VALID: u32 = 4;
pub const MAX_NUM_REG_RULES: u32 = 32;
pub const NRF_WIFI_CMD_REQ_SET_REG_ALPHA2_VALID: u32 = 1;
pub const NRF_WIFI_CMD_REQ_SET_REG_USER_REG_HINT_TYPE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_REQ_SET_REG_USER_REG_FORCE: u32 = 4;
pub const MAX_PEERS: u32 = 5;
pub const MAX_SW_PEERS: u32 = 6;
pub const NRF_WIFI_AC_TWT_PRIORITY_EMERGENCY: u32 = 255;
pub const NRF_WIFI_FMAC_STATS_RECV_TIMEOUT: u32 = 50;
pub const NRF_WIFI_FMAC_PS_CONF_EVNT_RECV_TIMEOUT: u32 = 50;
pub const HOST_PKTRAM_BB_START: u32 = 46137344;
pub const HOST_PKTRAM_BB_LEN: u32 = 4194304;
pub const MAX_HAL_RPU_READY_WAIT: u32 = 1000000;
pub type va_list = u32;
pub type __gnuc_va_list = u32;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(i32)]
#[doc = " enum nrf_wifi_status - The status of an operation performed by the\n                        RPU driver.\n @NRF_WIFI_STATUS_SUCCESS: The operation was successful.\n @NRF_WIFI_STATUS_FAIL: The operation failed.\n\n This enum lists the possible outcomes of an operation performed by the\n RPU driver."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_status {
    NRF_WIFI_STATUS_SUCCESS = 0,
    NRF_WIFI_STATUS_FAIL = -1,
}
#[repr(u32)]
#[doc = " enum nrf_wifi_osal_dma_dir - DMA direction for a DMA operation\n @NRF_WIFI_OSAL_DMA_DIR_TO_DEV: Data needs to be DMAed to the device.\n @NRF_WIFI_DMA_DIR_FROM_DEV: Data needs to be DMAed from the device.\n @NRF_WIFI_DMA_DIR_BIDI: Data can be DMAed in either direction i.e to\n                        or from the device.\n\n This enum lists the possible directions for a DMA operation i.e whether the\n DMA operation is for transferring data to or from a device"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_osal_dma_dir {
    NRF_WIFI_OSAL_DMA_DIR_TO_DEV = 0,
    NRF_WIFI_OSAL_DMA_DIR_FROM_DEV = 1,
    NRF_WIFI_OSAL_DMA_DIR_BIDI = 2,
}
#[repr(u32)]
#[doc = " enum nrf_wifi_tasklet_type - The type of a tasklet\n @NRF_WIFI_TASKLET_TYPE_BH: The tasklet is a bottom half tasklet i.e it is\n\t\tscheduled from an interrupt context used for all except\n\t\tTX done tasklets.\n @NRF_WIFI_TASKLET_TYPE_IRQ: The tasklet is an IRQ tasklet. It is scheduled\n\t\tfrom the Bus ISR, used internally by the SHIM layer.\n @NRF_WIFI_TASKLET_TYPE_TX_DONE: The tasklet is a TX done tasklet. It is\n\t\tscheduled from the BH tasklet for TX done interrupts.\n @NRF_WIFI_TASKLET_TYPE_RX: The tasklet is an RX tasklet. It is scheduled\n\t\tfrom the BH tasklet for RX interrupts.\n @NRF_WIFI_TASKLET_TYPE_MAX: The maximum number of tasklet types.\n\n This enum lists the possible types of a tasklet.\n Each tasklet type is associated with its own work queue."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_tasklet_type {
    NRF_WIFI_TASKLET_TYPE_BH = 0,
    NRF_WIFI_TASKLET_TYPE_IRQ = 1,
    NRF_WIFI_TASKLET_TYPE_TX_DONE = 2,
    NRF_WIFI_TASKLET_TYPE_RX = 3,
    NRF_WIFI_TASKLET_TYPE_MAX = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_osal_host_map {
    pub addr: ::core::ffi::c_ulong,
    pub size: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_osal_host_map() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_osal_host_map> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_osal_host_map>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_osal_host_map))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_osal_host_map>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_osal_host_map))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_host_map),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_host_map),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_osal_priv {
    pub ops: *const nrf_wifi_osal_ops,
}
#[test]
fn bindgen_test_layout_nrf_wifi_osal_priv() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_osal_priv> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_osal_priv>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_osal_priv))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_osal_priv>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_osal_priv))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_priv),
            "::",
            stringify!(ops)
        )
    );
}
#[repr(u32)]
#[doc = " enum nrf_wifi_assert_type - The type of assertion operation has to be done\n @NRF_WIFI_ASSERT_EQUAL_TO: The assertion check for equality.\n @NRF_WIFI_ASSERT_NOT_EQUAL_TO: The assertion check for non-equality.\n @NRF_WIFI_ASSERT_LESS_THAN: The assertion check for lesser value.\n @NRF_WIFI_ASSERT_LESS_THAN_OR_EQUAL_TO: The assertion check\n\t\tfor equal or lesser.\n @NRF_WIFI_ASSERT_MORE_THAN: The assertion check for condition\n\t\tof more than value.\n @NRF_WIFI_ASSERT_MORE_THAN_OR_EQUAL_TO: The assertion check for condition\n\t\tequal or more than value.\n\n This enum lists the possible type of operation in the assertion\n check should be taken."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_assert_op_type {
    NRF_WIFI_ASSERT_EQUAL_TO = 0,
    NRF_WIFI_ASSERT_NOT_EQUAL_TO = 1,
    NRF_WIFI_ASSERT_LESS_THAN = 2,
    NRF_WIFI_ASSERT_LESS_THAN_EQUAL_TO = 3,
    NRF_WIFI_ASSERT_GREATER_THAN = 4,
    NRF_WIFI_ASSERT_GREATER_THAN_EQUAL_TO = 5,
}
extern "C" {
    #[doc = " nrf_wifi_osal_init() - Initialize the OSAL layer.\n\n Initializes the OSAL layer and is expected to be called\n before using the OSAL layer. Returns a pointer to the OSAL context\n which might need to be passed to further API calls.\n\n Return: Pointer to instance of OSAL context."]
    pub fn nrf_wifi_osal_init() -> *mut nrf_wifi_osal_priv;
}
extern "C" {
    #[doc = " nrf_wifi_osal_deinit() - Deinitialize the OSAL layer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n\n Deinitializes the OSAL layer and is expected to be called after done using\n the OSAL layer.\n\n Return: None."]
    pub fn nrf_wifi_osal_deinit(opriv: *mut nrf_wifi_osal_priv);
}
extern "C" {
    #[doc = " nrf_wifi_osal_mem_alloc() - Allocate memory.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @size: Size of the memory to be allocated in bytes.\n\n Allocates memory of @size bytes and returns a pointer to the start\n of the memory allocated.\n\n Return:\n\t\tPass: Pointer to start of allocated memory.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_mem_alloc(
        opriv: *mut nrf_wifi_osal_priv,
        size: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_mem_zalloc() - Allocated zero-initialized memory.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @size: Size of the memory to be allocated in bytes.\n\n Allocates memory of @size bytes, zeroes it out and returns a pointer to the\n start of the memory allocated.\n\n Return:\n\t\tPass: Pointer to start of allocated memory.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_mem_zalloc(
        opriv: *mut nrf_wifi_osal_priv,
        size: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_mem_free() - Free previously allocated memory.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @buf: Pointer to the memory to be freed.\n\n Free up memory which has been allocated using @nrf_wifi_osal_mem_alloc or\n @nrf_wifi_osal_mem_zalloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_mem_free(opriv: *mut nrf_wifi_osal_priv, buf: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " nrf_wifi_osal_mem_cpy() - Copy contents from one memory location to another.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @dest: Pointer to the memory location where contents are to be copied.\n @src: Pointer to the memory location from where contents are to be copied.\n @count: Number of bytes to be copied.\n\n Copies @count number of bytes from @src location in memory to @dest\n location in memory.\n\n Return:\n\t\tPass: Pointer to destination memory.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_mem_cpy(
        opriv: *mut nrf_wifi_osal_priv,
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_mem_set() - Fill a block of memory with a particular value.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @start: Pointer to the memory location whose contents are to be set.\n @val: Value to be set.\n @size: Number of bytes to be set.\n\n Fills a block of memory of @size bytes starting at @start with a particular\n value represented by @val.\n\n Return:\n\t\tPass: Pointer to memory location which was set.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_mem_set(
        opriv: *mut nrf_wifi_osal_priv,
        start: *mut ::core::ffi::c_void,
        val: ::core::ffi::c_int,
        size: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_iomem_mmap() - Memory map IO memory into CPU space.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @addr: Address of the IO memory to be mapped.\n @size: Size of the IO memory in bytes.\n\n Maps IO memory of @size bytes pointed to by @addr into CPU space.\n\n Return:\n\t\tPass: Pointer to the mapped IO memory.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_iomem_mmap(
        opriv: *mut nrf_wifi_osal_priv,
        addr: ::core::ffi::c_ulong,
        size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_iomem_unmap() - Unmap previously mapped IO memory from CPU space.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @addr: Pointer to mapped IO memory to be unmapped.\n\n Unmaps IO memory from CPU space that was mapped using @nrf_wifi_osal_iomem_mmap.\n\n Return: None."]
    pub fn nrf_wifi_osal_iomem_unmap(
        opriv: *mut nrf_wifi_osal_priv,
        addr: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_iomem_read_reg32() - Read value from a 32 bit IO memory mapped\n                                   register.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @addr: Pointer to the IO memory mapped register address.\n\n Reads value from a 32 bit device register using a memory mapped\n address(@addr).\n\n Return: 32 bit value read from register."]
    pub fn nrf_wifi_osal_iomem_read_reg32(
        opriv: *mut nrf_wifi_osal_priv,
        addr: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_iomem_write_reg32() - Write a 32 bit value to a IO memory mapped register.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @addr: Pointer to the IO memory mapped register address.\n @val: Value to be written to the register.\n\n Writes a 32 bit value (@val) to a 32 bit device register using a memory\n mapped address(@addr).\n\n Return: None."]
    pub fn nrf_wifi_osal_iomem_write_reg32(
        opriv: *mut nrf_wifi_osal_priv,
        addr: *mut ::core::ffi::c_void,
        val: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_iomem_cpy_from() - Copy data from the memory of a memory\n                                 mapped IO device to host memory.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @dest: Pointer to the host memory where data is to be copied.\n @src: Pointer to the memory of the memory mapped IO device from where\n       data is to be copied.\n @count: The size of the data to be copied in bytes.\n\n Copies a block of data of size @count bytes from memory mapped device\n memory(@src) to host memory(@dest).\n\n Return: None."]
    pub fn nrf_wifi_osal_iomem_cpy_from(
        opriv: *mut nrf_wifi_osal_priv,
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_iomem_cpy_to() - Copy data to the memory of a memory\n                               mapped IO device from host memory.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @dest: Pointer to the memory of the memory mapped IO device where\n        data is to be copied.\n @src: Pointer to the host memory from where data is to be copied.\n @count: The size of the data to be copied in bytes.\n\n Copies a block of data of size @count bytes from host memory (@src) to\n memory mapped device memory(@dest).\n\n Return: None."]
    pub fn nrf_wifi_osal_iomem_cpy_to(
        opriv: *mut nrf_wifi_osal_priv,
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spinlock_alloc() - Allocate a busy lock.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n\n Allocates a busy lock.\n\n Return:\n\t\tPass: Pointer to the busy lock instance.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_spinlock_alloc(opriv: *mut nrf_wifi_osal_priv)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_spinlock_free() - Free a busy lock.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @lock: Pointer to a busy lock instance.\n\n Frees a busy lock (@lock) allocated by @nrf_wifi_osal_spinlock_alloc\n\n Return: None."]
    pub fn nrf_wifi_osal_spinlock_free(
        opriv: *mut nrf_wifi_osal_priv,
        lock: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spinlock_init() - Initialize a busy lock.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @lock: Pointer to a busy lock instance.\n\n Initializes a busy lock (@lock) allocated by @nrf_wifi_osal_spinlock_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_spinlock_init(
        opriv: *mut nrf_wifi_osal_priv,
        lock: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spinlock_take() - Acquire a buys lock.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @lock: Pointer to a busy lock instance.\n\n Acquires a busy lock (@lock) allocated by @nrf_wifi_osal_spinlock_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_spinlock_take(
        opriv: *mut nrf_wifi_osal_priv,
        lock: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spinlock_rel() - Releases a busy lock.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @lock: Pointer to a busy lock instance.\n\n Releases a busy lock (@lock) acquired by @nrf_wifi_osal_spinlock_take.\n\n Return: None."]
    pub fn nrf_wifi_osal_spinlock_rel(
        opriv: *mut nrf_wifi_osal_priv,
        lock: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spinlock_irq_take() - Acquire a busy lock and disable\n                                    interrupts.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @lock: Pointer to a busy lock instance.\n @flags: Interrupt state flags.\n\n Saves interrupt states (@flags), disable interrupts and take a\n busy lock (@lock).\n\n Return: None."]
    pub fn nrf_wifi_osal_spinlock_irq_take(
        opriv: *mut nrf_wifi_osal_priv,
        lock: *mut ::core::ffi::c_void,
        flags: *mut ::core::ffi::c_ulong,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spinlock_irq_rel() - Release a busy lock and enable interrupts.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @lock: Pointer to a busy lock instance.\n @flags: Interrupt state flags.\n\n Restores interrupt states (@flags) and releases busy lock (@lock) acquired\n using @nrf_wifi_osal_spinlock_irq_take.\n\n Return: None."]
    pub fn nrf_wifi_osal_spinlock_irq_rel(
        opriv: *mut nrf_wifi_osal_priv,
        lock: *mut ::core::ffi::c_void,
        flags: *mut ::core::ffi::c_ulong,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_node_alloc() - Allocate a linked list mode.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n\n Allocates a linked list node.\n\n Return:\n\t\tPass: Pointer to the linked list node allocated.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_llist_node_alloc(
        opriv: *mut nrf_wifi_osal_priv,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_node_free() - Free a linked list node.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @node: Pointer to a linked list node.\n\n Frees a linked list node(@node) which was allocated by\n @nrf_wifi_osal_llist_node_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_llist_node_free(
        opriv: *mut nrf_wifi_osal_priv,
        node: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_node_data_get() - Get data stored in a linked list node.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @node: Pointer to a linked list node.\n\n Gets the pointer to the data which the linked list node(@node) points to.\n\n Return:\n\t\tPass: Pointer to the data stored in the linked list node.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_llist_node_data_get(
        opriv: *mut nrf_wifi_osal_priv,
        node: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_node_data_set() - Set data in a linked list node.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @node: Pointer to a linked list node.\n @data: Pointer to the data to be stored in the linked list node.\n\n Stores the pointer to the data(@data) in a linked list node(@node).\n\n\n Return: None."]
    pub fn nrf_wifi_osal_llist_node_data_set(
        opriv: *mut nrf_wifi_osal_priv,
        node: *mut ::core::ffi::c_void,
        data: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_alloc() - Allocate a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n\n Allocates a linked list.\n\n Return:\n\t\tPass: Pointer to the allocated linked list.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_llist_alloc(opriv: *mut nrf_wifi_osal_priv) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_free() - Free a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n\n Frees a linked list(@llist) allocated by @nrf_wifi_osal_llist_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_llist_free(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_init() - Initialize a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n\n Initializes a linked list(@llist) allocated by @nrf_wifi_osal_llist_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_llist_init(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_add_node_tail() - Add a node to the tail of a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n @llist_node: Pointer to a linked list node.\n\n Adds a linked list node(@llist_node) allocated by @nrf_wifi_osal_llist_node_alloc\n to the tail of a linked list(@llist) allocated by @nrf_wifi_osal_llist_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_llist_add_node_tail(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
        llist_node: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_add_node_head() - Add a node to the head of a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n @llist_node: Pointer to a linked list node.\n\n Adds a linked list node(@llist_node) allocated by @nrf_wifi_osal_llist_node_alloc\n to the head of a linked list(@llist) allocated by @nrf_wifi_osal_llist_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_llist_add_node_head(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
        llist_node: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_get_node_head() - Get the head of a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n\n Returns the head node from a linked list(@llist) while still leaving the\n node as part of the linked list. If the linked list is empty\n returns NULL.\n\n Return:\n\t\tPass: Pointer to the head of the linked list.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_llist_get_node_head(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_get_node_nxt() - Get the next node in a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n @llist_node: Pointer to a linked list node.\n\n Return the node next to the node passed in the @llist_node parameter.\n The node returned is not removed from the linked list.\n\n Return:\n\t\tPass: Pointer to the next node in the linked list.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_llist_get_node_nxt(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
        llist_node: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_del_node() - Delete node from a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n @llist_node: Pointer to a linked list node.\n\n Removes the node passed in the @llist_node parameter from the linked list\n passed in the @llist parameter.\n\n Return: None."]
    pub fn nrf_wifi_osal_llist_del_node(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
        llist_node: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_llist_len() - Get length of a linked list.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @llist: Pointer to a linked list.\n\n Returns the length of the linked list(@llist).\n\n Return: Linked list length in bytes."]
    pub fn nrf_wifi_osal_llist_len(
        opriv: *mut nrf_wifi_osal_priv,
        llist: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_alloc() - Allocate a network buffer\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @size: Size in bytes of the network buffer to allocated.\n\n Allocates a network buffer of size @size.\n\n Return:\n\t\tPass: Pointer to the allocated network buffer.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_nbuf_alloc(
        opriv: *mut nrf_wifi_osal_priv,
        size: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_free() - Free a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n\n Frees a network buffer(@nbuf) which was allocated by\n @nrf_wifi_osal_nbuf_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_nbuf_free(opriv: *mut nrf_wifi_osal_priv, nbuf: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_headroom_res() - Reserve headroom space in a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n @size: Size in bytes of the headroom to be reserved.\n\n Reserves headroom of size(@size) bytes at the beginning of the data area of\n a network buffer(@nbuf).\n\n Return: None."]
    pub fn nrf_wifi_osal_nbuf_headroom_res(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_headroom_get() - Get the size of the headroom in a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n\n Gets the size of the reserved headroom at the beginning\n of the data area of a network buffer(@nbuf).\n\n Return: Size of the network buffer data headroom in bytes."]
    pub fn nrf_wifi_osal_nbuf_headroom_get(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_data_size() - Get the size of data in a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n\n Gets the size of the data area of a network buffer(@nbuf).\n\n Return: Size of the network buffer data in bytes."]
    pub fn nrf_wifi_osal_nbuf_data_size(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_data_get() - Get a handle to the data in a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n\n Gets the pointer to the data area of a network buffer(@nbuf).\n\n Return:\n\t\tPass: Pointer to the data in the network buffer.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_nbuf_data_get(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_data_put() - Extend the tail portion of the data\n                                in a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n @size: Size in bytes, of the extension.\n\n Increases the data area of a network buffer(@nbuf) by @size bytes at the\n end of the area and returns the pointer to the beginning of\n the data area.\n\n Return:\n\t\tPass: Updated pointer to the data in the network buffer.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_nbuf_data_put(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_data_push() - Extend the head portion of the data\n                                 in a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n @size: Size in bytes, of the extension.\n\n Increases the data area of a network buffer(@nbuf) by @size bytes at the\n start of the area and returns the pointer to the beginning of the\n data area.\n\n Return:\n\t\tPass: Updated pointer to the data in the network buffer.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_nbuf_data_push(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_data_pull() - Reduce the head portion of the data\n                                 in a network buffer.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n @size: Size in bytes, of the reduction.\n\n Decreases the data area of a network buffer(@nbuf) by @size bytes at the\n start of the area and returns the pointer to the beginning\n of the data area.\n\n Return:\n\t\tPass: Updated pointer to the data in the network buffer.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_nbuf_data_pull(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_nbuf_get_priority() - Get the priority of a network buffer.\n\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @nbuf: Pointer to a network buffer.\n\n Gets the priority of a network buffer(@nbuf).\n\n Return: Priority of the network buffer."]
    pub fn nrf_wifi_osal_nbuf_get_priority(
        opriv: *mut nrf_wifi_osal_priv,
        nbuf: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " nrf_wifi_osal_tasklet_alloc() - Allocate a tasklet.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @type: Type of tasklet.\n\n Allocates a tasklet structure and returns a pointer to it.\n\n Return:\n\t\tPass: Pointer to the tasklet instance allocated.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_tasklet_alloc(
        opriv: *mut nrf_wifi_osal_priv,
        type_: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_tasklet_free() - Free a tasklet.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @tasklet: Pointer to a tasklet.\n\n Frees a tasklet structure that had been allocated using\n @nrf_wifi_osal_tasklet_alloc.\n\n Return: None."]
    pub fn nrf_wifi_osal_tasklet_free(
        opriv: *mut nrf_wifi_osal_priv,
        tasklet: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_tasklet_init() - Initialize a tasklet.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @tasklet:  Pointer to a tasklet.\n @callbk_fn: Callback function to be invoked by the tasklet.\n @data: Data to be passed to the callback function when the tasklet\n        invokes it.\n\n Initializes a tasklet structure(@tasklet) that had been allocated using\n @nrf_wifi_osal_tasklet_alloc. Needs to be passed a callback\n function (@callbk_fn) which should get invoked when the tasklet is\n scheduled and the data(@data) which needs to be passed to the\n callback function.\n\n Return: None."]
    pub fn nrf_wifi_osal_tasklet_init(
        opriv: *mut nrf_wifi_osal_priv,
        tasklet: *mut ::core::ffi::c_void,
        callbk_fn: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_ulong)>,
        data: ::core::ffi::c_ulong,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_tasklet_schedule() - Schedule a tasklet.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @tasklet:  Pointer to a tasklet.\n\n Schedules a tasklet that had been allocated using\n @nrf_wifi_osal_tasklet_alloc and initialized using\n @nrf_wifi_osal_tasklet_init.\n\n Return: None."]
    pub fn nrf_wifi_osal_tasklet_schedule(
        opriv: *mut nrf_wifi_osal_priv,
        tasklet: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_tasklet_kill() - Terminate a tasklet.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @tasklet:  Pointer to a tasklet.\n\n Terminates a tasklet(@tasklet) that had been scheduled by\n @nrf_wifi_osal_tasklet_schedule.\n\n Return: None."]
    pub fn nrf_wifi_osal_tasklet_kill(
        opriv: *mut nrf_wifi_osal_priv,
        tasklet: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_sleep_ms() - Sleep for a specified duration in milliseconds.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @msecs: Sleep duration in milliseconds.\n\n Puts the calling thread to sleep for atleast @msecs milliseconds.\n\n Return: None."]
    pub fn nrf_wifi_osal_sleep_ms(opriv: *mut nrf_wifi_osal_priv, msecs: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " nrf_wifi_osal_delay_us() - Delay for a specified duration in microseconds.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @usecs: Delay duration in microseconds.\n\n Delays execution of calling thread for @usecs microseconds. This is\n busy-waiting and won't allow other threads to execute during\n the time lapse.\n\n Return: None."]
    pub fn nrf_wifi_osal_delay_us(opriv: *mut nrf_wifi_osal_priv, usecs: ::core::ffi::c_ulong);
}
extern "C" {
    #[doc = " nrf_wifi_osal_time_get_curr_us() - Get current system uptime in microseconds.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n\n Gets the current system uptime in microseconds.\n\n Return: System uptime in microseconds."]
    pub fn nrf_wifi_osal_time_get_curr_us(opriv: *mut nrf_wifi_osal_priv) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " nrf_wifi_osal_time_elapsed_us() - Get elapsed time in microseconds\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @start_time_us: The timestamp in microseconds from which elapsed\n                 time is to be measured.\n\n Returns the time elapsed in microseconds since some\n time instant (@start_time_us).\n\n Return: Elapsed time in microseconds."]
    pub fn nrf_wifi_osal_time_elapsed_us(
        opriv: *mut nrf_wifi_osal_priv,
        start_time_us: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_init() - Initialize a PCIe driver.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @dev_name: Name of the PCIe device.\n @vendor_id: Vendor ID of the PCIe device.\n @sub_vendor_id: Sub-vendor ID of the PCIE device.\n @device_id: Device ID of the PCIe device.\n @sub_device_id: Sub-device ID of the PCIe device.\n\n Registers a PCIe device driver to the OS's PCIe core.\n\n Return: OS specific PCIe device context."]
    pub fn nrf_wifi_osal_bus_pcie_init(
        opriv: *mut nrf_wifi_osal_priv,
        dev_name: *const ::core::ffi::c_char,
        vendor_id: ::core::ffi::c_uint,
        sub_vendor_id: ::core::ffi::c_uint,
        device_id: ::core::ffi::c_uint,
        sub_device_id: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_deinit() - Deinitialize a PCIe device driver.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_priv: OS specific PCIe context.\n\n This API should be called when the PCIe device driver is\n to be unregistered from the OS's PCIe core.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_pcie_deinit(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_priv: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_add() - Add a PCIe device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @osal_pcie_dev_ctx: Pointer to the OSAL PCIe device context.\n\n Function to be invoked when a matching PCIe device is added to the system.\n It expects the pointer to a OS specific PCIe device context to be returned.\n\n Return: OS specific PCIe device context."]
    pub fn nrf_wifi_osal_bus_pcie_dev_add(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_priv: *mut ::core::ffi::c_void,
        osal_pcie_dev_ctx: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_rem() - Remove a PCIe device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: Pointer to the OS specific PCIe device context which was\n                   returned by @nrf_wifi_osal_bus_pcie_dev_add.\n\n Function to be invoked when a matching PCIe device is removed from the system.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_pcie_dev_rem(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_init() - Initialize a PCIe device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: Pointer to the OS specific PCIe device context which was\n                   returned by @nrf_wifi_osal_bus_pcie_dev_add.\n\n Function to be invoked when a PCIe device is to be initialized.\n\n Return:\n\t\tPass: NRF_WIFI_STATUS_SUCCESS.\n\t\tFail: NRF_WIFI_STATUS_FAIL."]
    pub fn nrf_wifi_osal_bus_pcie_dev_init(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_deinit() - Deinitialize a PCIe device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: Pointer to the OS specific PCIe device context which was\n                   returned by @nrf_wifi_osal_bus_pcie_dev_add.\n\n Function to be invoked when a PCIe device is to be deinitialized.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_pcie_dev_deinit(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_intr_reg() - Register a interrupt handler for a PCIe device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: OS specific PCIe device context.\n @callbk_data: Data to be passed to the ISR.\n @callbk_fn: ISR to be invoked on receiving an interrupt.\n\n Registers an interrupt handler to the OS. This API also passes the callback\n data to be passed to the ISR when an interrupt is received.\n\n Return:\n\t    Pass: NRF_WIFI_STATUS_SUCCESS.\n\t    Fail: NRF_WIFI_STATUS_FAIL."]
    pub fn nrf_wifi_osal_bus_pcie_dev_intr_reg(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
        callbk_data: *mut ::core::ffi::c_void,
        callbk_fn: ::core::option::Option<
            unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_intr_unreg() - Unregister an interrupt handler for a PCIe device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: OS specific PCIe device context.\n\n Unregisters the interrupt handler that was registered using\n @nrf_wifi_osal_bus_pcie_dev_intr_reg.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_pcie_dev_intr_unreg(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_dma_map() - Map host memory for DMA access.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: Pointer to a OS specific PCIe device handle.\n @virt_addr: Virtual host address to be DMA mapped.\n @size: Size in bytes of the host memory to be DMA mapped.\n @dir: DMA direction.\n\n Maps host memory of @size bytes pointed to by the virtual address\n @virt_addr to be used by the device(@dma_dev) for DMAing contents.\n The contents are available for DMAing to the device if @dir has a\n value of @NRF_WIFI_OSAL_DMA_DIR_TO_DEV. Conversely the device can DMA\n contents to the host memory if @dir has a value of\n @NRF_WIFI_OSAL_DMA_DIR_FROM_DEV. The function returns the DMA address\n of the mapped memory.\n\n Return:\n\t\tPass: Pointer to the DMA mapped physical address.\n\t\tError: NULL."]
    pub fn nrf_wifi_osal_bus_pcie_dev_dma_map(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
        virt_addr: *mut ::core::ffi::c_void,
        size: usize,
        dir: nrf_wifi_osal_dma_dir,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_dma_unmap() - Unmap DMA mapped host memory.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: Pointer to a OS specific PCIe device handle.\n @dma_addr: DMA mapped physical host memory address.\n @size: Size in bytes of the DMA mapped host memory.\n @dir: DMA direction.\n\n Unmaps the host memory which was mapped for DMA using @nrf_wifi_osal_dma_map.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_pcie_dev_dma_unmap(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
        dma_addr: *mut ::core::ffi::c_void,
        size: usize,
        dir: nrf_wifi_osal_dma_dir,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_pcie_dev_host_map_get() - Get host mapped address for a PCIe device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_pcie_dev_ctx: OS specific PCIe device context.\n @host_map: Host map address information.\n\n Gets the host map address for a PCIe device.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_pcie_dev_host_map_get(
        opriv: *mut nrf_wifi_osal_priv,
        os_pcie_dev_ctx: *mut ::core::ffi::c_void,
        host_map: *mut nrf_wifi_osal_host_map,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_init() - Initialize a qspi driver.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n\n Registers a qspi device driver to the OS's qspi core.\n\n Return: OS specific qspi device context."]
    pub fn nrf_wifi_osal_bus_qspi_init(opriv: *mut nrf_wifi_osal_priv) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_deinit() - Deinitialize a qspi device driver.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_qspi_priv: OS specific qspi context.\n\n This API should be called when the qspi device driver is\n to be unregistered from the OS's qspi core.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_qspi_deinit(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_priv: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_dev_add() - Add a qspi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @osal_qspi_dev_ctx: Pointer to the OSAL qspi device context.\n\n Function to be invoked when a matching qspi device is added to the system.\n It expects the pointer to a OS specific qspi device context to be returned.\n\n Return: OS specific qspi device context."]
    pub fn nrf_wifi_osal_bus_qspi_dev_add(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_priv: *mut ::core::ffi::c_void,
        osal_qspi_dev_ctx: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_dev_rem() - Remove a qspi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_qspi_dev_ctx: Pointer to the OS specific qspi device context which was\n                   returned by @nrf_wifi_osal_bus_qspi_dev_add.\n\n Function to be invoked when a matching qspi device is removed from the system.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_qspi_dev_rem(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_dev_init() - Initialize a qspi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_qspi_dev_ctx: Pointer to the OS specific qspi device context which was\n                   returned by @nrf_wifi_osal_bus_qspi_dev_add.\n\n Function to be invoked when a qspi device is to be initialized.\n\n Return:\n\t\tPass: NRF_WIFI_STATUS_SUCCESS.\n\t\tFail: NRF_WIFI_STATUS_FAIL."]
    pub fn nrf_wifi_osal_bus_qspi_dev_init(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_dev_ctx: *mut ::core::ffi::c_void,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_dev_deinit() - Deinitialize a qspi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_qspi_dev_ctx: Pointer to the OS specific qspi device context which was\n                   returned by @nrf_wifi_osal_bus_qspi_dev_add.\n\n Function to be invoked when a qspi device is to be deinitialized.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_qspi_dev_deinit(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_dev_intr_reg() - Register a interrupt handler for a qspi device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_qspi_dev_ctx: OS specific qspi device context.\n @callbk_data: Data to be passed to the ISR.\n @callbk_fn: ISR to be invoked on receiving an interrupt.\n\n Registers an interrupt handler to the OS. This API also passes the callback\n data to be passed to the ISR when an interrupt is received.\n\n Return:\n\t    Pass: NRF_WIFI_STATUS_SUCCESS.\n\t    Fail: NRF_WIFI_STATUS_FAIL."]
    pub fn nrf_wifi_osal_bus_qspi_dev_intr_reg(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_dev_ctx: *mut ::core::ffi::c_void,
        callbk_data: *mut ::core::ffi::c_void,
        callbk_fn: ::core::option::Option<
            unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_dev_intr_unreg() - Unregister an interrupt handler for a qspi device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_qspi_dev_ctx: OS specific qspi device context.\n\n Unregisters the interrupt handler that was registered using\n @nrf_wifi_osal_bus_qspi_dev_intr_reg.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_qspi_dev_intr_unreg(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_qspi_dev_host_map_get() - Get host mapped address for a qspi device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_qspi_dev_ctx: OS specific qspi device context.\n @host_map: Host map address information.\n\n Gets the host map address for a qspi device.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_qspi_dev_host_map_get(
        opriv: *mut nrf_wifi_osal_priv,
        os_qspi_dev_ctx: *mut ::core::ffi::c_void,
        host_map: *mut nrf_wifi_osal_host_map,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_qspi_read_reg32() - Read value from a 32 bit register on a\n                                  QSPI slave device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @addr: Address of the register to read from.\n\n Reads value from a 32 bit device register at address(@addr) on\n a QSPI slave device.\n\n Return: 32 bit value read from register."]
    pub fn nrf_wifi_osal_qspi_read_reg32(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_qspi_write_reg32() -\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @addr: Address of the register to write to.\n @val: Value to be written to the register.\n\n Writes a 32 bit value (@val) to a 32 bit device register at address(@addr)\n on a QSPI slave device.\n\n Return: None."]
    pub fn nrf_wifi_osal_qspi_write_reg32(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
        val: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_qspi_cpy_from() -\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @dest:\n @src:\n @count:\n\n\n Return: None."]
    pub fn nrf_wifi_osal_qspi_cpy_from(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        dest: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_qspi_cpy_to() -\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @dest:\n @src:\n @count:\n\n\n Return: None."]
    pub fn nrf_wifi_osal_qspi_cpy_to(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
        src: *const ::core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_init() - Initialize a spi driver.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n\n Registers a spi device driver to the OS's spi core.\n\n Return: OS specific spi device context."]
    pub fn nrf_wifi_osal_bus_spi_init(opriv: *mut nrf_wifi_osal_priv) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_deinit() - Deinitialize a spi device driver.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_spi_priv: OS specific spi context.\n\n This API should be called when the spi device driver is\n to be unregistered from the OS's spi core.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_spi_deinit(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_priv: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_dev_add() - Add a spi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @osal_spi_dev_ctx: Pointer to the OSAL spi device context.\n\n Function to be invoked when a matching spi device is added to the system.\n It expects the pointer to a OS specific spi device context to be returned.\n\n Return: OS specific spi device context."]
    pub fn nrf_wifi_osal_bus_spi_dev_add(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_priv: *mut ::core::ffi::c_void,
        osal_spi_dev_ctx: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_dev_rem() - Remove a spi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_spi_dev_ctx: Pointer to the OS specific spi device context which was\n                   returned by @nrf_wifi_osal_bus_spi_dev_add.\n\n Function to be invoked when a matching spi device is removed from the system.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_spi_dev_rem(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_dev_init() - Initialize a spi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_spi_dev_ctx: Pointer to the OS specific spi device context which was\n                   returned by @nrf_wifi_osal_bus_spi_dev_add.\n\n Function to be invoked when a spi device is to be initialized.\n\n Return:\n\t\tPass: nrf_wifi_STATUS_SUCCESS.\n\t\tFail: nrf_wifi_STATUS_FAIL."]
    pub fn nrf_wifi_osal_bus_spi_dev_init(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_dev_ctx: *mut ::core::ffi::c_void,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_dev_deinit() - Deinitialize a spi device instance.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_spi_dev_ctx: Pointer to the OS specific spi device context which was\n                   returned by @nrf_wifi_osal_bus_spi_dev_add.\n\n Function to be invoked when a spi device is to be deinitialized.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_spi_dev_deinit(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_dev_intr_reg() - Register a interrupt handler for a spi device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_spi_dev_ctx: OS specific spi device context.\n @callbk_data: Data to be passed to the ISR.\n @callbk_fn: ISR to be invoked on receiving an interrupt.\n\n Registers an interrupt handler to the OS. This API also passes the callback\n data to be passed to the ISR when an interrupt is received.\n\n Return:\n\t    Pass: nrf_wifi_STATUS_SUCCESS.\n\t    Fail: nrf_wifi_STATUS_FAIL."]
    pub fn nrf_wifi_osal_bus_spi_dev_intr_reg(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_dev_ctx: *mut ::core::ffi::c_void,
        callbk_data: *mut ::core::ffi::c_void,
        callbk_fn: ::core::option::Option<
            unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_dev_intr_unreg() - Unregister an interrupt handler for a spi device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_spi_dev_ctx: OS specific spi device context.\n\n Unregisters the interrupt handler that was registered using\n @nrf_wifi_osal_bus_spi_dev_intr_reg.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_spi_dev_intr_unreg(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_dev_ctx: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_bus_spi_dev_host_map_get() - Get host mapped address for a spi device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @os_spi_dev_ctx: OS specific spi device context.\n @host_map: Host map address information.\n\n Gets the host map address for a spi device.\n\n Return: None."]
    pub fn nrf_wifi_osal_bus_spi_dev_host_map_get(
        opriv: *mut nrf_wifi_osal_priv,
        os_spi_dev_ctx: *mut ::core::ffi::c_void,
        host_map: *mut nrf_wifi_osal_host_map,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spi_read_reg32() - Read value from a 32 bit register on a\n                                  Linux SPI slave device.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @addr: Address of the register to read from.\n\n Reads value from a 32 bit device register at address(@addr) on\n a QSPI slave device.\n\n Return: 32 bit value read from register."]
    pub fn nrf_wifi_osal_spi_read_reg32(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_spi_write_reg32() -\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @addr: Address of the register to write to.\n @val: Value to be written to the register.\n\n Writes a 32 bit value (@val) to a 32 bit device register at address(@addr)\n on a Linux SPI slave device.\n\n Return: None."]
    pub fn nrf_wifi_osal_spi_write_reg32(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
        val: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spi_cpy_from() -\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @dest:\n @src:\n @count:\n\n\n Return: None."]
    pub fn nrf_wifi_osal_spi_cpy_from(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        dest: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_spi_cpy_to() -\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @priv:\n @dest:\n @src:\n @count:\n\n\n Return: None."]
    pub fn nrf_wifi_osal_spi_cpy_to(
        opriv: *mut nrf_wifi_osal_priv,
        priv_: *mut ::core::ffi::c_void,
        addr: ::core::ffi::c_ulong,
        src: *const ::core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_assert() - Assert a condition with a value.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @test: Variable to be tested.\n @val: Value to be checked for the @test\n @op: type of operation to be done during assertion check.\n @msg: Assertion message.\n\n Compares @test aith @val. If true prints assert message.\n\n Return:\n              None"]
    pub fn nrf_wifi_osal_assert(
        opriv: *mut nrf_wifi_osal_priv,
        test: ::core::ffi::c_int,
        val: ::core::ffi::c_int,
        op: nrf_wifi_assert_op_type,
        msg: *mut ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " nrf_wifi_osal_strlen() - Gives the length of the string @str.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @str: Pointer to the memory location of the string.\n\n Calculates the length of the string pointed to by @str\n\n Return:\n              returns the number of bytes of the string @str."]
    pub fn nrf_wifi_osal_strlen(
        opriv: *mut nrf_wifi_osal_priv,
        str_: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " nrf_wifi_osal_mem_cmp() - Compare contents from one memory location to another.\n @opriv: Pointer to the OSAL context returned by the @nrf_wifi_osal_init API.\n @addr1: Pointer to the memory location of first address.\n @addr2: Pointer to the memory location of second address.\n @count: Number of bytes to be compared.\n\n Compares @count number of bytes from @addr1 location in memory to @addr2\n location in memory.\n\n Return:\n              returns an integer less than, equal to, or greater than zero"]
    pub fn nrf_wifi_osal_mem_cmp(
        opriv: *mut nrf_wifi_osal_priv,
        addr1: *const ::core::ffi::c_void,
        addr2: *const ::core::ffi::c_void,
        count: usize,
    ) -> ::core::ffi::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RPU_MCU_ADDR_REGIONS {
    RPU_MCU_ADDR_REGION_ROM = 0,
    RPU_MCU_ADDR_REGION_RETENTION = 1,
    RPU_MCU_ADDR_REGION_SCRATCH = 2,
    RPU_MCU_ADDR_REGION_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_addr_region {
    pub start: ::core::ffi::c_uint,
    pub end: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_rpu_addr_region() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_addr_region> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_addr_region>(),
        8usize,
        concat!("Size of: ", stringify!(rpu_addr_region))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_addr_region>(),
        4usize,
        concat!("Alignment of ", stringify!(rpu_addr_region))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_addr_region),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_addr_region),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_addr_map {
    pub regions: [rpu_addr_region; 3usize],
}
#[test]
fn bindgen_test_layout_rpu_addr_map() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_addr_map> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_addr_map>(),
        24usize,
        concat!("Size of: ", stringify!(rpu_addr_map))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_addr_map>(),
        4usize,
        concat!("Alignment of ", stringify!(rpu_addr_map))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).regions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_addr_map),
            "::",
            stringify!(regions)
        )
    );
}
extern "C" {
    pub static RPU_ADDR_MAP_MCU: [rpu_addr_map; 2usize];
}
#[doc = " struct nrf_wifi_rpu_pwr_data - Data that host may want to read from the Power IP.\n @lfc_err: Estimated Lo Frequency Clock error in ppm.\n @vbat_mon: Vbat monitor readout. The actual Vbat in volt equals 2.5 + 0.07*vbat_mon.\n @temp: Estimated die temperature (degC).\n\n This structure represents the Power IP monitoring data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_rpu_pwr_data {
    pub lfc_err: ::core::ffi::c_int,
    pub vbat_mon: ::core::ffi::c_int,
    pub temp: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_rpu_pwr_data() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_rpu_pwr_data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_rpu_pwr_data>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_rpu_pwr_data))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_rpu_pwr_data>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_rpu_pwr_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lfc_err) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rpu_pwr_data),
            "::",
            stringify!(lfc_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vbat_mon) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rpu_pwr_data),
            "::",
            stringify!(vbat_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rpu_pwr_data),
            "::",
            stringify!(temp)
        )
    );
}
#[doc = " struct host_rpu_rx_buf_info - RX buffer related information to be passed to\n                               the RPU.\n @addr: Address in the host memory where the RX buffer is located.\n\n This structure encapsulates the information to be passed to the RPU for\n buffers which the RPU will use to pass the received frames."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_rx_buf_info {
    pub addr: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_host_rpu_rx_buf_info() {
    const UNINIT: ::core::mem::MaybeUninit<host_rpu_rx_buf_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<host_rpu_rx_buf_info>(),
        4usize,
        concat!("Size of: ", stringify!(host_rpu_rx_buf_info))
    );
    assert_eq!(
        ::core::mem::align_of::<host_rpu_rx_buf_info>(),
        1usize,
        concat!("Alignment of ", stringify!(host_rpu_rx_buf_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_rx_buf_info),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " struct host_rpu_hpq - Hostport Queue (HPQ) information.\n @enqueue_addr: HPQ address where the host can post the address of a\n                message intended for the RPU.\n @dequeue_addr: HPQ address where the host can get the address of a\n                message intended for the host.\n\n This structure encapsulates the information which represents a HPQ."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_hpq {
    pub enqueue_addr: ::core::ffi::c_uint,
    pub dequeue_addr: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_host_rpu_hpq() {
    const UNINIT: ::core::mem::MaybeUninit<host_rpu_hpq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<host_rpu_hpq>(),
        8usize,
        concat!("Size of: ", stringify!(host_rpu_hpq))
    );
    assert_eq!(
        ::core::mem::align_of::<host_rpu_hpq>(),
        1usize,
        concat!("Alignment of ", stringify!(host_rpu_hpq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enqueue_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_hpq),
            "::",
            stringify!(enqueue_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dequeue_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_hpq),
            "::",
            stringify!(dequeue_addr)
        )
    );
}
#[doc = " struct host_rpu_hpqm_info - Information about Hostport Queues (HPQ) to be used\n            for exchanging information between the Host and RPU.\n @event_busy_queue: Queue which the RPU uses to inform the host about events.\n @event_avl_queue: Queue on which the consumed events are pushed so that RPU\n                    can reuse them.\n @cmd_busy_queue: Queue used by the host to push commands to the RPU.\n @cmd_avl_queue: Queue which RPU uses to inform host about command\n                  buffers which can be used to push commands to the RPU.\n\n Hostport queue information passed by the RPU to the host, which the host can\n use, to communicate with the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_hpqm_info {
    pub event_busy_queue: host_rpu_hpq,
    pub event_avl_queue: host_rpu_hpq,
    pub cmd_busy_queue: host_rpu_hpq,
    pub cmd_avl_queue: host_rpu_hpq,
    pub rx_buf_busy_queue: [host_rpu_hpq; 3usize],
}
#[test]
fn bindgen_test_layout_host_rpu_hpqm_info() {
    const UNINIT: ::core::mem::MaybeUninit<host_rpu_hpqm_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<host_rpu_hpqm_info>(),
        56usize,
        concat!("Size of: ", stringify!(host_rpu_hpqm_info))
    );
    assert_eq!(
        ::core::mem::align_of::<host_rpu_hpqm_info>(),
        1usize,
        concat!("Alignment of ", stringify!(host_rpu_hpqm_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_busy_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_hpqm_info),
            "::",
            stringify!(event_busy_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_avl_queue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_hpqm_info),
            "::",
            stringify!(event_avl_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_busy_queue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_hpqm_info),
            "::",
            stringify!(cmd_busy_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_avl_queue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_hpqm_info),
            "::",
            stringify!(cmd_avl_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf_busy_queue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_hpqm_info),
            "::",
            stringify!(rx_buf_busy_queue)
        )
    );
}
#[doc = " struct host_rpu_msg_hdr - Common header included in each command/event.\n @len: Length of the message.\n @resubmit: Flag to indicate whether the recipient is expected to resubmit\n            the cmd/event address back to the trasmitting entity.\n\n This structure encapsulates the common information included at the start of\n each command/event exchanged with the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_msg_hdr {
    pub len: ::core::ffi::c_uint,
    pub resubmit: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_host_rpu_msg_hdr() {
    const UNINIT: ::core::mem::MaybeUninit<host_rpu_msg_hdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<host_rpu_msg_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(host_rpu_msg_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<host_rpu_msg_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(host_rpu_msg_hdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_msg_hdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resubmit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_msg_hdr),
            "::",
            stringify!(resubmit)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pta_ext_params {
    #[doc = " Set polarity to 1 if  BT_TX_RX active high indicates Tx. Set polarity to 0 if BT_TX_RX\n active high indicates Rx."]
    pub tx_rx_pol: ::core::ffi::c_uchar,
    #[doc = " BT_ACTIVE signal lead time period. This is with reference to time instance at which\nBT slot boundary starts if BT supports classic only mode and BT activity starts if BT\nsupports BLE or dual mode"]
    pub lead_time: ::core::ffi::c_uint,
    #[doc = " Time instance at which BT_STATUS is sampled by PTA to get the BT_PTI information. This\nis done anywhere between BT_ACTIVE_ASSERT time and BT_STATUS priority signalling time\nperiod ends.This is with reference to BT_ACTIVE assert time."]
    pub pti_samp_time: ::core::ffi::c_uint,
    #[doc = " Time instance at which BT_STATUS is sampled by PTA to get BT_TX_RX information.\nThis is done by PTA after the end of time period T2.  This is with reference to BT_ACTIVE\nassert time."]
    pub tx_rx_samp_time: ::core::ffi::c_uint,
    #[doc = " Time instance at which PTA takes arbitration decision and posts WLAN_DENY to BT. This\n is with reference to BT_ACTIVE assert time."]
    pub dec_time: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_pta_ext_params() {
    const UNINIT: ::core::mem::MaybeUninit<pta_ext_params> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pta_ext_params>(),
        17usize,
        concat!("Size of: ", stringify!(pta_ext_params))
    );
    assert_eq!(
        ::core::mem::align_of::<pta_ext_params>(),
        1usize,
        concat!("Alignment of ", stringify!(pta_ext_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_rx_pol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pta_ext_params),
            "::",
            stringify!(tx_rx_pol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lead_time) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(pta_ext_params),
            "::",
            stringify!(lead_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pti_samp_time) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(pta_ext_params),
            "::",
            stringify!(pti_samp_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_rx_samp_time) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(pta_ext_params),
            "::",
            stringify!(tx_rx_samp_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dec_time) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(pta_ext_params),
            "::",
            stringify!(dec_time)
        )
    );
}
#[repr(u32)]
#[doc = " @brief This enum defines the different categories of messages that can be exchanged between\n  the Host and the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_host_rpu_msg_type {
    #[doc = " System interface messages"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_SYSTEM = 0,
    #[doc = " Unused"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_SUPPLICANT = 1,
    #[doc = " Data path messages"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_DATA = 2,
    #[doc = " Control path messages"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_UMAC = 3,
}
#[doc = " @brief This structure defines the common message header used to encapsulate each message\n  exchanged between the Host and UMAC.\n"]
#[repr(C, packed)]
pub struct host_rpu_msg {
    #[doc = " Header"]
    pub hdr: host_rpu_msg_hdr,
    #[doc = " Type of the RPU message see &enum nrf_wifi_host_rpu_msg_type"]
    pub type_: ::core::ffi::c_int,
    #[doc = " Actual message"]
    pub msg: __IncompleteArrayField<::core::ffi::c_schar>,
}
#[test]
fn bindgen_test_layout_host_rpu_msg() {
    const UNINIT: ::core::mem::MaybeUninit<host_rpu_msg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<host_rpu_msg>(),
        12usize,
        concat!("Size of: ", stringify!(host_rpu_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<host_rpu_msg>(),
        1usize,
        concat!("Alignment of ", stringify!(host_rpu_msg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_msg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_msg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_msg),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = " @brief This structure represents the bitmap of STA (Station) pending frames in\n  SoftAP power save mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sap_pend_frames_bitmap {
    #[doc = " STA MAC address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Pending frames bitmap for each access category"]
    pub pend_frames_bitmap: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_sap_pend_frames_bitmap() {
    const UNINIT: ::core::mem::MaybeUninit<sap_pend_frames_bitmap> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sap_pend_frames_bitmap>(),
        7usize,
        concat!("Size of: ", stringify!(sap_pend_frames_bitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<sap_pend_frames_bitmap>(),
        1usize,
        concat!("Alignment of ", stringify!(sap_pend_frames_bitmap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sap_pend_frames_bitmap),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pend_frames_bitmap) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sap_pend_frames_bitmap),
            "::",
            stringify!(pend_frames_bitmap)
        )
    );
}
#[doc = " @brief This structure represents the information related to UMAC.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_umac_info {
    #[doc = " Boot status signature"]
    pub boot_status: ::core::ffi::c_uint,
    #[doc = " UMAC version"]
    pub version: ::core::ffi::c_uint,
    #[doc = " @ref sap_pend_frames_bitmap"]
    pub sap_bitmap: [sap_pend_frames_bitmap; 4usize],
    #[doc = " Hardware queues info &enum host_rpu_hpqm_info"]
    pub hpqm_info: host_rpu_hpqm_info,
    #[doc = " OTP params"]
    pub info_part: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_variant: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_lromversion: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_uromversion: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_uuid: [::core::ffi::c_uint; 4usize],
    #[doc = " OTP params"]
    pub info_spare0: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_spare1: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub mac_address0: [::core::ffi::c_uint; 2usize],
    #[doc = " OTP params"]
    pub mac_address1: [::core::ffi::c_uint; 2usize],
    #[doc = " OTP params"]
    pub calib: [::core::ffi::c_uint; 9usize],
}
#[test]
fn bindgen_test_layout_host_rpu_umac_info() {
    const UNINIT: ::core::mem::MaybeUninit<host_rpu_umac_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<host_rpu_umac_info>(),
        184usize,
        concat!("Size of: ", stringify!(host_rpu_umac_info))
    );
    assert_eq!(
        ::core::mem::align_of::<host_rpu_umac_info>(),
        1usize,
        concat!("Alignment of ", stringify!(host_rpu_umac_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).boot_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(boot_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sap_bitmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(sap_bitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hpqm_info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(hpqm_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info_part) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(info_part)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info_variant) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(info_variant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info_lromversion) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(info_lromversion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info_uromversion) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(info_uromversion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info_uuid) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(info_uuid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info_spare0) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(info_spare0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info_spare1) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(info_spare1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_address0) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(mac_address0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_address1) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(mac_address1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calib) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(host_rpu_umac_info),
            "::",
            stringify!(calib)
        )
    );
}
#[doc = " @brief This structure defines the parameters used to control the max transmit (TX) power\n in both frequency bands for different data rates.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_pwr_ceil_params {
    #[doc = " Maximum power permitted while transmitting DSSS rates in 2.4G band.\n  Resolution is 0.25dBm."]
    pub max_pwr_2g_dsss: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 2.4G band.\n  Resolution is 0.25dBm."]
    pub max_pwr_2g_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 2.4G band.\n  Resolution is 0.25dBm."]
    pub max_pwr_2g_mcs7: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 5G lowband.\n Low band corresponds to ch: 36 to 64 Resolution is 0.25dBm."]
    pub max_pwr_5g_low_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 5G lowband.\n Low band corresponds to ch: 36 to 64, resolution is 0.25dBm."]
    pub max_pwr_5g_low_mcs7: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 5G midband.\n Mid band corresponds to ch: 96 to 132, resolution is 0.25dBm."]
    pub max_pwr_5g_mid_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 5G midband.\n Mid band corresponds to ch: 96 to 132, resolution is 0.25dBm."]
    pub max_pwr_5g_mid_mcs7: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 5G highband.\n High band corresponds to ch: 136 to 177, resolution is 0.25dBm."]
    pub max_pwr_5g_high_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 5G highband.\n High band corresponds to ch: 136 to 177, resolution is 0.25dBm."]
    pub max_pwr_5g_high_mcs7: ::core::ffi::c_uchar,
    #[doc = " Flag to determine presence of overriding, default parameters present\n in RF parameters string."]
    pub rf_tx_pwr_ceil_params_override: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_tx_pwr_ceil_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_tx_pwr_ceil_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_tx_pwr_ceil_params>(),
        10usize,
        concat!("Size of: ", stringify!(nrf_wifi_tx_pwr_ceil_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_tx_pwr_ceil_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_tx_pwr_ceil_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_2g_dsss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_2g_dsss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_2g_mcs0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_2g_mcs0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_2g_mcs7) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_2g_mcs7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_5g_low_mcs0) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_5g_low_mcs0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_5g_low_mcs7) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_5g_low_mcs7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_5g_mid_mcs0) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_5g_mid_mcs0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_5g_mid_mcs7) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_5g_mid_mcs7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_5g_high_mcs0) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_5g_high_mcs0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_pwr_5g_high_mcs7) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(max_pwr_5g_high_mcs7)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).rf_tx_pwr_ceil_params_override) as usize - ptr as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ceil_params),
            "::",
            stringify!(rf_tx_pwr_ceil_params_override)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ft_prog_ver {
    FT_PROG_VER1 = 1,
    FT_PROG_VER2 = 2,
    FT_PROG_VER3 = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lmac_prod_stats {
    pub reset_cmd_cnt: ::core::ffi::c_uint,
    pub reset_complete_event_cnt: ::core::ffi::c_uint,
    pub unable_gen_event: ::core::ffi::c_uint,
    pub ch_prog_cmd_cnt: ::core::ffi::c_uint,
    pub channel_prog_done: ::core::ffi::c_uint,
    pub tx_pkt_cnt: ::core::ffi::c_uint,
    pub tx_pkt_done_cnt: ::core::ffi::c_uint,
    pub scan_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_done_cnt: ::core::ffi::c_uint,
    pub ack_resp_cnt: ::core::ffi::c_uint,
    pub tx_timeout: ::core::ffi::c_uint,
    pub deagg_isr: ::core::ffi::c_uint,
    pub deagg_inptr_desc_empty: ::core::ffi::c_uint,
    pub deagg_circular_buffer_full: ::core::ffi::c_uint,
    pub lmac_rxisr_cnt: ::core::ffi::c_uint,
    pub rx_decryptcnt: ::core::ffi::c_uint,
    pub process_decrypt_fail: ::core::ffi::c_uint,
    pub prepa_rx_event_fail: ::core::ffi::c_uint,
    pub rx_core_pool_full_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_fail_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_fail_cnt: ::core::ffi::c_uint,
    pub rxDSSSCrcSuccessCnt: ::core::ffi::c_uint,
    pub rxDSSSCrcFailCnt: ::core::ffi::c_uint,
    pub rx_crypto_start_cnt: ::core::ffi::c_uint,
    pub rx_crypto_done_cnt: ::core::ffi::c_uint,
    pub rx_event_buf_full: ::core::ffi::c_uint,
    pub rx_extram_buf_full: ::core::ffi::c_uint,
    pub scan_req: ::core::ffi::c_uint,
    pub scan_complete: ::core::ffi::c_uint,
    pub scan_abort_req: ::core::ffi::c_uint,
    pub scan_abort_complete: ::core::ffi::c_uint,
    pub internal_buf_pool_null: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_lmac_prod_stats() {
    const UNINIT: ::core::mem::MaybeUninit<lmac_prod_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lmac_prod_stats>(),
        140usize,
        concat!("Size of: ", stringify!(lmac_prod_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<lmac_prod_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(lmac_prod_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset_cmd_cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(reset_cmd_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset_complete_event_cnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(reset_complete_event_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unable_gen_event) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(unable_gen_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ch_prog_cmd_cnt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(ch_prog_cmd_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_prog_done) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(channel_prog_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_cnt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(tx_pkt_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_done_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(tx_pkt_done_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_pkt_cnt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(scan_pkt_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_pkt_cnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(internal_pkt_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_pkt_done_cnt) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(internal_pkt_done_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ack_resp_cnt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(ack_resp_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_timeout) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(tx_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deagg_isr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(deagg_isr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deagg_inptr_desc_empty) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(deagg_inptr_desc_empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deagg_circular_buffer_full) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(deagg_circular_buffer_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_rxisr_cnt) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(lmac_rxisr_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_decryptcnt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_decryptcnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).process_decrypt_fail) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(process_decrypt_fail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepa_rx_event_fail) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(prepa_rx_event_fail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_core_pool_full_cnt) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_core_pool_full_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_mpdu_crc_success_cnt) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_mpdu_crc_success_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_mpdu_crc_fail_cnt) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_mpdu_crc_fail_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ofdm_crc_success_cnt) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_ofdm_crc_success_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ofdm_crc_fail_cnt) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_ofdm_crc_fail_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxDSSSCrcSuccessCnt) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rxDSSSCrcSuccessCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxDSSSCrcFailCnt) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rxDSSSCrcFailCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_crypto_start_cnt) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_crypto_start_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_crypto_done_cnt) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_crypto_done_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_event_buf_full) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_event_buf_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_extram_buf_full) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(rx_extram_buf_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_req) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(scan_req)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_complete) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(scan_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_abort_req) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(scan_abort_req)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_abort_complete) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(scan_abort_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_buf_pool_null) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_prod_stats),
            "::",
            stringify!(internal_buf_pool_null)
        )
    );
}
#[doc = " struct phy_prod_stats : used to get the production mode stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_prod_stats {
    pub ofdm_crc32_pass_cnt: ::core::ffi::c_uint,
    pub ofdm_crc32_fail_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_pass_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_fail_cnt: ::core::ffi::c_uint,
    pub averageRSSI: ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_phy_prod_stats() {
    const UNINIT: ::core::mem::MaybeUninit<phy_prod_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<phy_prod_stats>(),
        20usize,
        concat!("Size of: ", stringify!(phy_prod_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<phy_prod_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(phy_prod_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ofdm_crc32_pass_cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(phy_prod_stats),
            "::",
            stringify!(ofdm_crc32_pass_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ofdm_crc32_fail_cnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(phy_prod_stats),
            "::",
            stringify!(ofdm_crc32_fail_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsss_crc32_pass_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(phy_prod_stats),
            "::",
            stringify!(dsss_crc32_pass_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsss_crc32_fail_cnt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(phy_prod_stats),
            "::",
            stringify!(dsss_crc32_fail_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).averageRSSI) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(phy_prod_stats),
            "::",
            stringify!(averageRSSI)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rpu_stats {
    pub lmac_stats: lmac_prod_stats,
    pub phy_stats: phy_prod_stats,
}
#[test]
fn bindgen_test_layout_rpu_stats() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_stats>(),
        140usize,
        concat!("Size of: ", stringify!(rpu_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(rpu_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_stats) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_stats),
            "::",
            stringify!(lmac_stats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_stats) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_stats),
            "::",
            stringify!(phy_stats)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct hpqm_queue {
    pub pop_addr: ::core::ffi::c_uint,
    pub push_addr: ::core::ffi::c_uint,
    pub id_num: ::core::ffi::c_uint,
    pub status_addr: ::core::ffi::c_uint,
    pub status_mask: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_hpqm_queue() {
    const UNINIT: ::core::mem::MaybeUninit<hpqm_queue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hpqm_queue>(),
        20usize,
        concat!("Size of: ", stringify!(hpqm_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<hpqm_queue>(),
        1usize,
        concat!("Alignment of ", stringify!(hpqm_queue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pop_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hpqm_queue),
            "::",
            stringify!(pop_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).push_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hpqm_queue),
            "::",
            stringify!(push_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id_num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hpqm_queue),
            "::",
            stringify!(id_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status_addr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hpqm_queue),
            "::",
            stringify!(status_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hpqm_queue),
            "::",
            stringify!(status_mask)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct INT_HPQ {
    pub id: ::core::ffi::c_uint,
    pub head: ::core::ffi::c_uint,
    pub tail: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_INT_HPQ() {
    const UNINIT: ::core::mem::MaybeUninit<INT_HPQ> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<INT_HPQ>(),
        12usize,
        concat!("Size of: ", stringify!(INT_HPQ))
    );
    assert_eq!(
        ::core::mem::align_of::<INT_HPQ>(),
        1usize,
        concat!("Alignment of ", stringify!(INT_HPQ))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(INT_HPQ),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(INT_HPQ),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(INT_HPQ),
            "::",
            stringify!(tail)
        )
    );
}
#[doc = " @brief LMAC firmware config params\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lmac_fw_config_params {
    #[doc = " lmac firmware boot status. LMAC will set to 0x5a5a5a5a after completing boot process"]
    pub boot_status: ::core::ffi::c_uint,
    #[doc = " LMAC version"]
    pub version: ::core::ffi::c_uint,
    #[doc = " Address to resubmit Rx buffers"]
    pub lmac_rx_buffer_addr: ::core::ffi::c_uint,
    #[doc = " Maximum Rx descriptors"]
    pub lmac_rx_max_desc_cnt: ::core::ffi::c_uint,
    #[doc = " size of each descriptor size"]
    pub lmac_rx_desc_size: ::core::ffi::c_uint,
    #[doc = " rpu config name. this is a string"]
    pub rpu_config_name: [::core::ffi::c_uchar; 16usize],
    #[doc = " rpu config number"]
    pub rpu_config_number: [::core::ffi::c_uchar; 8usize],
    #[doc = " numRX"]
    pub numRX: ::core::ffi::c_uint,
    #[doc = " numTX"]
    pub numTX: ::core::ffi::c_uint,
    #[doc = " supported bands"]
    pub bands: ::core::ffi::c_uint,
    #[doc = " system frequency"]
    pub sys_frequency_in_mhz: ::core::ffi::c_uint,
    #[doc = " queue which contains Free GRAM pointers for commands"]
    pub FreeCmdPtrQ: hpqm_queue,
    #[doc = " Command pointer queue. Host should pick pointer from FreeCmdPtrQ, populate\n  command into that address and submit back to this queue for RPU"]
    pub cmdPtrQ: hpqm_queue,
    #[doc = " queue which contains Free GRAM pointers for events"]
    pub eventPtrQ: hpqm_queue,
    #[doc = " Event pointer queue. Host should pick pointer from FreeCmdPtrQ, populate\n  command into that address and submit back to this queue for RPU"]
    pub freeEventPtrQ: hpqm_queue,
    #[doc = " Rx buffer queue"]
    pub SKBGramPtrQ_1: hpqm_queue,
    #[doc = " Rx buffer queue"]
    pub SKBGramPtrQ_2: hpqm_queue,
    #[doc = " Rx buffer queue"]
    pub SKBGramPtrQ_3: hpqm_queue,
    #[doc = " lmac register address to enable ISR to Host"]
    pub HP_lmac_to_host_isr_en: ::core::ffi::c_uint,
    #[doc = " Address to Clear host ISR"]
    pub HP_lmac_to_host_isr_clear: ::core::ffi::c_uint,
    #[doc = " Address to set ISR to lmac Clear host ISR"]
    pub HP_set_lmac_isr: ::core::ffi::c_uint,
    #[doc = " Hardware queues"]
    pub hpq32: [INT_HPQ; 4usize],
}
#[test]
fn bindgen_test_layout_lmac_fw_config_params() {
    const UNINIT: ::core::mem::MaybeUninit<lmac_fw_config_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lmac_fw_config_params>(),
        260usize,
        concat!("Size of: ", stringify!(lmac_fw_config_params))
    );
    assert_eq!(
        ::core::mem::align_of::<lmac_fw_config_params>(),
        1usize,
        concat!("Alignment of ", stringify!(lmac_fw_config_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).boot_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(boot_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_rx_buffer_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(lmac_rx_buffer_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_rx_max_desc_cnt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(lmac_rx_max_desc_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_rx_desc_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(lmac_rx_desc_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rpu_config_name) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(rpu_config_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rpu_config_number) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(rpu_config_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRX) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(numRX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTX) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(numTX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(bands)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_frequency_in_mhz) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(sys_frequency_in_mhz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreeCmdPtrQ) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(FreeCmdPtrQ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmdPtrQ) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(cmdPtrQ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventPtrQ) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(eventPtrQ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freeEventPtrQ) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(freeEventPtrQ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SKBGramPtrQ_1) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(SKBGramPtrQ_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SKBGramPtrQ_2) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(SKBGramPtrQ_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SKBGramPtrQ_3) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(SKBGramPtrQ_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HP_lmac_to_host_isr_en) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(HP_lmac_to_host_isr_en)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HP_lmac_to_host_isr_clear) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(HP_lmac_to_host_isr_clear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HP_set_lmac_isr) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(HP_set_lmac_isr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hpq32) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(lmac_fw_config_params),
            "::",
            stringify!(hpq32)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rx_buf_pool_params {
    #[doc = " buffer size"]
    pub buf_sz: ::core::ffi::c_ushort,
    #[doc = " number of buffers"]
    pub num_bufs: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_rx_buf_pool_params() {
    const UNINIT: ::core::mem::MaybeUninit<rx_buf_pool_params> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rx_buf_pool_params>(),
        4usize,
        concat!("Size of: ", stringify!(rx_buf_pool_params))
    );
    assert_eq!(
        ::core::mem::align_of::<rx_buf_pool_params>(),
        1usize,
        concat!("Alignment of ", stringify!(rx_buf_pool_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf_sz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_buf_pool_params),
            "::",
            stringify!(buf_sz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_bufs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_buf_pool_params),
            "::",
            stringify!(num_bufs)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct temp_vbat_config {
    pub temp_based_calib_en: ::core::ffi::c_uint,
    pub temp_calib_bitmap: ::core::ffi::c_uint,
    pub vbat_calibp_bitmap: ::core::ffi::c_uint,
    pub temp_vbat_mon_period: ::core::ffi::c_uint,
    pub vth_very_low: ::core::ffi::c_int,
    pub vth_low: ::core::ffi::c_int,
    pub vth_hi: ::core::ffi::c_int,
    pub temp_threshold: ::core::ffi::c_int,
    pub vbat_threshold: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_temp_vbat_config() {
    const UNINIT: ::core::mem::MaybeUninit<temp_vbat_config> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<temp_vbat_config>(),
        36usize,
        concat!("Size of: ", stringify!(temp_vbat_config))
    );
    assert_eq!(
        ::core::mem::align_of::<temp_vbat_config>(),
        1usize,
        concat!("Alignment of ", stringify!(temp_vbat_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp_based_calib_en) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(temp_based_calib_en)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp_calib_bitmap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(temp_calib_bitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vbat_calibp_bitmap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(vbat_calibp_bitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp_vbat_mon_period) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(temp_vbat_mon_period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vth_very_low) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(vth_very_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vth_low) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(vth_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vth_hi) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(vth_hi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp_threshold) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(temp_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vbat_threshold) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(temp_vbat_config),
            "::",
            stringify!(vbat_threshold)
        )
    );
}
#[repr(u32)]
#[doc = " @brief This enum provides a list of different operating modes.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_op_mode {
    #[doc = " Radio test mode is used for performing radio tests using\n  continuous Tx/Rx on a configured channel at a particular rate or power."]
    RPU_OP_MODE_RADIO_TEST = 0,
    #[doc = " In this mode different types of calibration like RF calibration can be performed"]
    RPU_OP_MODE_FCM = 1,
    #[doc = " Regular mode of operation"]
    RPU_OP_MODE_REG = 2,
    #[doc = " Debug mode can be used to control certain parameters like TX rate\n  in order to debug functional issues."]
    RPU_OP_MODE_DBG = 3,
    #[doc = " Highest mode number currently defined"]
    RPU_OP_MODE_MAX = 4,
}
#[repr(u32)]
#[doc = "  @brief This enum defines various types of statistics."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_stats_type {
    #[doc = " All statistics includes PHY, LMAC & UMAC"]
    RPU_STATS_TYPE_ALL = 0,
    #[doc = " Host statistics"]
    RPU_STATS_TYPE_HOST = 1,
    #[doc = " UMAC statistics"]
    RPU_STATS_TYPE_UMAC = 2,
    #[doc = " LMAC statistics"]
    RPU_STATS_TYPE_LMAC = 3,
    #[doc = " PHY statistics"]
    RPU_STATS_TYPE_PHY = 4,
    #[doc = " Highest statistics type number currently defined"]
    RPU_STATS_TYPE_MAX = 5,
}
#[repr(u32)]
#[doc = " @brief- Throughput mode\n Throughput mode to be used for transmitting the packet."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_tput_mode {
    #[doc = " Legacy mode"]
    RPU_TPUT_MODE_LEGACY = 0,
    #[doc = " High Throuput mode(11n)"]
    RPU_TPUT_MODE_HT = 1,
    #[doc = " Very hight throughput(11ac)"]
    RPU_TPUT_MODE_VHT = 2,
    #[doc = " HE SU mode"]
    RPU_TPUT_MODE_HE_SU = 3,
    #[doc = " HE ER SU mode"]
    RPU_TPUT_MODE_HE_ER_SU = 4,
    #[doc = " HE TB mode"]
    RPU_TPUT_MODE_HE_TB = 5,
    #[doc = " Highest throughput mode currently defined"]
    RPU_TPUT_MODE_MAX = 6,
}
#[repr(u32)]
#[doc = " @brief - System commands.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_sys_commands {
    #[doc = " Command to initialize RPU and RPU responds with NRF_WIFI_EVENT_INIT_DONE"]
    NRF_WIFI_CMD_INIT = 0,
    #[doc = " command to send a Tx packet in radiotest mode"]
    NRF_WIFI_CMD_TX = 1,
    #[doc = " Unused"]
    NRF_WIFI_CMD_IF_TYPE = 2,
    #[doc = " command to specify mode of operation"]
    NRF_WIFI_CMD_MODE = 3,
    #[doc = " command to get statistics"]
    NRF_WIFI_CMD_GET_STATS = 4,
    #[doc = " command to clear statistics"]
    NRF_WIFI_CMD_CLEAR_STATS = 5,
    #[doc = " command to ENABLE/DISABLE receiving packets in radiotest mode"]
    NRF_WIFI_CMD_RX = 6,
    #[doc = " Command to measure battery voltage and RPU responds\twith NRF_WIFI_EVENT_PWR_DATA"]
    NRF_WIFI_CMD_PWR = 7,
    #[doc = " RPU De-initialization"]
    NRF_WIFI_CMD_DEINIT = 8,
    #[doc = " Command for WIFI & Bluetooth coexistence"]
    NRF_WIFI_CMD_BTCOEX = 9,
    #[doc = " Command to start RF test"]
    NRF_WIFI_CMD_RF_TEST = 10,
    #[doc = " Configure HE_GI & HE_LTF"]
    NRF_WIFI_CMD_HE_GI_LTF_CONFIG = 11,
    #[doc = " Command for getting UMAC memory statistics"]
    NRF_WIFI_CMD_UMAC_INT_STATS = 12,
    #[doc = " Command for Setting the channel & Rf params in radiotest mode"]
    NRF_WIFI_CMD_RADIO_TEST_INIT = 13,
    #[doc = " Command for setting country in radiotest mode"]
    NRF_WIFI_CMD_RT_REQ_SET_REG = 14,
    #[doc = " Command to enable/disable fixed data rate in regular mode"]
    NRF_WIFI_CMD_TX_FIX_DATA_RATE = 15,
}
#[repr(u32)]
#[doc = " @brief - Events from the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_sys_events {
    #[doc = " Response to NRF_WIFI_CMD_PWR"]
    NRF_WIFI_EVENT_PWR_DATA = 0,
    #[doc = " Response to NRF_WIFI_CMD_INIT"]
    NRF_WIFI_EVENT_INIT_DONE = 1,
    #[doc = " Response to NRF_WIFI_CMD_GET_STATS"]
    NRF_WIFI_EVENT_STATS = 2,
    #[doc = " Response to NRF_WIFI_CMD_DEINIT"]
    NRF_WIFI_EVENT_DEINIT_DONE = 3,
    #[doc = " Response to NRF_WIFI_CMD_RF_TEST"]
    NRF_WIFI_EVENT_RF_TEST = 4,
    #[doc = " Response to NRF_WIFI_CMD_BTCOEX."]
    NRF_WIFI_EVENT_COEX_CONFIG = 5,
    #[doc = " Response to NRF_WIFI_CMD_UMAC_INT_STATS"]
    NRF_WIFI_EVENT_INT_UMAC_STATS = 6,
    #[doc = " Command status events for radio test commands"]
    NRF_WIFI_EVENT_RADIOCMD_STATUS = 7,
}
#[repr(u32)]
#[doc = " @brief - Channel Bandwidth types.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_ch_bw {
    #[doc = " 20MHz bandwidth"]
    RPU_CH_BW_20 = 0,
    #[doc = " 40MHz bandwidth"]
    RPU_CH_BW_40 = 1,
    #[doc = " 80MHz bandwidth"]
    RPU_CH_BW_MAX = 2,
}
#[doc = " @brief - This structure specifies the parameters required to configure a specific channel.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct chan_params {
    #[doc = " Primary channel number"]
    pub primary_num: ::core::ffi::c_uint,
    #[doc = " Channel bandwidth"]
    pub bw: ::core::ffi::c_uchar,
    #[doc = " 20Mhz offset value"]
    pub sec_20_offset: ::core::ffi::c_int,
    #[doc = " 40Mhz offset value"]
    pub sec_40_offset: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_chan_params() {
    const UNINIT: ::core::mem::MaybeUninit<chan_params> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<chan_params>(),
        13usize,
        concat!("Size of: ", stringify!(chan_params))
    );
    assert_eq!(
        ::core::mem::align_of::<chan_params>(),
        1usize,
        concat!("Alignment of ", stringify!(chan_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).primary_num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chan_params),
            "::",
            stringify!(primary_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(chan_params),
            "::",
            stringify!(bw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sec_20_offset) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(chan_params),
            "::",
            stringify!(sec_20_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sec_40_offset) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(chan_params),
            "::",
            stringify!(sec_40_offset)
        )
    );
}
#[doc = " @brief This structure specifies the parameters required to start or stop the RX (receive)\n  operation in radiotest mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_conf_rx_radio_test_params {
    #[doc = " Number of spatial streams supported. Currently unused."]
    pub nss: ::core::ffi::c_uchar,
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " An array containing RF and baseband control params"]
    pub chan: chan_params,
    #[doc = " Copy OTP params to this memory"]
    pub phy_threshold: ::core::ffi::c_schar,
    #[doc = " Calibration bit map value. More information can be found in the phy_rf_params.h file."]
    pub phy_calib: ::core::ffi::c_uint,
    #[doc = " Start Rx : 1, Stop Rx :0"]
    pub rx: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_rpu_conf_rx_radio_test_params() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_conf_rx_radio_test_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_conf_rx_radio_test_params>(),
        220usize,
        concat!("Size of: ", stringify!(rpu_conf_rx_radio_test_params))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_conf_rx_radio_test_params>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_conf_rx_radio_test_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_rx_radio_test_params),
            "::",
            stringify!(nss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_params) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_rx_radio_test_params),
            "::",
            stringify!(rf_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chan) as usize - ptr as usize },
        201usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_rx_radio_test_params),
            "::",
            stringify!(chan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_threshold) as usize - ptr as usize },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_rx_radio_test_params),
            "::",
            stringify!(phy_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_calib) as usize - ptr as usize },
        215usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_rx_radio_test_params),
            "::",
            stringify!(phy_calib)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        219usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_rx_radio_test_params),
            "::",
            stringify!(rx)
        )
    );
}
#[doc = " @brief This structure specifies the UMAC (Upper MAC) RX (receive) debug parameters\n  specifically designed for debugging purpose.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_rx_dbg_params {
    #[doc = " Total lmac events received to UMAC"]
    pub lmac_events: ::core::ffi::c_uint,
    #[doc = " Total Rx events(LMAC_EVENT_RX) received in ISR"]
    pub rx_events: ::core::ffi::c_uint,
    #[doc = " Received coalised events from LMAC"]
    pub rx_coalesce_events: ::core::ffi::c_uint,
    #[doc = " Total Rx packets received from LMAC"]
    pub total_rx_pkts_from_lmac: ::core::ffi::c_uint,
    #[doc = " Maximum RX packets buffered at any point of time in UMAC."]
    pub max_refill_gap: ::core::ffi::c_uint,
    #[doc = " Difference between rx packets received from lmac and packets sent to host"]
    pub current_refill_gap: ::core::ffi::c_uint,
    #[doc = " Number of Packets queued to reorder buffer due to out of order"]
    pub out_of_order_mpdus: ::core::ffi::c_uint,
    #[doc = " Number of packets removed from reorder buffer"]
    pub reorder_free_mpdus: ::core::ffi::c_uint,
    #[doc = " Number of Rx packets resubmitted to LMAC by UMAC"]
    pub umac_consumed_pkts: ::core::ffi::c_uint,
    #[doc = " Number of Rx packets sent to Host for resubmiting"]
    pub host_consumed_pkts: ::core::ffi::c_uint,
    #[doc = " Total events posted to UMAC RX thread from LMAC"]
    pub rx_mbox_post: ::core::ffi::c_uint,
    #[doc = " Total events received to UMAC RX thread from LMAC"]
    pub rx_mbox_receive: ::core::ffi::c_uint,
    #[doc = " Number of packets received in out of order"]
    pub reordering_ampdu: ::core::ffi::c_uint,
    #[doc = " Messages posted  to TX mbox from timer ISR"]
    pub timer_mbox_post: ::core::ffi::c_uint,
    #[doc = " Messages received from timer ISR"]
    pub timer_mbox_rcv: ::core::ffi::c_uint,
    #[doc = " Messages posted to TX mbox from work scheduler"]
    pub work_mbox_post: ::core::ffi::c_uint,
    #[doc = " Messages received from work scheduler"]
    pub work_mbox_rcv: ::core::ffi::c_uint,
    #[doc = " Messages posted to TX mbox from tasklet function"]
    pub tasklet_mbox_post: ::core::ffi::c_uint,
    #[doc = " Messages received from tasklet function"]
    pub tasklet_mbox_rcv: ::core::ffi::c_uint,
    #[doc = " Management frames sent to userspace"]
    pub userspace_offload_frames: ::core::ffi::c_uint,
    #[doc = " Number of times where requested buffer size is not available\n  and allocated from next available memory buffer"]
    pub alloc_buf_fail: ::core::ffi::c_uint,
    #[doc = " Total packets count in RX thread"]
    pub rx_packet_total_count: ::core::ffi::c_uint,
    #[doc = " Number of data packets received"]
    pub rx_packet_data_count: ::core::ffi::c_uint,
    #[doc = " Number of Qos data packets received"]
    pub rx_packet_qos_data_count: ::core::ffi::c_uint,
    #[doc = " Number of protected data packets received"]
    pub rx_packet_protected_data_count: ::core::ffi::c_uint,
    #[doc = " Number of management packets received"]
    pub rx_packet_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets received"]
    pub rx_packet_beacon_count: ::core::ffi::c_uint,
    #[doc = " Number of probe response packets received"]
    pub rx_packet_probe_resp_count: ::core::ffi::c_uint,
    #[doc = " Number of authentication packets received"]
    pub rx_packet_auth_count: ::core::ffi::c_uint,
    #[doc = " Number of deauthentication packets received"]
    pub rx_packet_deauth_count: ::core::ffi::c_uint,
    #[doc = " Number of assoc response packets received"]
    pub rx_packet_assoc_resp_count: ::core::ffi::c_uint,
    #[doc = " Number of disassociation packets received"]
    pub rx_packet_disassoc_count: ::core::ffi::c_uint,
    #[doc = " Number of action frames received"]
    pub rx_packet_action_count: ::core::ffi::c_uint,
    #[doc = " Number of probe request packets received"]
    pub rx_packet_probe_req_count: ::core::ffi::c_uint,
    #[doc = " Other management packets received"]
    pub rx_packet_other_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Maximum coalised packets received from LMAC in any RX event"]
    pub max_coalesce_pkts: ::core::ffi::c_schar,
    #[doc = " Packets received with null skb pointer from LMAC"]
    pub null_skb_pointer_from_lmac: ::core::ffi::c_uint,
    #[doc = " Number of unexpected management packets received in coalesce event"]
    pub unexpected_mgmt_pkt: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_umac_rx_dbg_params() {
    const UNINIT: ::core::mem::MaybeUninit<umac_rx_dbg_params> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<umac_rx_dbg_params>(),
        149usize,
        concat!("Size of: ", stringify!(umac_rx_dbg_params))
    );
    assert_eq!(
        ::core::mem::align_of::<umac_rx_dbg_params>(),
        1usize,
        concat!("Alignment of ", stringify!(umac_rx_dbg_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_events) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(lmac_events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_coalesce_events) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_coalesce_events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_rx_pkts_from_lmac) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(total_rx_pkts_from_lmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_refill_gap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(max_refill_gap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_refill_gap) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(current_refill_gap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_of_order_mpdus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(out_of_order_mpdus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reorder_free_mpdus) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(reorder_free_mpdus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_consumed_pkts) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(umac_consumed_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_consumed_pkts) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(host_consumed_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_mbox_post) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_mbox_post)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_mbox_receive) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_mbox_receive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reordering_ampdu) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(reordering_ampdu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timer_mbox_post) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(timer_mbox_post)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timer_mbox_rcv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(timer_mbox_rcv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_mbox_post) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(work_mbox_post)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_mbox_rcv) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(work_mbox_rcv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tasklet_mbox_post) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(tasklet_mbox_post)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tasklet_mbox_rcv) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(tasklet_mbox_rcv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userspace_offload_frames) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(userspace_offload_frames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc_buf_fail) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(alloc_buf_fail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_total_count) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_total_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_data_count) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_data_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_qos_data_count) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_qos_data_count)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).rx_packet_protected_data_count) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_protected_data_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_mgmt_count) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_mgmt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_beacon_count) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_beacon_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_probe_resp_count) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_probe_resp_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_auth_count) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_auth_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_deauth_count) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_deauth_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_assoc_resp_count) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_assoc_resp_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_disassoc_count) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_disassoc_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_action_count) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_action_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_probe_req_count) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_probe_req_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_other_mgmt_count) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(rx_packet_other_mgmt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_coalesce_pkts) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(max_coalesce_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).null_skb_pointer_from_lmac) as usize - ptr as usize },
        141usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(null_skb_pointer_from_lmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unexpected_mgmt_pkt) as usize - ptr as usize },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_rx_dbg_params),
            "::",
            stringify!(unexpected_mgmt_pkt)
        )
    );
}
#[doc = " @brief This structure specifies the UMAC TX (transmit) debug parameters used for\n  debugging purposes.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_tx_dbg_params {
    #[doc = " Total number of tx commands received from host"]
    pub tx_cmd: ::core::ffi::c_uint,
    #[doc = " Non coalesce packets received"]
    pub tx_non_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " coalesce packets received"]
    pub tx_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Maximum number of coalesce packets received in any\n  TX command coalesce packets received"]
    pub tx_max_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Maximum Tx commands currently in process at any point of time in UMAC"]
    pub tx_cmds_max_used: ::core::ffi::c_uint,
    #[doc = " Number of Tx commands that are currently in process in UMAC"]
    pub tx_cmds_currently_in_use: ::core::ffi::c_uint,
    #[doc = " Number of tx done events sent to host"]
    pub tx_done_events_send_to_host: ::core::ffi::c_uint,
    #[doc = " Number of tx done success packets sent to host"]
    pub tx_done_success_pkts_to_host: ::core::ffi::c_uint,
    #[doc = " Number of tx done failure packets sent to host"]
    pub tx_done_failure_pkts_to_host: ::core::ffi::c_uint,
    #[doc = " Number of packets received from host that needs to be encrypted"]
    pub tx_cmds_with_crypto_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of packets received from host that need not to be encrypted"]
    pub tx_cmds_with_non_crypto_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of broadcast\tpackets received from host"]
    pub tx_cmds_with_broadcast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of multicast\tpackets received from host"]
    pub tx_cmds_with_multicast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of unicast packets received from host"]
    pub tx_cmds_with_unicast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " UMAC internal count"]
    pub xmit: ::core::ffi::c_uint,
    #[doc = " Number of addba requests sent"]
    pub send_addba_req: ::core::ffi::c_uint,
    #[doc = " Total ADD BA responses received from host"]
    pub addba_resp: ::core::ffi::c_uint,
    #[doc = " Total packets received in softmac tx function"]
    pub softmac_tx: ::core::ffi::c_uint,
    #[doc = " Number of packets generated internally in UMAC"]
    pub internal_pkts: ::core::ffi::c_uint,
    #[doc = " Number of packets Received from host"]
    pub external_pkts: ::core::ffi::c_uint,
    #[doc = " Total tx commmands sent to lmac"]
    pub tx_cmds_to_lmac: ::core::ffi::c_uint,
    #[doc = " Tx dones received from LMAC"]
    pub tx_dones_from_lmac: ::core::ffi::c_uint,
    #[doc = " Total commands sent to lmac in UMAC hal"]
    pub total_cmds_to_lmac: ::core::ffi::c_uint,
    #[doc = " Number of data packets sent"]
    pub tx_packet_data_count: ::core::ffi::c_uint,
    #[doc = " Number of management packets sent"]
    pub tx_packet_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets sent"]
    pub tx_packet_beacon_count: ::core::ffi::c_uint,
    #[doc = " Number of probe request packets sent"]
    pub tx_packet_probe_req_count: ::core::ffi::c_uint,
    #[doc = " Number of authentication packets sent"]
    pub tx_packet_auth_count: ::core::ffi::c_uint,
    #[doc = " Number of deauthentication packets sent"]
    pub tx_packet_deauth_count: ::core::ffi::c_uint,
    #[doc = " Number of association request packets sent"]
    pub tx_packet_assoc_req_count: ::core::ffi::c_uint,
    #[doc = " Number of disassociation packets sent"]
    pub tx_packet_disassoc_count: ::core::ffi::c_uint,
    #[doc = " Number of action packets sent"]
    pub tx_packet_action_count: ::core::ffi::c_uint,
    #[doc = " Other management packets sent"]
    pub tx_packet_other_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Number of Non management packets sent"]
    pub tx_packet_non_mgmt_data_count: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_umac_tx_dbg_params() {
    const UNINIT: ::core::mem::MaybeUninit<umac_tx_dbg_params> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<umac_tx_dbg_params>(),
        136usize,
        concat!("Size of: ", stringify!(umac_tx_dbg_params))
    );
    assert_eq!(
        ::core::mem::align_of::<umac_tx_dbg_params>(),
        1usize,
        concat!("Alignment of ", stringify!(umac_tx_dbg_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmd)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_non_coalesce_pkts_rcvd_from_host) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_non_coalesce_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_coalesce_pkts_rcvd_from_host) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_coalesce_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_max_coalesce_pkts_rcvd_from_host) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_max_coalesce_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_cmds_max_used) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_max_used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_cmds_currently_in_use) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_currently_in_use)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_done_events_send_to_host) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_done_events_send_to_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_done_success_pkts_to_host) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_done_success_pkts_to_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_done_failure_pkts_to_host) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_done_failure_pkts_to_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_cmds_with_crypto_pkts_rcvd_from_host) as usize
                - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_with_crypto_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_cmds_with_non_crypto_pkts_rcvd_from_host) as usize
                - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_with_non_crypto_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_cmds_with_broadcast_pkts_rcvd_from_host) as usize
                - ptr as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_with_broadcast_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_cmds_with_multicast_pkts_rcvd_from_host) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_with_multicast_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_cmds_with_unicast_pkts_rcvd_from_host) as usize
                - ptr as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_with_unicast_pkts_rcvd_from_host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xmit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(xmit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_addba_req) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(send_addba_req)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addba_resp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(addba_resp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).softmac_tx) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(softmac_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_pkts) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(internal_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).external_pkts) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(external_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_cmds_to_lmac) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_cmds_to_lmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_dones_from_lmac) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_dones_from_lmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_cmds_to_lmac) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(total_cmds_to_lmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_data_count) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_data_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_mgmt_count) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_mgmt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_beacon_count) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_beacon_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_probe_req_count) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_probe_req_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_auth_count) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_auth_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_deauth_count) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_deauth_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_assoc_req_count) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_assoc_req_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_disassoc_count) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_disassoc_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_action_count) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_action_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_other_mgmt_count) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_other_mgmt_count)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).tx_packet_non_mgmt_data_count) as usize - ptr as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_tx_dbg_params),
            "::",
            stringify!(tx_packet_non_mgmt_data_count)
        )
    );
}
#[doc = " @brief This structure specifies the UMAC command and event debug parameters used for\n  debugging purpose.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_evnt_dbg_params {
    #[doc = " Number of command init received from host"]
    pub cmd_init: ::core::ffi::c_uchar,
    #[doc = " Number of init_done events sent to host"]
    pub event_init_done: ::core::ffi::c_uchar,
    #[doc = " Number of rf test command received from host"]
    pub cmd_rf_test: ::core::ffi::c_uchar,
    #[doc = " Number of connect command received from host"]
    pub cmd_connect: ::core::ffi::c_uchar,
    #[doc = " Number of get_stats command received from host"]
    pub cmd_get_stats: ::core::ffi::c_uint,
    #[doc = " Number of power save state events sent to host"]
    pub event_ps_state: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub cmd_set_reg: ::core::ffi::c_uint,
    #[doc = " Number of get regulatory commands received from host"]
    pub cmd_get_reg: ::core::ffi::c_uint,
    #[doc = " Number of request set regulatory commands received from host"]
    pub cmd_req_set_reg: ::core::ffi::c_uint,
    #[doc = " Number of trigger scan commands received from host"]
    pub cmd_trigger_scan: ::core::ffi::c_uint,
    #[doc = " Number of scan done events sent to host"]
    pub event_scan_done: ::core::ffi::c_uint,
    #[doc = " Number of get scan commands received from the host to get scan results"]
    pub cmd_get_scan: ::core::ffi::c_uint,
    #[doc = " Number of scan commands sent to LMAC"]
    pub umac_scan_req: ::core::ffi::c_uint,
    #[doc = " Number of scan complete events received from LMAC"]
    pub umac_scan_complete: ::core::ffi::c_uint,
    #[doc = " Number of scan requests received from host when previous scan is in progress"]
    pub umac_scan_busy: ::core::ffi::c_uint,
    #[doc = " Number of authentication requests received from host"]
    pub cmd_auth: ::core::ffi::c_uint,
    #[doc = " Number of association requests received from host"]
    pub cmd_assoc: ::core::ffi::c_uint,
    #[doc = " Number of deauthentication requests received from host"]
    pub cmd_deauth: ::core::ffi::c_uint,
    #[doc = " Number of register frame commands received from host to register\n  a management frame type which should be passed to host"]
    pub cmd_register_frame: ::core::ffi::c_uint,
    #[doc = " Number of command frames from host which will be used for\n  transmitting management frames"]
    pub cmd_frame: ::core::ffi::c_uint,
    #[doc = " Number of delete key commands from host"]
    pub cmd_del_key: ::core::ffi::c_uint,
    #[doc = " Number of new key commands received from host"]
    pub cmd_new_key: ::core::ffi::c_uint,
    #[doc = " Number of set key commands received from host"]
    pub cmd_set_key: ::core::ffi::c_uint,
    #[doc = " Number of get key commands received from host"]
    pub cmd_get_key: ::core::ffi::c_uint,
    #[doc = " Number of beacon hint events sent to host"]
    pub event_beacon_hint: ::core::ffi::c_uint,
    #[doc = " Number of regulatory change events sent to host when regulatory change command\n  received from host such as in response to command NL80211_CMD_REG_CHANGE"]
    pub event_reg_change: ::core::ffi::c_uint,
    #[doc = " Number of regulatory change events sent to host other than\n  host request for regulatory change"]
    pub event_wiphy_reg_change: ::core::ffi::c_uint,
    #[doc = " Number of set station commands received from host"]
    pub cmd_set_station: ::core::ffi::c_uint,
    #[doc = " Number of new station commands received from host"]
    pub cmd_new_station: ::core::ffi::c_uint,
    #[doc = " Number of del station commands received from host"]
    pub cmd_del_station: ::core::ffi::c_uint,
    #[doc = " Number of new interface commands received from host"]
    pub cmd_new_interface: ::core::ffi::c_uint,
    #[doc = " Number of set interface commands received from host"]
    pub cmd_set_interface: ::core::ffi::c_uint,
    #[doc = " Number of get interface commands received from host"]
    pub cmd_get_interface: ::core::ffi::c_uint,
    #[doc = " Number of set_ifflags commands received from host"]
    pub cmd_set_ifflags: ::core::ffi::c_uint,
    #[doc = " Number of set_ifflags events sent to host"]
    pub cmd_set_ifflags_done: ::core::ffi::c_uint,
    #[doc = " Number of set bss command received from host"]
    pub cmd_set_bss: ::core::ffi::c_uint,
    #[doc = " Number of set wiphy command received from host"]
    pub cmd_set_wiphy: ::core::ffi::c_uint,
    #[doc = " Number of start access point command received from host"]
    pub cmd_start_ap: ::core::ffi::c_uint,
    #[doc = " Number of power save configuration commands sent to LMAC"]
    pub LMAC_CMD_PS: ::core::ffi::c_uint,
    #[doc = " Current power save state configured to LMAC through LMAC_CMD_PS command"]
    pub CURR_STATE: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_umac_cmd_evnt_dbg_params() {
    const UNINIT: ::core::mem::MaybeUninit<umac_cmd_evnt_dbg_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<umac_cmd_evnt_dbg_params>(),
        148usize,
        concat!("Size of: ", stringify!(umac_cmd_evnt_dbg_params))
    );
    assert_eq!(
        ::core::mem::align_of::<umac_cmd_evnt_dbg_params>(),
        1usize,
        concat!("Alignment of ", stringify!(umac_cmd_evnt_dbg_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_init_done) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(event_init_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_rf_test) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_rf_test)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_connect) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_connect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_get_stats) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_get_stats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_ps_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(event_ps_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_reg) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_reg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_get_reg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_get_reg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_req_set_reg) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_req_set_reg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_trigger_scan) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_trigger_scan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_scan_done) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(event_scan_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_get_scan) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_get_scan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_scan_req) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(umac_scan_req)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_scan_complete) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(umac_scan_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_scan_busy) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(umac_scan_busy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_auth) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_auth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_assoc) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_assoc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_deauth) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_deauth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_register_frame) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_register_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_frame) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_del_key) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_del_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_new_key) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_new_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_key) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_get_key) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_get_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_beacon_hint) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(event_beacon_hint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_reg_change) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(event_reg_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_wiphy_reg_change) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(event_wiphy_reg_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_station) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_station)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_new_station) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_new_station)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_del_station) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_del_station)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_new_interface) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_new_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_interface) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_get_interface) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_get_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_ifflags) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_ifflags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_ifflags_done) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_ifflags_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_bss) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_bss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_set_wiphy) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_set_wiphy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_start_ap) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(cmd_start_ap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LMAC_CMD_PS) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(LMAC_CMD_PS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CURR_STATE) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_cmd_evnt_dbg_params),
            "::",
            stringify!(CURR_STATE)
        )
    );
}
#[doc = " @brief This structure specifies the UMAC interface debug parameters used for debugging purpose.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_interface_stats {
    #[doc = " Number of unicast packets sent"]
    pub tx_unicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of multicast packets sent"]
    pub tx_multicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of broadcast packets sent"]
    pub tx_broadcast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of tx data bytes sent"]
    pub tx_bytes: ::core::ffi::c_uint,
    #[doc = " Number of unicast packets received"]
    pub rx_unicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of multicast packets received"]
    pub rx_multicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of broadcast packets received"]
    pub rx_broadcast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets received"]
    pub rx_beacon_success_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets missed"]
    pub rx_beacon_miss_count: ::core::ffi::c_uint,
    #[doc = " Number of rx data bytes received"]
    pub rx_bytes: ::core::ffi::c_uint,
    #[doc = " Number of packets with checksum mismatch received"]
    pub rx_checksum_error_count: ::core::ffi::c_uint,
    #[doc = " Number of duplicate packets received"]
    pub replay_attack_drop_cnt: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_interface_stats() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_interface_stats> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_interface_stats>(),
        48usize,
        concat!("Size of: ", stringify!(nrf_wifi_interface_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_interface_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_interface_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_unicast_pkt_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(tx_unicast_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_multicast_pkt_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(tx_multicast_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_broadcast_pkt_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(tx_broadcast_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_unicast_pkt_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(rx_unicast_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_multicast_pkt_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(rx_multicast_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_broadcast_pkt_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(rx_broadcast_pkt_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_beacon_success_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(rx_beacon_success_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_beacon_miss_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(rx_beacon_miss_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_bytes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_checksum_error_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(rx_checksum_error_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).replay_attack_drop_cnt) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_stats),
            "::",
            stringify!(replay_attack_drop_cnt)
        )
    );
}
#[doc = " @brief This structure defines the UMAC debug statistics. It contains the necessary parameters\n  and fields used to gather and present debugging statistics within the UMAC layer.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_umac_stats {
    #[doc = " Transmit debug statistics @ref umac_tx_dbg_params"]
    pub tx_dbg_params: umac_tx_dbg_params,
    #[doc = " Receive debug statistics @ref umac_rx_dbg_params"]
    pub rx_dbg_params: umac_rx_dbg_params,
    #[doc = " Command Event debug statistics @ref umac_cmd_evnt_dbg_params"]
    pub cmd_evnt_dbg_params: umac_cmd_evnt_dbg_params,
    #[doc = " Interface debug parameters @ref nrf_wifi_interface_stats"]
    pub interface_data_stats: nrf_wifi_interface_stats,
}
#[test]
fn bindgen_test_layout_rpu_umac_stats() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_umac_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_umac_stats>(),
        481usize,
        concat!("Size of: ", stringify!(rpu_umac_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_umac_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_umac_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_dbg_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_umac_stats),
            "::",
            stringify!(tx_dbg_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_dbg_params) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_umac_stats),
            "::",
            stringify!(rx_dbg_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_evnt_dbg_params) as usize - ptr as usize },
        285usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_umac_stats),
            "::",
            stringify!(cmd_evnt_dbg_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface_data_stats) as usize - ptr as usize },
        433usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_umac_stats),
            "::",
            stringify!(interface_data_stats)
        )
    );
}
#[doc = " @brief This structure defines the LMAC debug parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_lmac_stats {
    #[doc = " Number of reset command counts from UMAC"]
    pub reset_cmd_cnt: ::core::ffi::c_uint,
    #[doc = " Number of reset complete events sent to UMAC"]
    pub reset_complete_event_cnt: ::core::ffi::c_uint,
    #[doc = " Number of events unable to generate"]
    pub unable_gen_event: ::core::ffi::c_uint,
    #[doc = " Number of channel program commands from UMAC"]
    pub ch_prog_cmd_cnt: ::core::ffi::c_uint,
    #[doc = " Number of channel program done events to UMAC"]
    pub channel_prog_done: ::core::ffi::c_uint,
    #[doc = " Number of Tx commands from UMAC"]
    pub tx_pkt_cnt: ::core::ffi::c_uint,
    #[doc = " Number of Tx done events to UMAC"]
    pub tx_pkt_done_cnt: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub scan_pkt_cnt: ::core::ffi::c_uint,
    #[doc = " Number of internal Tx packets"]
    pub internal_pkt_cnt: ::core::ffi::c_uint,
    #[doc = " Number of Tx dones for internal packets"]
    pub internal_pkt_done_cnt: ::core::ffi::c_uint,
    #[doc = " Number of acknowledgment responses"]
    pub ack_resp_cnt: ::core::ffi::c_uint,
    #[doc = " Number of transmit timeouts"]
    pub tx_timeout: ::core::ffi::c_uint,
    #[doc = " Number of deaggregation ISRs"]
    pub deagg_isr: ::core::ffi::c_uint,
    #[doc = " Number of deaggregation input descriptor empties"]
    pub deagg_inptr_desc_empty: ::core::ffi::c_uint,
    #[doc = " Number of deaggregation circular buffer full events"]
    pub deagg_circular_buffer_full: ::core::ffi::c_uint,
    #[doc = " Number of LMAC received ISRs"]
    pub lmac_rxisr_cnt: ::core::ffi::c_uint,
    #[doc = " Number of received packets decrypted"]
    pub rx_decryptcnt: ::core::ffi::c_uint,
    #[doc = " Number of packet decryption failures during processing"]
    pub process_decrypt_fail: ::core::ffi::c_uint,
    #[doc = " Number of RX event preparation failures"]
    pub prepa_rx_event_fail: ::core::ffi::c_uint,
    #[doc = " Number of RX core pool full counts"]
    pub rx_core_pool_full_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX MPDU CRC successes"]
    pub rx_mpdu_crc_success_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX MPDU CRC failures"]
    pub rx_mpdu_crc_fail_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX OFDM CRC successes"]
    pub rx_ofdm_crc_success_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX OFDM CRC failures"]
    pub rx_ofdm_crc_fail_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX DSSS CRC successes"]
    pub rxDSSSCrcSuccessCnt: ::core::ffi::c_uint,
    #[doc = " Number of RX DSSS CRC failures"]
    pub rxDSSSCrcFailCnt: ::core::ffi::c_uint,
    #[doc = " Number of RX crypto start counts"]
    pub rx_crypto_start_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX crypto done counts"]
    pub rx_crypto_done_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX event buffer full counts"]
    pub rx_event_buf_full: ::core::ffi::c_uint,
    #[doc = " Number of RX external RAM buffer full counts"]
    pub rx_extram_buf_full: ::core::ffi::c_uint,
    #[doc = " Number of scan requests receive from UMAC"]
    pub scan_req: ::core::ffi::c_uint,
    #[doc = " Number of scan complete events sent to UMAC"]
    pub scan_complete: ::core::ffi::c_uint,
    #[doc = " Number of scan abort requests"]
    pub scan_abort_req: ::core::ffi::c_uint,
    #[doc = " Number of scan abort complete events"]
    pub scan_abort_complete: ::core::ffi::c_uint,
    #[doc = " Number of internal buffer pool null counts"]
    pub internal_buf_pool_null: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_rpu_lmac_stats() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_lmac_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_lmac_stats>(),
        140usize,
        concat!("Size of: ", stringify!(rpu_lmac_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_lmac_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_lmac_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset_cmd_cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(reset_cmd_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset_complete_event_cnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(reset_complete_event_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unable_gen_event) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(unable_gen_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ch_prog_cmd_cnt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(ch_prog_cmd_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_prog_done) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(channel_prog_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_cnt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(tx_pkt_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_done_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(tx_pkt_done_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_pkt_cnt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(scan_pkt_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_pkt_cnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(internal_pkt_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_pkt_done_cnt) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(internal_pkt_done_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ack_resp_cnt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(ack_resp_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_timeout) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(tx_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deagg_isr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(deagg_isr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deagg_inptr_desc_empty) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(deagg_inptr_desc_empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deagg_circular_buffer_full) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(deagg_circular_buffer_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_rxisr_cnt) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(lmac_rxisr_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_decryptcnt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_decryptcnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).process_decrypt_fail) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(process_decrypt_fail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepa_rx_event_fail) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(prepa_rx_event_fail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_core_pool_full_cnt) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_core_pool_full_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_mpdu_crc_success_cnt) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_mpdu_crc_success_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_mpdu_crc_fail_cnt) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_mpdu_crc_fail_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ofdm_crc_success_cnt) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_ofdm_crc_success_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ofdm_crc_fail_cnt) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_ofdm_crc_fail_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxDSSSCrcSuccessCnt) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rxDSSSCrcSuccessCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxDSSSCrcFailCnt) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rxDSSSCrcFailCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_crypto_start_cnt) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_crypto_start_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_crypto_done_cnt) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_crypto_done_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_event_buf_full) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_event_buf_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_extram_buf_full) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(rx_extram_buf_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_req) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(scan_req)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_complete) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(scan_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_abort_req) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(scan_abort_req)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_abort_complete) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(scan_abort_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_buf_pool_null) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_lmac_stats),
            "::",
            stringify!(internal_buf_pool_null)
        )
    );
}
#[doc = " @brief This structure defines the PHY (Physical Layer) debug statistics.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_phy_stats {
    #[doc = " Rssi average value received from LMAC"]
    pub rssi_avg: ::core::ffi::c_schar,
    #[doc = " Unused"]
    pub pdout_val: ::core::ffi::c_uchar,
    #[doc = " Number of OFDM CRC Pass packets"]
    pub ofdm_crc32_pass_cnt: ::core::ffi::c_uint,
    #[doc = " Number of OFDM CRC Fail packets"]
    pub ofdm_crc32_fail_cnt: ::core::ffi::c_uint,
    #[doc = " Number of DSSS CRC Pass packets"]
    pub dsss_crc32_pass_cnt: ::core::ffi::c_uint,
    #[doc = " Number of DSSS CRC Fail packets"]
    pub dsss_crc32_fail_cnt: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_rpu_phy_stats() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_phy_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_phy_stats>(),
        18usize,
        concat!("Size of: ", stringify!(rpu_phy_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_phy_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_phy_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rssi_avg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_phy_stats),
            "::",
            stringify!(rssi_avg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdout_val) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_phy_stats),
            "::",
            stringify!(pdout_val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ofdm_crc32_pass_cnt) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_phy_stats),
            "::",
            stringify!(ofdm_crc32_pass_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ofdm_crc32_fail_cnt) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_phy_stats),
            "::",
            stringify!(ofdm_crc32_fail_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsss_crc32_pass_cnt) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_phy_stats),
            "::",
            stringify!(dsss_crc32_pass_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsss_crc32_fail_cnt) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_phy_stats),
            "::",
            stringify!(dsss_crc32_fail_cnt)
        )
    );
}
#[doc = " @brief The UMAC header structure for system commands and events defines the format\n  used to transmit and receive system-level commands and events.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sys_head {
    #[doc = " Command/Event id"]
    pub cmd_event: ::core::ffi::c_uint,
    #[doc = " message length"]
    pub len: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_sys_head() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sys_head> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sys_head>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_sys_head))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sys_head>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sys_head))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_head),
            "::",
            stringify!(cmd_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_head),
            "::",
            stringify!(len)
        )
    );
}
#[repr(u32)]
#[doc = " @brief The maximum Rx (receive) A-MPDU size in KB.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum max_rx_ampdu_size {
    #[doc = " 8KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_8KB = 0,
    #[doc = " 16KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_16KB = 1,
    #[doc = " 32KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_32KB = 2,
    #[doc = " 64KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_64KB = 3,
}
#[doc = " @brief This structure specifies the configuration parameters used for configuring\n  data-related settings.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_data_config_params {
    #[doc = " rate_protection_type:0->NONE, 1->RTS/CTS, 2->CTS2SELF"]
    pub rate_protection_type: ::core::ffi::c_uchar,
    #[doc = " Aggregation is enabled(NRF_WIFI_FEATURE_ENABLE) or\n  disabled(NRF_WIFI_FEATURE_DISABLE)"]
    pub aggregation: ::core::ffi::c_uchar,
    #[doc = " WMM is enabled(NRF_WIFI_FEATURE_ENABLE) or\n  disabled(NRF_WIFI_FEATURE_DISABLE)"]
    pub wmm: ::core::ffi::c_uchar,
    #[doc = " Max number of aggregated TX sessions"]
    pub max_num_tx_agg_sessions: ::core::ffi::c_uchar,
    #[doc = " Max number of aggregated RX sessions"]
    pub max_num_rx_agg_sessions: ::core::ffi::c_uchar,
    #[doc = " maximum aggregation size"]
    pub max_tx_aggregation: ::core::ffi::c_uchar,
    #[doc = " Reorder buffer size (1 to 64)"]
    pub reorder_buf_size: ::core::ffi::c_uchar,
    #[doc = " Max RX AMPDU size (8/16/32/64 KB), see &enum max_rx_ampdu_size"]
    pub max_rxampdu_size: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_data_config_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_data_config_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_data_config_params>(),
        11usize,
        concat!("Size of: ", stringify!(nrf_wifi_data_config_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_data_config_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_data_config_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rate_protection_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(rate_protection_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aggregation) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(aggregation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wmm) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(wmm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_num_tx_agg_sessions) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(max_num_tx_agg_sessions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_num_rx_agg_sessions) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(max_num_rx_agg_sessions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tx_aggregation) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(max_tx_aggregation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reorder_buf_size) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(reorder_buf_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_rxampdu_size) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_config_params),
            "::",
            stringify!(max_rxampdu_size)
        )
    );
}
#[doc = " @brief This structure specifies the parameters that need to be provided for the command\n  NRF_WIFI_CMD_INIT. The NRF_WIFI_CMD_INIT command is typically used to initialize the\n  Wi-Fi module and prepare it for further communication.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sys_params {
    #[doc = " enable rpu sleep"]
    pub sleep_enable: ::core::ffi::c_uint,
    #[doc = " Normal/FTM mode"]
    pub hw_bringup_time: ::core::ffi::c_uint,
    #[doc = " Antenna Configuration, applicable only for 1x1"]
    pub sw_bringup_time: ::core::ffi::c_uint,
    #[doc = " Internal tuning parameter"]
    pub bcn_time_out: ::core::ffi::c_uint,
    #[doc = " Set to 1 if rpu is expected to perform sleep clock calibration"]
    pub calib_sleep_clk: ::core::ffi::c_uint,
    #[doc = " calib bit map value. More info can be found in phy_rf_params.h NRF_WIFI_DEF_PHY_CALIB"]
    pub phy_calib: ::core::ffi::c_uint,
    #[doc = " MAC address of the interface"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " An array containing RF & baseband control params"]
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " Indicates whether the rf_params has a valid value"]
    pub rf_params_valid: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_sys_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sys_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sys_params>(),
        231usize,
        concat!("Size of: ", stringify!(nrf_wifi_sys_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sys_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sys_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sleep_enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(sleep_enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_bringup_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(hw_bringup_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_bringup_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(sw_bringup_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bcn_time_out) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(bcn_time_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calib_sleep_clk) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(calib_sleep_clk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_calib) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(phy_calib)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_params) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(rf_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_params_valid) as usize - ptr as usize },
        230usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sys_params),
            "::",
            stringify!(rf_params_valid)
        )
    );
}
#[doc = " @brief This structure defines the parameters used to control the transmit (TX) power.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_pwr_ctrl_params {
    #[doc = " Antenna gain for 2.4 GHz band"]
    pub ant_gain_2g: ::core::ffi::c_uchar,
    #[doc = " Antenna gain for 5 GHz band (5150 MHz - 5350 MHz)"]
    pub ant_gain_5g_band1: ::core::ffi::c_uchar,
    #[doc = " Antenna gain for 5 GHz band (5470 MHz - 5730 MHz)"]
    pub ant_gain_5g_band2: ::core::ffi::c_uchar,
    #[doc = " Antenna gain for 5 GHz band (5730 MHz - 5895 MHz)"]
    pub ant_gain_5g_band3: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for lower edge of 2.4 GHz frequency band"]
    pub band_edge_2g_lo: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for upper edge of 2.4 GHz frequency band"]
    pub band_edge_2g_hi: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for lower edge of UNII-1 frequency band"]
    pub band_edge_5g_unii_1_lo: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for upper edge of UNII-1 frequency band"]
    pub band_edge_5g_unii_1_hi: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for lower edge of UNII-2A frequency band"]
    pub band_edge_5g_unii_2a_lo: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for upper edge of UNII-2A frequency band"]
    pub band_edge_5g_unii_2a_hi: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for lower edge of UNII-2C frequency band"]
    pub band_edge_5g_unii_2c_lo: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for upper edge of UNII-2C frequency band"]
    pub band_edge_5g_unii_2c_hi: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for lower edge of UNII-3 frequency band"]
    pub band_edge_5g_unii_3_lo: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for upper edge of UNII-3 frequency band"]
    pub band_edge_5g_unii_3_hi: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for lower edge of UNII-4 frequency band"]
    pub band_edge_5g_unii_4_lo: ::core::ffi::c_uchar,
    #[doc = " Transmit power backoff (in dB) for upper edge of UNII-4 frequency band"]
    pub band_edge_5g_unii_4_hi: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_tx_pwr_ctrl_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_tx_pwr_ctrl_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_tx_pwr_ctrl_params>(),
        16usize,
        concat!("Size of: ", stringify!(nrf_wifi_tx_pwr_ctrl_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_tx_pwr_ctrl_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_tx_pwr_ctrl_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ant_gain_2g) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(ant_gain_2g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ant_gain_5g_band1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(ant_gain_5g_band1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ant_gain_5g_band2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(ant_gain_5g_band2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ant_gain_5g_band3) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(ant_gain_5g_band3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_2g_lo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_2g_lo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_2g_hi) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_2g_hi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_1_lo) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_1_lo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_1_hi) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_1_hi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_2a_lo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_2a_lo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_2a_hi) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_2a_hi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_2c_lo) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_2c_lo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_2c_hi) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_2c_hi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_3_lo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_3_lo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_3_hi) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_3_hi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_4_lo) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_4_lo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band_edge_5g_unii_4_hi) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_pwr_ctrl_params),
            "::",
            stringify!(band_edge_5g_unii_4_hi)
        )
    );
}
#[repr(u32)]
#[doc = " @brief This enum defines different types of operating bands.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum op_band {
    #[doc = " All bands"]
    BAND_ALL = 0,
    #[doc = " 2.4Ghz band"]
    BAND_24G = 1,
}
#[doc = " @brief This structure defines the command responsible for initializing the UMAC.\n  After the host driver brings up, the host sends NRF_WIFI_CMD_INIT to the RPU.\n  The RPU then performs the initialization and responds with NRF_WIFI_EVENT_INIT_DONE\n  once the initialization is completed.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_sys_init {
    #[doc = " umac header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " id of the interface"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " @ref nrf_wifi_sys_params"]
    pub sys_params: nrf_wifi_sys_params,
    #[doc = " LMAC Rx buffs pool params, @ref rx_buf_pool_params"]
    pub rx_buf_pools: [rx_buf_pool_params; 3usize],
    #[doc = " Data configuration params, @ref nrf_wifi_data_config_params"]
    pub data_config_params: nrf_wifi_data_config_params,
    #[doc = " Calibration trigger control info based on battery voltage and temperature changes.\n  @ref temp_vbat_config from lmac_if_common.h"]
    pub temp_vbat_config_params: temp_vbat_config,
    #[doc = " 0:umac checksum disable 1: umac checksum enable"]
    pub tcp_ip_checksum_offload: ::core::ffi::c_uchar,
    #[doc = " Country code to set"]
    pub country_code: [::core::ffi::c_uchar; 2usize],
    #[doc = " Operating band see enum op_band"]
    pub op_band: ::core::ffi::c_uint,
    #[doc = " System parameters provided for controlling the TX power"]
    pub tx_pwr_ctrl_params: nrf_wifi_tx_pwr_ctrl_params,
    #[doc = " Offload mgmt buffer refill to UMAC when enabled"]
    pub mgmt_buff_offload: ::core::ffi::c_uchar,
    #[doc = " Enable features from driver config"]
    pub feature_flags: ::core::ffi::c_uint,
    #[doc = " To deactivate beamforming, By default the RPU enables the beamforming feature.\n  If a user wishes to turn it off, they should set this parameter to 1."]
    pub disable_beamforming: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_sys_init() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_sys_init> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_sys_init>(),
        334usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_sys_init))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_sys_init>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_sys_init))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(wdev_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_params) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(sys_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf_pools) as usize - ptr as usize },
        243usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(rx_buf_pools)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_config_params) as usize - ptr as usize },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(data_config_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp_vbat_config_params) as usize - ptr as usize },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(temp_vbat_config_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcp_ip_checksum_offload) as usize - ptr as usize },
        302usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(tcp_ip_checksum_offload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        303usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op_band) as usize - ptr as usize },
        305usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(op_band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pwr_ctrl_params) as usize - ptr as usize },
        309usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(tx_pwr_ctrl_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mgmt_buff_offload) as usize - ptr as usize },
        325usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(mgmt_buff_offload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feature_flags) as usize - ptr as usize },
        326usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(feature_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disable_beamforming) as usize - ptr as usize },
        330usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_init),
            "::",
            stringify!(disable_beamforming)
        )
    );
}
#[doc = " @brief This structure defines the command used to de-initialize the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_sys_deinit {
    #[doc = " umac header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_sys_deinit() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_sys_deinit> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_sys_deinit>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_sys_deinit))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_sys_deinit>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_sys_deinit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_sys_deinit),
            "::",
            stringify!(sys_head)
        )
    );
}
#[doc = " @brief This structure defines the command used to configure\n  High-Efficiency Guard Interval(HE-GI) and High-Efficiency Long Training Field (HE-LTF).\n\n  HE-GI duration determines the guard interval length used in the HE transmission.\n  HE-LTF is used for channel estimation and signal detection in HE transmissions.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_he_gi_ltf_config {
    #[doc = " umac header, see &nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " wdev interface id"]
    pub wdev_id: ::core::ffi::c_uchar,
    #[doc = " HE GI type (NRF_WIFI_HE_GI_800NS/NRF_WIFI_HE_GI_1600NS/NRF_WIFI_HE_GI_3200NS)"]
    pub he_gi_type: ::core::ffi::c_uchar,
    #[doc = " HE LTF (NRF_WIFI_HE_LTF_3200NS/NRF_WIFI_HE_LTF_6400NS/NRF_WIFI_HE_LTF_12800NS)"]
    pub he_ltf: ::core::ffi::c_uchar,
    #[doc = " Fixed HE GI & LTF values can be enabled and disabled"]
    pub enable: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_he_gi_ltf_config() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_he_gi_ltf_config> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_he_gi_ltf_config>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_he_gi_ltf_config))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_he_gi_ltf_config>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_he_gi_ltf_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_he_gi_ltf_config),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_he_gi_ltf_config),
            "::",
            stringify!(wdev_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).he_gi_type) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_he_gi_ltf_config),
            "::",
            stringify!(he_gi_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).he_ltf) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_he_gi_ltf_config),
            "::",
            stringify!(he_ltf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_he_gi_ltf_config),
            "::",
            stringify!(enable)
        )
    );
}
#[repr(u32)]
#[doc = " @brief This enum represents the different types of preambles used.\n  Preambles are sequences of known symbols transmitted before the actual\n  data transmission to enable synchronization, channel estimation, and\n  frame detection at the receiver.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_pkt_preamble {
    #[doc = " Short preamble packet"]
    RPU_PKT_PREAMBLE_SHORT = 0,
    #[doc = " Long preamble packet"]
    RPU_PKT_PREAMBLE_LONG = 1,
    #[doc = " mixed preamble packet"]
    RPU_PKT_PREAMBLE_MIXED = 2,
    #[doc = " Highest preamble type currently defined"]
    RPU_PKT_PREAMBLE_MAX = 3,
}
#[doc = " @brief This structure describes different Physical Layer (PHY) configuration parameters used\n  in RF test and Radio test scenarios. These parameters are specific to testing and evaluating\n  the performance of the radio hardware.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_conf_params {
    #[doc = " Unused. Number of spatial streams supported. Support is there for 1x1 only."]
    pub nss: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub antenna_sel: ::core::ffi::c_uchar,
    #[doc = " An array containing RF & baseband control params"]
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " Not required"]
    pub tx_pkt_chnl_bw: ::core::ffi::c_uchar,
    #[doc = " WLAN packet formats. 0->Legacy 1->HT 2->VHT 3->HE(SU) 4->HE(ERSU) and 5->HE(TB)"]
    pub tx_pkt_tput_mode: ::core::ffi::c_uchar,
    #[doc = " Short Guard enable/disable"]
    pub tx_pkt_sgi: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub tx_pkt_nss: ::core::ffi::c_uchar,
    #[doc = " Preamble type. 0->short, 1->Long and 2->Mixed"]
    pub tx_pkt_preamble: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub tx_pkt_stbc: ::core::ffi::c_uchar,
    #[doc = " 0->BCC 1->LDPC. Supporting only BCC in nRF7002"]
    pub tx_pkt_fec_coding: ::core::ffi::c_uchar,
    #[doc = " Valid MCS number between 0 to 7"]
    pub tx_pkt_mcs: ::core::ffi::c_schar,
    #[doc = " Legacy rate to be used in Mbps (1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54)"]
    pub tx_pkt_rate: ::core::ffi::c_schar,
    #[doc = " Copy OTP params to this memory"]
    pub phy_threshold: ::core::ffi::c_schar,
    #[doc = " Calibration bit map value. refer NRF_WIFI_DEF_PHY_CALIB"]
    pub phy_calib: ::core::ffi::c_uint,
    #[doc = " Radio test mode or System mode selection"]
    pub op_mode: ::core::ffi::c_int,
    #[doc = " Channel related info viz, channel, bandwidth, primary 20 offset"]
    pub chan: chan_params,
    #[doc = " Value of 0 means continuous transmission.Greater than 1 is invalid"]
    pub tx_mode: ::core::ffi::c_uchar,
    #[doc = " Number of packets to be transmitted. Any number above 0.\n  Set -1 for continuous transmission"]
    pub tx_pkt_num: ::core::ffi::c_int,
    #[doc = " Length of the packet (in bytes) to be transmitted"]
    pub tx_pkt_len: ::core::ffi::c_ushort,
    #[doc = " Desired TX power in dBm in the range 0 dBm to 21 dBm in steps of 1 dBm"]
    pub tx_power: ::core::ffi::c_uint,
    #[doc = " Transmit WLAN packet"]
    pub tx: ::core::ffi::c_uchar,
    #[doc = " Receive WLAN packet"]
    pub rx: ::core::ffi::c_uchar,
    #[doc = "  Not required"]
    pub aux_adc_input_chain_id: ::core::ffi::c_uchar,
    #[doc = "  Unused"]
    pub agg: ::core::ffi::c_uchar,
    #[doc = " Select HE LTF type viz, 0->1x, 1->2x and 2->4x"]
    pub he_ltf: ::core::ffi::c_uchar,
    #[doc = " Select HE LTF type viz, 0->0.8us, 1->1.6us and 2->3.2us"]
    pub he_gi: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub set_he_ltf_gi: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub power_save: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub rts_threshold: ::core::ffi::c_uint,
    #[doc = " Not required"]
    pub uapsd_queue: ::core::ffi::c_uint,
    #[doc = " Interval between TX packets in us (Min: 200, Max: 200000, Default: 200)"]
    pub tx_pkt_gap_us: ::core::ffi::c_uint,
    #[doc = " Configure WLAN antenna switch(0-separate/1-shared)"]
    pub wlan_ant_switch_ctrl: ::core::ffi::c_uchar,
    #[doc = " Switch to control the BLE antenna or shared WiFi antenna"]
    pub ble_ant_switch_ctrl: ::core::ffi::c_uchar,
    #[doc = " Resource unit (RU) size (26,52,106 or 242)"]
    pub ru_tone: ::core::ffi::c_uchar,
    #[doc = " Location of resource unit (RU) in 20 MHz spectrum"]
    pub ru_index: ::core::ffi::c_uchar,
    #[doc = " Desired tone frequency to be transmitted"]
    pub tx_tone_freq: ::core::ffi::c_schar,
    #[doc = " RX LNA gain"]
    pub lna_gain: ::core::ffi::c_uchar,
    #[doc = " RX BB gain"]
    pub bb_gain: ::core::ffi::c_uchar,
    #[doc = " Number of RX samples to be captured"]
    pub capture_length: ::core::ffi::c_ushort,
    #[doc = " Configure WLAN to bypass regulatory"]
    pub bypass_regulatory: ::core::ffi::c_uchar,
    #[doc = " Two letter country code (00: Default for WORLD)"]
    pub country_code: [::core::ffi::c_uchar; 2usize],
    #[doc = " Contention window value to be configured"]
    pub tx_pkt_cw: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_rpu_conf_params() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_conf_params> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_conf_params>(),
        280usize,
        concat!("Size of: ", stringify!(rpu_conf_params))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_conf_params>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_conf_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(nss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).antenna_sel) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(antenna_sel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_params) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(rf_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_chnl_bw) as usize - ptr as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_chnl_bw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_tput_mode) as usize - ptr as usize },
        203usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_tput_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_sgi) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_sgi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_nss) as usize - ptr as usize },
        205usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_nss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_preamble) as usize - ptr as usize },
        206usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_preamble)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_stbc) as usize - ptr as usize },
        207usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_stbc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_fec_coding) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_fec_coding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_mcs) as usize - ptr as usize },
        209usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_mcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_rate) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_threshold) as usize - ptr as usize },
        211usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(phy_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_calib) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(phy_calib)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op_mode) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(op_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chan) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(chan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_mode) as usize - ptr as usize },
        233usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_num) as usize - ptr as usize },
        234usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_len) as usize - ptr as usize },
        238usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        245usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aux_adc_input_chain_id) as usize - ptr as usize },
        246usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(aux_adc_input_chain_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).agg) as usize - ptr as usize },
        247usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(agg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).he_ltf) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(he_ltf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).he_gi) as usize - ptr as usize },
        249usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(he_gi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_he_ltf_gi) as usize - ptr as usize },
        250usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(set_he_ltf_gi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).power_save) as usize - ptr as usize },
        251usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(power_save)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rts_threshold) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(rts_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uapsd_queue) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(uapsd_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_gap_us) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_gap_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wlan_ant_switch_ctrl) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(wlan_ant_switch_ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ble_ant_switch_ctrl) as usize - ptr as usize },
        265usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(ble_ant_switch_ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ru_tone) as usize - ptr as usize },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(ru_tone)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ru_index) as usize - ptr as usize },
        267usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(ru_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_tone_freq) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_tone_freq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lna_gain) as usize - ptr as usize },
        269usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(lna_gain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bb_gain) as usize - ptr as usize },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(bb_gain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capture_length) as usize - ptr as usize },
        271usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(capture_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bypass_regulatory) as usize - ptr as usize },
        273usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(bypass_regulatory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        274usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_pkt_cw) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_conf_params),
            "::",
            stringify!(tx_pkt_cw)
        )
    );
}
#[doc = " @brief This structure defines the command used to configure the RPU with different\n  PHY configuration parameters specifically designed for RF test and Radio test scenarios.\n  The command is intended to set up the RPU for testing and evaluating the performance\n  of the radio hardware.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_mode_params {
    #[doc = " UMAC header, See &struct nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " configuration parameters of different modes see &union rpu_conf_params"]
    pub conf: rpu_conf_params,
    #[doc = " Packet length"]
    pub pkt_length: [::core::ffi::c_ushort; 16usize],
    #[doc = " Packet ddr pointer"]
    pub ddr_ptrs: [::core::ffi::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_mode_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_mode_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_mode_params>(),
        384usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_mode_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_mode_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_mode_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_mode_params),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_mode_params),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkt_length) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_mode_params),
            "::",
            stringify!(pkt_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ddr_ptrs) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_mode_params),
            "::",
            stringify!(ddr_ptrs)
        )
    );
}
#[doc = " @brief This structure represents the parameters required to initialize a radio test.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_radio_test_init_info {
    #[doc = " An array containing RF & baseband control params"]
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " Channel related info viz, channel, bandwidth, primary 20 offset"]
    pub chan: chan_params,
    #[doc = " Phy threshold value to be sent to LMAC in channel programming"]
    pub phy_threshold: ::core::ffi::c_schar,
    #[doc = " Calibration bit map value. refer phy_rf_params.h NRF_WIFI_DEF_PHY_CALIB"]
    pub phy_calib: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_radio_test_init_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_radio_test_init_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_radio_test_init_info>(),
        218usize,
        concat!("Size of: ", stringify!(nrf_wifi_radio_test_init_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_radio_test_init_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_radio_test_init_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_radio_test_init_info),
            "::",
            stringify!(rf_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chan) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_radio_test_init_info),
            "::",
            stringify!(chan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_threshold) as usize - ptr as usize },
        213usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_radio_test_init_info),
            "::",
            stringify!(phy_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_calib) as usize - ptr as usize },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_radio_test_init_info),
            "::",
            stringify!(phy_calib)
        )
    );
}
#[doc = " @brief This structure defines the command used to initialize a radio test.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_radio_test_init {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " radiotest init configuration parameters @ref nrf_wifi_radio_test_init_info"]
    pub conf: nrf_wifi_radio_test_init_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_radio_test_init() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_radio_test_init> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_radio_test_init>(),
        226usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_radio_test_init))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_radio_test_init>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_radio_test_init))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_radio_test_init),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_radio_test_init),
            "::",
            stringify!(conf)
        )
    );
}
#[doc = " @brief This structure defines the command used to enable or disable the reception (Rx).\n  It allows controlling the radio hardware's receive functionality to start or stop listening\n  for incoming data frames."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_rx {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " rx configuration parameters @ref rpu_conf_rx_radio_test_params"]
    pub conf: rpu_conf_rx_radio_test_params,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_rx() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_rx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_rx>(),
        228usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_rx))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_rx>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_rx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_rx),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_rx),
            "::",
            stringify!(conf)
        )
    );
}
#[doc = " @brief This structure defines the command used to retrieve statistics from the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Statistics type &enum rpu_stats_type"]
    pub stats_type: ::core::ffi::c_int,
    #[doc = " Production mode or FCM mode"]
    pub op_mode: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_get_stats() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_get_stats> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_get_stats>(),
        16usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_get_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_get_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_get_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_get_stats),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stats_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_get_stats),
            "::",
            stringify!(stats_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op_mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_get_stats),
            "::",
            stringify!(op_mode)
        )
    );
}
#[doc = " @brief This structure defines the command used to clear or reset statistics.\n\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_clear_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Type of statistics to clear &enum rpu_stats_type"]
    pub stats_type: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_clear_stats() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_clear_stats> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_clear_stats>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_clear_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_clear_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_clear_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_clear_stats),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stats_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_clear_stats),
            "::",
            stringify!(stats_type)
        )
    );
}
#[doc = " @brief This structure represents the command used to obtain power monitor information\n  specific to different data types.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_pwr {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Type of Control info that host need"]
    pub data_type: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_pwr() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_pwr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_pwr>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_pwr))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_pwr>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_pwr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_pwr),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_pwr),
            "::",
            stringify!(data_type)
        )
    );
}
#[doc = " @brief Structure for coexistence (coex) switch configuration.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct coex_wlan_switch_ctrl {
    #[doc = " Host to coexistence manager message id"]
    pub rpu_msg_id: ::core::ffi::c_int,
    #[doc = " Switch configuration value"]
    pub switch_A: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_coex_wlan_switch_ctrl() {
    const UNINIT: ::core::mem::MaybeUninit<coex_wlan_switch_ctrl> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<coex_wlan_switch_ctrl>(),
        8usize,
        concat!("Size of: ", stringify!(coex_wlan_switch_ctrl))
    );
    assert_eq!(
        ::core::mem::align_of::<coex_wlan_switch_ctrl>(),
        1usize,
        concat!("Alignment of ", stringify!(coex_wlan_switch_ctrl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rpu_msg_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coex_wlan_switch_ctrl),
            "::",
            stringify!(rpu_msg_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).switch_A) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(coex_wlan_switch_ctrl),
            "::",
            stringify!(switch_A)
        )
    );
}
#[doc = " @brief The structure represents the command used to configure the Wi-Fi side shared switch\n  for Bluetooth coexistence (btcoex).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_btcoex {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Switch configuration data"]
    pub conf: coex_wlan_switch_ctrl,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_btcoex() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_btcoex> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_btcoex>(),
        16usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_btcoex))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_btcoex>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_btcoex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_btcoex),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_btcoex),
            "::",
            stringify!(conf)
        )
    );
}
#[doc = " @brief The structure defines the parameters used to configure the coexistence hardware.\n"]
#[repr(C, packed)]
pub struct rpu_cmd_coex_config_info {
    #[doc = " Length of coexistence configuration data"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Coexistence configuration data"]
    pub coex_cmd: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_rpu_cmd_coex_config_info() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_cmd_coex_config_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_cmd_coex_config_info>(),
        4usize,
        concat!("Size of: ", stringify!(rpu_cmd_coex_config_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_cmd_coex_config_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_cmd_coex_config_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_cmd_coex_config_info),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_cmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_cmd_coex_config_info),
            "::",
            stringify!(coex_cmd)
        )
    );
}
#[doc = " @brief This structure defines the command used to configure the coexistence hardware.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_cmd_coex_config {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Coexistence configuration data. @ref rpu_cmd_coex_config_info"]
    pub coex_config_info: rpu_cmd_coex_config_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_coex_config() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_coex_config> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_coex_config>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_coex_config))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_coex_config>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_coex_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_coex_config),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_config_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_coex_config),
            "::",
            stringify!(coex_config_info)
        )
    );
}
#[doc = " @brief This structure describes the coexistence configuration data received\n  in the NRF_WIFI_EVENT_COEX_CONFIG event.\n"]
#[repr(C, packed)]
pub struct rpu_evnt_coex_config_info {
    #[doc = " Length of coexistence configuration data"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Coexistence configuration data"]
    pub coex_event: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_rpu_evnt_coex_config_info() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_evnt_coex_config_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_evnt_coex_config_info>(),
        4usize,
        concat!("Size of: ", stringify!(rpu_evnt_coex_config_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_evnt_coex_config_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_evnt_coex_config_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_evnt_coex_config_info),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_evnt_coex_config_info),
            "::",
            stringify!(coex_event)
        )
    );
}
#[doc = " @brief This structure defines the event used to represent coexistence configuration.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_event_coex_config {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Coexistence configuration data in the event. @ref rpu_evnt_coex_config_info"]
    pub coex_config_info: rpu_evnt_coex_config_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_coex_config() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_coex_config> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_coex_config>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_coex_config))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_coex_config>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_coex_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_coex_config),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_config_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_coex_config),
            "::",
            stringify!(coex_config_info)
        )
    );
}
#[doc = " @brief This structure defines the command used to fix the transmission (Tx) data rate.\n  The command allows setting a specific data rate for data transmission, ensuring that the\n  system uses the designated rate instead of dynamically adapting to changing channel conditions.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_fix_tx_rate {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " refer see &enum rpu_tput_mode"]
    pub rate_flags: ::core::ffi::c_uchar,
    #[doc = " fixed_rate: -1 Disable fixed rate and use ratecontrol selected rate\n  fixed rate: >0 legacy rates: 1,2,55,11,6,9,12,18,24,36,48,54\n\t\t  11N VHT HE  : MCS index 0 to 7."]
    pub fixed_rate: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_fix_tx_rate() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_fix_tx_rate> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_fix_tx_rate>(),
        13usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_fix_tx_rate))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_fix_tx_rate>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_fix_tx_rate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_fix_tx_rate),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rate_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_fix_tx_rate),
            "::",
            stringify!(rate_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fixed_rate) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_fix_tx_rate),
            "::",
            stringify!(fixed_rate)
        )
    );
}
#[doc = " @brief This structure describes rf test command information.\n"]
#[repr(C, packed)]
pub struct rpu_cmd_rftest_info {
    #[doc = " length of the rf test command"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Rf test command data"]
    pub rfcmd: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_rpu_cmd_rftest_info() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_cmd_rftest_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_cmd_rftest_info>(),
        4usize,
        concat!("Size of: ", stringify!(rpu_cmd_rftest_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_cmd_rftest_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_cmd_rftest_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_cmd_rftest_info),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rfcmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_cmd_rftest_info),
            "::",
            stringify!(rfcmd)
        )
    );
}
#[doc = " @brief This structure defines the command used for RF (Radio Frequency) testing.\n  RF test commands are specifically designed to configure and control the radio hardware\n  for conducting tests and evaluating its performance in various scenarios.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_cmd_rftest {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " @ref rpu_cmd_rftest_info"]
    pub rf_test_info: rpu_cmd_rftest_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_rftest() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_rftest> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_rftest>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_rftest))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_rftest>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_rftest))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_rftest),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_test_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_rftest),
            "::",
            stringify!(rf_test_info)
        )
    );
}
#[doc = " @brief This structure describes rf test event information.\n"]
#[repr(C, packed)]
pub struct rpu_evnt_rftest_info {
    #[doc = " length of the rf test event"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Rf test event data"]
    pub rfevent: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_rpu_evnt_rftest_info() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_evnt_rftest_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_evnt_rftest_info>(),
        4usize,
        concat!("Size of: ", stringify!(rpu_evnt_rftest_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_evnt_rftest_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_evnt_rftest_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_evnt_rftest_info),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rfevent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_evnt_rftest_info),
            "::",
            stringify!(rfevent)
        )
    );
}
#[doc = " @brief This structure describes the event generated during RF (Radio Frequency) testing.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_event_rftest {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " @ref rpu_evnt_rftest_info"]
    pub rf_test_info: rpu_evnt_rftest_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_rftest() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_rftest> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_rftest>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_rftest))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_rftest>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_rftest))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_rftest),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_test_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_rftest),
            "::",
            stringify!(rf_test_info)
        )
    );
}
#[doc = " @brief This structure represents the power data event generated in response to\n  the NRF_WIFI_CMD_PWR command.\n\n  The NRF_WIFI_CMD_PWR command is used to retrieve power-related data or measurements\n  from the radio hardware.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_pwr_data {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Power monitor command status info"]
    pub mon_status: ::core::ffi::c_int,
    #[doc = " Data"]
    pub data_type: ::core::ffi::c_int,
    #[doc = " Data that host may want to read from Power IP"]
    pub data: nrf_wifi_rpu_pwr_data,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_pwr_data() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_pwr_data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_pwr_data>(),
        28usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_pwr_data))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_pwr_data>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_pwr_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_pwr_data),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_pwr_data),
            "::",
            stringify!(mon_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_pwr_data),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_pwr_data),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @brief This structure is a comprehensive combination of all the firmware statistics\n  that the RPU (Radio Processing Unit) can provide.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_fw_stats {
    #[doc = " PHY statistics  @ref rpu_phy_stats"]
    pub phy: rpu_phy_stats,
    #[doc = " LMAC statistics @ref rpu_lmac_stats"]
    pub lmac: rpu_lmac_stats,
    #[doc = " UMAC statistics @ref rpu_umac_stats"]
    pub umac: rpu_umac_stats,
}
#[test]
fn bindgen_test_layout_rpu_fw_stats() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_fw_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_fw_stats>(),
        639usize,
        concat!("Size of: ", stringify!(rpu_fw_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_fw_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(rpu_fw_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_fw_stats),
            "::",
            stringify!(phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_fw_stats),
            "::",
            stringify!(lmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac) as usize - ptr as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_fw_stats),
            "::",
            stringify!(umac)
        )
    );
}
#[doc = " @brief This structure represents the event that provides RPU statistics in response\n  to the command NRF_WIFI_CMD_GET_STATS in a wireless communication system.\n\n  The NRF_WIFI_CMD_GET_STATS command is used to request various statistics from the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " All the statistics that the firmware can provide @ref rpu_fw_stats"]
    pub fw: rpu_fw_stats,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_stats() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_stats> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_stats>(),
        647usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_stats),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_stats),
            "::",
            stringify!(fw)
        )
    );
}
#[repr(u32)]
#[doc = " @brief This enum defines various error status values that may occur during a radio test.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_radio_test_err_status {
    #[doc = " Command success"]
    NRF_WIFI_UMAC_CMD_SUCCESS = 1,
    #[doc = " Invalid channel error"]
    NRF_WIFI_UMAC_INVALID_CHNL = 2,
}
#[doc = " @brief This structure defines an event that indicates the error status values that may occur\n  during a radio test. It serves as a response to the radio test commands.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_err_status {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " status of the command, Fail/success &enum nrf_wifi_radio_test_err_status"]
    pub status: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_err_status() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_err_status> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_err_status>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_err_status))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_err_status>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_err_status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_err_status),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_err_status),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief This structure represents the UMAC initialization done event.\n  The event is sent by the RPU (Radio Processing Unit) in response to\n  the NRF_WIFI_CMD_INIT command, indicating that the RPU initialization\n  process has been completed successfully."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_init_done {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_init_done() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_init_done> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_init_done>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_init_done))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_init_done>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_init_done))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_init_done),
            "::",
            stringify!(sys_head)
        )
    );
}
#[doc = " @brief structure for UMAC memory pool information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pool_data_to_host {
    #[doc = " Size of the memory buffer"]
    pub buffer_size: ::core::ffi::c_uint,
    #[doc = " Number of pool items available for the above memory buffer"]
    pub num_pool_items: ::core::ffi::c_uchar,
    #[doc = " Maximum pools allocated at any point of time"]
    pub items_num_max_allocated: ::core::ffi::c_uchar,
    #[doc = " Currently allocated pools"]
    pub items_num_cur_allocated: ::core::ffi::c_uchar,
    #[doc = " Total number of pool allocated"]
    pub items_num_total_allocated: ::core::ffi::c_uint,
    #[doc = " Number of times this memory pool is full"]
    pub items_num_not_allocated: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_pool_data_to_host() {
    const UNINIT: ::core::mem::MaybeUninit<pool_data_to_host> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pool_data_to_host>(),
        15usize,
        concat!("Size of: ", stringify!(pool_data_to_host))
    );
    assert_eq!(
        ::core::mem::align_of::<pool_data_to_host>(),
        1usize,
        concat!("Alignment of ", stringify!(pool_data_to_host))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_data_to_host),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_pool_items) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_data_to_host),
            "::",
            stringify!(num_pool_items)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items_num_max_allocated) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_data_to_host),
            "::",
            stringify!(items_num_max_allocated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items_num_cur_allocated) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_data_to_host),
            "::",
            stringify!(items_num_cur_allocated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items_num_total_allocated) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_data_to_host),
            "::",
            stringify!(items_num_total_allocated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items_num_not_allocated) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_data_to_host),
            "::",
            stringify!(items_num_not_allocated)
        )
    );
}
#[doc = " @brief This structure represents the event that provides UMAC (Upper MAC) internal\n  memory statistics in response to the NRF_WIFI_CMD_UMAC_INT_STATS command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_int_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " See @ref pool_data_to_host"]
    pub scratch_dynamic_memory_info: [pool_data_to_host; 56usize],
    #[doc = " See @ref pool_data_to_host"]
    pub retention_dynamic_memory_info: [pool_data_to_host; 56usize],
}
#[test]
fn bindgen_test_layout_umac_int_stats() {
    const UNINIT: ::core::mem::MaybeUninit<umac_int_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<umac_int_stats>(),
        1688usize,
        concat!("Size of: ", stringify!(umac_int_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<umac_int_stats>(),
        1usize,
        concat!("Alignment of ", stringify!(umac_int_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_int_stats),
            "::",
            stringify!(sys_head)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).scratch_dynamic_memory_info) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_int_stats),
            "::",
            stringify!(scratch_dynamic_memory_info)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).retention_dynamic_memory_info) as usize - ptr as usize
        },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_int_stats),
            "::",
            stringify!(retention_dynamic_memory_info)
        )
    );
}
#[doc = " @brief This structure represents the event that indicates the completion of UMAC\n  deinitialization. The RPU sends this event as a response to the NRF_WIFI_CMD_DEINIT\n  command, signaling that the UMAC has been successfully deinitialized."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_deinit_done {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_deinit_done() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_deinit_done> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_deinit_done>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_deinit_done))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_deinit_done>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_deinit_done))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_deinit_done),
            "::",
            stringify!(sys_head)
        )
    );
}
#[repr(u32)]
#[doc = " @brief UMAC data interface commands and events.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_umac_data_commands {
    #[doc = " Unused."]
    NRF_WIFI_CMD_MGMT_BUFF_CONFIG = 0,
    #[doc = " Transmit data packet @ref nrf_wifi_tx_buff"]
    NRF_WIFI_CMD_TX_BUFF = 1,
    #[doc = " TX done event @ref nrf_wifi_tx_buff_done"]
    NRF_WIFI_CMD_TX_BUFF_DONE = 2,
    #[doc = " RX packet event @ref nrf_wifi_rx_buff"]
    NRF_WIFI_CMD_RX_BUFF = 3,
    #[doc = " Event to indicate interface is operational\n  @ref nrf_wifi_data_carrier_state"]
    NRF_WIFI_CMD_CARRIER_ON = 4,
    #[doc = " Event to indicate interface is non-operational\n  @ref nrf_wifi_data_carrier_state"]
    NRF_WIFI_CMD_CARRIER_OFF = 5,
    #[doc = " Event to indicate softap client's power save mode\n  If client is in power save mode, host should start buffering\n  packets until it receives NRF_WIFI_CMD_PS_GET_FRAMES event."]
    NRF_WIFI_CMD_PM_MODE = 6,
    #[doc = " Event to indicate to start sending buffered packets for\n  softap client @ref nrf_wifi_sap_ps_get_frames."]
    NRF_WIFI_CMD_PS_GET_FRAMES = 7,
}
#[doc = " @brief Data interface Command and Event header.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_head {
    #[doc = " Command or Event id see &enum nrf_wifi_umac_data_commands"]
    pub cmd: ::core::ffi::c_uint,
    #[doc = " length"]
    pub len: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_head() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_head> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_head>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_head))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_head>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_head))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_head),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_head),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " @brief Tx mac80211 header information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tx_mac_hdr_info {
    #[doc = " Unused"]
    pub umac_fill_flags: ::core::ffi::c_int,
    #[doc = " frame control"]
    pub fc: ::core::ffi::c_ushort,
    #[doc = " source Mac header"]
    pub dest: [::core::ffi::c_uchar; 6usize],
    #[doc = " destination Mac address"]
    pub src: [::core::ffi::c_uchar; 6usize],
    #[doc = " Ethernet type"]
    pub etype: ::core::ffi::c_ushort,
    #[doc = " Type of Service"]
    pub dscp_or_tos: ::core::ffi::c_uint,
    #[doc = " more frames queued"]
    pub more_data: ::core::ffi::c_uchar,
    #[doc = " End Of Service Period flag(applicable in U-APSD)"]
    pub eosp: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_tx_mac_hdr_info() {
    const UNINIT: ::core::mem::MaybeUninit<tx_mac_hdr_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tx_mac_hdr_info>(),
        26usize,
        concat!("Size of: ", stringify!(tx_mac_hdr_info))
    );
    assert_eq!(
        ::core::mem::align_of::<tx_mac_hdr_info>(),
        1usize,
        concat!("Alignment of ", stringify!(tx_mac_hdr_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_fill_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(umac_fill_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).etype) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(etype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dscp_or_tos) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(dscp_or_tos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).more_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(more_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eosp) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(tx_mac_hdr_info),
            "::",
            stringify!(eosp)
        )
    );
}
#[doc = " @brief This structure provides the information of each packet in the tx command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_buff_info {
    #[doc = " Tx packet length"]
    pub pkt_length: ::core::ffi::c_ushort,
    #[doc = " Tx packet address"]
    pub ddr_ptr: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_tx_buff_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_tx_buff_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_tx_buff_info>(),
        6usize,
        concat!("Size of: ", stringify!(nrf_wifi_tx_buff_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_tx_buff_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_tx_buff_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkt_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_info),
            "::",
            stringify!(pkt_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ddr_ptr) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_info),
            "::",
            stringify!(ddr_ptr)
        )
    );
}
#[doc = " @brief This structure provides the parameters for the tx command.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_tx_buff {
    #[doc = " Command header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uchar,
    #[doc = " Descriptor id"]
    pub tx_desc_num: ::core::ffi::c_uchar,
    #[doc = " Common mac header for all packets in this command\n  @ref tx_mac_hdr_info"]
    pub mac_hdr_info: tx_mac_hdr_info,
    #[doc = " Pending buffer size at host to encode queue size\n  in qos control field of mac header in TWT enable case"]
    pub pending_buf_size: ::core::ffi::c_uint,
    #[doc = " Number of packets sending in this command"]
    pub num_tx_pkts: ::core::ffi::c_uchar,
    #[doc = " Each packets information @ref nrf_wifi_tx_buff_info"]
    pub tx_buff_info: __IncompleteArrayField<nrf_wifi_tx_buff_info>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_tx_buff() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_tx_buff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_tx_buff>(),
        41usize,
        concat!("Size of: ", stringify!(nrf_wifi_tx_buff))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_tx_buff>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_tx_buff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff),
            "::",
            stringify!(umac_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff),
            "::",
            stringify!(wdev_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_desc_num) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff),
            "::",
            stringify!(tx_desc_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_hdr_info) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff),
            "::",
            stringify!(mac_hdr_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending_buf_size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff),
            "::",
            stringify!(pending_buf_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_tx_pkts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff),
            "::",
            stringify!(num_tx_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_buff_info) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff),
            "::",
            stringify!(tx_buff_info)
        )
    );
}
#[doc = " @brief This structure represents the Tx done event(NRF_WIFI_CMD_TX_BUFF_DONE).\n"]
#[repr(C, packed)]
pub struct nrf_wifi_tx_buff_done {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Descriptor id"]
    pub tx_desc_num: ::core::ffi::c_uchar,
    #[doc = " Number of packets in this Tx done event"]
    pub num_tx_status_code: ::core::ffi::c_uchar,
    #[doc = " Frame sent time at Phy"]
    pub timestamp_t1: [::core::ffi::c_uchar; 6usize],
    #[doc = " Frame ack received time at Phy"]
    pub timestamp_t4: [::core::ffi::c_uchar; 6usize],
    #[doc = " Status of Tx packet. Maximum of MAX_TX_AGG_SIZE"]
    pub tx_status_code: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_tx_buff_done() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_tx_buff_done> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_tx_buff_done>(),
        22usize,
        concat!("Size of: ", stringify!(nrf_wifi_tx_buff_done))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_tx_buff_done>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_tx_buff_done))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_done),
            "::",
            stringify!(umac_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_desc_num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_done),
            "::",
            stringify!(tx_desc_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_tx_status_code) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_done),
            "::",
            stringify!(num_tx_status_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp_t1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_done),
            "::",
            stringify!(timestamp_t1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp_t4) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_done),
            "::",
            stringify!(timestamp_t4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_status_code) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_buff_done),
            "::",
            stringify!(tx_status_code)
        )
    );
}
#[repr(u32)]
#[doc = " @brief This structure defines the type of received packet.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_rx_pkt_type {
    #[doc = " The Rx packet is of type data"]
    NRF_WIFI_RX_PKT_DATA = 0,
    #[doc = " RX packet is beacon or probe response"]
    NRF_WIFI_RX_PKT_BCN_PRB_RSP = 1,
}
#[doc = " @brief This structure provides information about the parameters in the RX data event.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_rx_buff_info {
    #[doc = " Descriptor id"]
    pub descriptor_id: ::core::ffi::c_ushort,
    #[doc = " Rx packet length"]
    pub rx_pkt_len: ::core::ffi::c_ushort,
    #[doc = " type PKT_TYPE_MPDU/PKT_TYPE_MSDU_WITH_MAC/PKT_TYPE_MSDU"]
    pub pkt_type: ::core::ffi::c_uchar,
    #[doc = " Frame received time at Phy"]
    pub timestamp_t2: [::core::ffi::c_uchar; 6usize],
    #[doc = " Ack sent time at Phy"]
    pub timestamp_t3: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_rx_buff_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_rx_buff_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_rx_buff_info>(),
        17usize,
        concat!("Size of: ", stringify!(nrf_wifi_rx_buff_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_rx_buff_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_rx_buff_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descriptor_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff_info),
            "::",
            stringify!(descriptor_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_pkt_len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff_info),
            "::",
            stringify!(rx_pkt_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkt_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff_info),
            "::",
            stringify!(pkt_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp_t2) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff_info),
            "::",
            stringify!(timestamp_t2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp_t3) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff_info),
            "::",
            stringify!(timestamp_t3)
        )
    );
}
#[doc = " @brief This structure represents RX data event(NRF_WIFI_CMD_RX_BUFF).\n"]
#[repr(C, packed)]
pub struct nrf_wifi_rx_buff {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Rx packet type. see &enum nrf_wifi_rx_pkt_type"]
    pub rx_pkt_type: ::core::ffi::c_int,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uchar,
    #[doc = " Number of packets in this event"]
    pub rx_pkt_cnt: ::core::ffi::c_uchar,
    #[doc = " Depricated"]
    pub reserved: ::core::ffi::c_uchar,
    #[doc = " MAC header length. Same for all packets in this event"]
    pub mac_header_len: ::core::ffi::c_uchar,
    #[doc = " Frequency on which this packet received"]
    pub frequency: ::core::ffi::c_ushort,
    #[doc = " signal strength"]
    pub signal: ::core::ffi::c_short,
    #[doc = " Information of each packet. @ref nrf_wifi_rx_buff_info"]
    pub rx_buff_info: __IncompleteArrayField<nrf_wifi_rx_buff_info>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_rx_buff() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_rx_buff> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_rx_buff>(),
        20usize,
        concat!("Size of: ", stringify!(nrf_wifi_rx_buff))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_rx_buff>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_rx_buff))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(umac_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_pkt_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(rx_pkt_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(wdev_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_pkt_cnt) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(rx_pkt_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_header_len) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(mac_header_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buff_info) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rx_buff),
            "::",
            stringify!(rx_buff_info)
        )
    );
}
#[doc = " @brief This structure provides information about the carrier (interface) state.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_data_carrier_state {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_data_carrier_state() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_data_carrier_state> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_data_carrier_state>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_data_carrier_state))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_data_carrier_state>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_data_carrier_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_carrier_state),
            "::",
            stringify!(umac_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_data_carrier_state),
            "::",
            stringify!(wdev_id)
        )
    );
}
#[doc = " @brief This structure describes an event related to the power save state of the softap's client.\n  When the client is in PS mode (NRF_WIFI_CLIENT_PS_MODE), the host should queue Tx packets.\n  When the client is in wakeup mode (NRF_WIFI_CLIENT_ACTIVE), the host should send all\n  buffered and upcoming Tx packets.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sap_client_pwrsave {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " state NRF_WIFI_CLIENT_ACTIVE or NRF_WIFI_CLIENT_PS_MODE"]
    pub sta_ps_state: ::core::ffi::c_uchar,
    #[doc = " STA MAC Address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_sap_client_pwrsave() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sap_client_pwrsave> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sap_client_pwrsave>(),
        19usize,
        concat!("Size of: ", stringify!(nrf_wifi_sap_client_pwrsave))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sap_client_pwrsave>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sap_client_pwrsave))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_client_pwrsave),
            "::",
            stringify!(umac_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_client_pwrsave),
            "::",
            stringify!(wdev_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_ps_state) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_client_pwrsave),
            "::",
            stringify!(sta_ps_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_client_pwrsave),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure represents an event that instructs the host to transmit a specific\n  number of frames that host queued when softap's client is in power save mode.\n  This event is primarily used when Softap's client operates in legacy power save mode.\n  In this scenario, the access point (AP) is required to send a single packet for every PS POLL\n  frame it receives from the client. Additionally, this mechanism will also be utilized in\n  UAPSD power save.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sap_ps_get_frames {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " STA MAC Address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Number of frames to be transmitted in this service period"]
    pub num_frames: ::core::ffi::c_schar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_sap_ps_get_frames() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sap_ps_get_frames> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sap_ps_get_frames>(),
        19usize,
        concat!("Size of: ", stringify!(nrf_wifi_sap_ps_get_frames))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sap_ps_get_frames>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sap_ps_get_frames))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_ps_get_frames),
            "::",
            stringify!(umac_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_ps_get_frames),
            "::",
            stringify!(wdev_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_ps_get_frames),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_frames) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sap_ps_get_frames),
            "::",
            stringify!(num_frames)
        )
    );
}
#[repr(u32)]
#[doc = " @brief The host can send the following commands to the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_umac_commands {
    #[doc = " Trigger a new scan @ref nrf_wifi_umac_cmd_scan"]
    NRF_WIFI_UMAC_CMD_TRIGGER_SCAN = 0,
    #[doc = " Request for scan results @ref nrf_wifi_umac_cmd_get_scan_results"]
    NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS = 1,
    #[doc = " Send authentication request to AP @ref nrf_wifi_umac_cmd_auth"]
    NRF_WIFI_UMAC_CMD_AUTHENTICATE = 2,
    #[doc = " Send associate request to AP @ref nrf_wifi_umac_cmd_assoc"]
    NRF_WIFI_UMAC_CMD_ASSOCIATE = 3,
    #[doc = " Send deauthentication request to AP @ref nrf_wifi_umac_cmd_disconn"]
    NRF_WIFI_UMAC_CMD_DEAUTHENTICATE = 4,
    #[doc = " Set wiphy parameters @ref nrf_wifi_umac_cmd_set_wiphy"]
    NRF_WIFI_UMAC_CMD_SET_WIPHY = 5,
    #[doc = " Add new key @ref nrf_wifi_umac_cmd_key"]
    NRF_WIFI_UMAC_CMD_NEW_KEY = 6,
    #[doc = " Delete key @ref nrf_wifi_umac_cmd_key"]
    NRF_WIFI_UMAC_CMD_DEL_KEY = 7,
    #[doc = " Set default key to use @ref nrf_wifi_umac_cmd_set_key"]
    NRF_WIFI_UMAC_CMD_SET_KEY = 8,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_GET_KEY = 9,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_NEW_BEACON = 10,
    #[doc = " Change the beacon on an AP interface @ref nrf_wifi_umac_cmd_set_beacon"]
    NRF_WIFI_UMAC_CMD_SET_BEACON = 11,
    #[doc = " Set the BSS @ref nrf_wifi_umac_cmd_set_bss"]
    NRF_WIFI_UMAC_CMD_SET_BSS = 12,
    #[doc = " Start soft AP operation on an AP interface @ref nrf_wifi_umac_cmd_start_ap"]
    NRF_WIFI_UMAC_CMD_START_AP = 13,
    #[doc = " Stop soft AP operation @ref nrf_wifi_umac_cmd_stop_ap"]
    NRF_WIFI_UMAC_CMD_STOP_AP = 14,
    #[doc = " Create new interface @ref nrf_wifi_umac_cmd_add_vif"]
    NRF_WIFI_UMAC_CMD_NEW_INTERFACE = 15,
    #[doc = " Change interface configuration @ref nrf_wifi_umac_cmd_chg_vif_attr"]
    NRF_WIFI_UMAC_CMD_SET_INTERFACE = 16,
    #[doc = " Delete interface @ref nrf_wifi_umac_cmd_del_vif"]
    NRF_WIFI_UMAC_CMD_DEL_INTERFACE = 17,
    #[doc = " Change interface flags @ref nrf_wifi_umac_cmd_chg_vif_state"]
    NRF_WIFI_UMAC_CMD_SET_IFFLAGS = 18,
    #[doc = " Add a new station @ref nrf_wifi_umac_cmd_add_sta"]
    NRF_WIFI_UMAC_CMD_NEW_STATION = 19,
    #[doc = " Delete station @ref nrf_wifi_umac_cmd_del_sta"]
    NRF_WIFI_UMAC_CMD_DEL_STATION = 20,
    #[doc = " Change station info @ref nrf_wifi_umac_cmd_chg_sta"]
    NRF_WIFI_UMAC_CMD_SET_STATION = 21,
    #[doc = " Get station info @ref nrf_wifi_umac_cmd_get_sta"]
    NRF_WIFI_UMAC_CMD_GET_STATION = 22,
    #[doc = " Start the P2P device @ref nrf_wifi_cmd_start_p2p"]
    NRF_WIFI_UMAC_CMD_START_P2P_DEVICE = 23,
    #[doc = " Stop the P2P device @ref nrf_wifi_umac_cmd_stop_p2p_dev"]
    NRF_WIFI_UMAC_CMD_STOP_P2P_DEVICE = 24,
    #[doc = " Remain awake on the specified channel @ref nrf_wifi_umac_cmd_remain_on_channel"]
    NRF_WIFI_UMAC_CMD_REMAIN_ON_CHANNEL = 25,
    #[doc = " Cancel a pending ROC duration @ref nrf_wifi_umac_cmd_cancel_remain_on_channel"]
    NRF_WIFI_UMAC_CMD_CANCEL_REMAIN_ON_CHANNEL = 26,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SET_CHANNEL = 27,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_RADAR_DETECT = 28,
    #[doc = " Whitelist filter based on frame types @ref nrf_wifi_umac_cmd_mgmt_frame_reg"]
    NRF_WIFI_UMAC_CMD_REGISTER_FRAME = 29,
    #[doc = " Send a management frame @ref nrf_wifi_umac_cmd_mgmt_tx"]
    NRF_WIFI_UMAC_CMD_FRAME = 30,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_JOIN_IBSS = 31,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_WIN_STA_CONNECT = 32,
    #[doc = " Power save Enable/Disable @ref nrf_wifi_umac_cmd_set_power_save"]
    NRF_WIFI_UMAC_CMD_SET_POWER_SAVE = 33,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SET_WOWLAN = 34,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SUSPEND = 35,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_RESUME = 36,
    #[doc = " QOS map @ref nrf_wifi_umac_cmd_set_qos_map"]
    NRF_WIFI_UMAC_CMD_SET_QOS_MAP = 37,
    #[doc = " Get Channel info @ref nrf_wifi_umac_cmd_get_channel"]
    NRF_WIFI_UMAC_CMD_GET_CHANNEL = 38,
    #[doc = " Get Tx power level @ref nrf_wifi_umac_cmd_get_tx_power"]
    NRF_WIFI_UMAC_CMD_GET_TX_POWER = 39,
    #[doc = " Get interface @ref nrf_wifi_cmd_get_interface"]
    NRF_WIFI_UMAC_CMD_GET_INTERFACE = 40,
    #[doc = " Get Wiphy info @ref nrf_wifi_cmd_get_wiphy"]
    NRF_WIFI_UMAC_CMD_GET_WIPHY = 41,
    #[doc = " Get hardware address @ref nrf_wifi_cmd_get_ifhwaddr"]
    NRF_WIFI_UMAC_CMD_GET_IFHWADDR = 42,
    #[doc = " Set hardware address @ref nrf_wifi_cmd_set_ifhwaddr"]
    NRF_WIFI_UMAC_CMD_SET_IFHWADDR = 43,
    #[doc = " Get regulatory domain @ref nrf_wifi_umac_cmd_get_reg"]
    NRF_WIFI_UMAC_CMD_GET_REG = 44,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SET_REG = 45,
    #[doc = " Set regulatory domain @ref  nrf_wifi_cmd_req_set_reg"]
    NRF_WIFI_UMAC_CMD_REQ_SET_REG = 46,
    #[doc = " Config UAPSD @ref nrf_wifi_umac_cmd_config_uapsd"]
    NRF_WIFI_UMAC_CMD_CONFIG_UAPSD = 47,
    #[doc = " Config TWT @ref nrf_wifi_umac_cmd_config_twt"]
    NRF_WIFI_UMAC_CMD_CONFIG_TWT = 48,
    #[doc = " Teardown TWT @ref nrf_wifi_umac_cmd_teardown_twt"]
    NRF_WIFI_UMAC_CMD_TEARDOWN_TWT = 49,
    #[doc = " Abort scan @ref nrf_wifi_umac_cmd_abort_scan"]
    NRF_WIFI_UMAC_CMD_ABORT_SCAN = 50,
    #[doc = " Multicast filter @ref nrf_wifi_umac_cmd_mcast_filter"]
    NRF_WIFI_UMAC_CMD_MCAST_FILTER = 51,
    #[doc = " Change macaddress @ref nrf_wifi_umac_cmd_change_macaddr"]
    NRF_WIFI_UMAC_CMD_CHANGE_MACADDR = 52,
    #[doc = " Set powersave timeout @ref nrf_wifi_umac_cmd_set_power_save_timeout"]
    NRF_WIFI_UMAC_CMD_SET_POWER_SAVE_TIMEOUT = 53,
    #[doc = " Get connection information @ref nrf_wifi_umac_cmd_conn_info"]
    NRF_WIFI_UMAC_CMD_GET_CONNECTION_INFO = 54,
    #[doc = " Get power save information @ref nrf_wifi_umac_cmd_get_power_save_info"]
    NRF_WIFI_UMAC_CMD_GET_POWER_SAVE_INFO = 55,
    #[doc = " Set listen interval @ref nrf_wifi_umac_cmd_set_listen_interval"]
    NRF_WIFI_UMAC_CMD_SET_LISTEN_INTERVAL = 56,
    #[doc = " Configure extended power save @ref nrf_wifi_umac_cmd_config_extended_ps"]
    NRF_WIFI_UMAC_CMD_CONFIG_EXTENDED_PS = 57,
}
#[repr(u32)]
#[doc = " @brief The host can receive the following events from the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_umac_events {
    NRF_WIFI_UMAC_EVENT_UNSPECIFIED = 256,
    #[doc = " Indicate scan started @ref nrf_wifi_umac_event_trigger_scan"]
    NRF_WIFI_UMAC_EVENT_TRIGGER_SCAN_START = 257,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_SCAN_ABORTED = 258,
    #[doc = " Indicate scan done @ref nrf_wifi_umac_event_scan_done"]
    NRF_WIFI_UMAC_EVENT_SCAN_DONE = 259,
    #[doc = " Scan result event @ref nrf_wifi_umac_event_new_scan_results"]
    NRF_WIFI_UMAC_EVENT_SCAN_RESULT = 260,
    #[doc = " Authentication status @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_AUTHENTICATE = 261,
    #[doc = " Association status @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_ASSOCIATE = 262,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_CONNECT = 263,
    #[doc = " Station deauth event @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_DEAUTHENTICATE = 264,
    #[doc = " Station disassoc event @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_DISASSOCIATE = 265,
    #[doc = " Station added indication @ref nrf_wifi_umac_event_new_station"]
    NRF_WIFI_UMAC_EVENT_NEW_STATION = 266,
    #[doc = " Station added indication @ref nrf_wifi_umac_event_new_station"]
    NRF_WIFI_UMAC_EVENT_DEL_STATION = 267,
    #[doc = " Station info indication @ref nrf_wifi_umac_event_new_station"]
    NRF_WIFI_UMAC_EVENT_GET_STATION = 268,
    #[doc = " remain on channel event @ref nrf_wifi_event_remain_on_channel"]
    NRF_WIFI_UMAC_EVENT_REMAIN_ON_CHANNEL = 269,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_CANCEL_REMAIN_ON_CHANNEL = 270,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_DISCONNECT = 271,
    #[doc = " RX management frame @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_FRAME = 272,
    #[doc = " Cookie mapping for NRF_WIFI_UMAC_CMD_FRAME @ref nrf_wifi_umac_event_cookie_rsp"]
    NRF_WIFI_UMAC_EVENT_COOKIE_RESP = 273,
    #[doc = " TX management frame transmitted @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_FRAME_TX_STATUS = 274,
    #[doc = " @ref nrf_wifi_umac_event_vif_state"]
    NRF_WIFI_UMAC_EVENT_IFFLAGS_STATUS = 275,
    #[doc = " Send Tx power @ref nrf_wifi_umac_event_get_tx_power"]
    NRF_WIFI_UMAC_EVENT_GET_TX_POWER = 276,
    #[doc = " Send Channel info @ref nrf_wifi_umac_event_get_channel"]
    NRF_WIFI_UMAC_EVENT_GET_CHANNEL = 277,
    #[doc = " @ref nrf_wifi_umac_event_set_interface"]
    NRF_WIFI_UMAC_EVENT_SET_INTERFACE = 278,
    #[doc = " @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_UNPROT_DEAUTHENTICATE = 279,
    #[doc = " @ref nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_UNPROT_DISASSOCIATE = 280,
    #[doc = " @ref nrf_wifi_interface_info"]
    NRF_WIFI_UMAC_EVENT_NEW_INTERFACE = 281,
    #[doc = " @ref nrf_wifi_event_get_wiphy"]
    NRF_WIFI_UMAC_EVENT_NEW_WIPHY = 282,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_GET_IFHWADDR = 283,
    #[doc = " Get regulatory @ref nrf_wifi_reg"]
    NRF_WIFI_UMAC_EVENT_GET_REG = 284,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_SET_REG = 285,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_REQ_SET_REG = 286,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_GET_KEY = 287,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_BEACON_HINT = 288,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_REG_CHANGE = 289,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_WIPHY_REG_CHANGE = 290,
    #[doc = " Display scan result @ref nrf_wifi_umac_event_new_scan_display_results"]
    NRF_WIFI_UMAC_EVENT_SCAN_DISPLAY_RESULT = 291,
    #[doc = " @ref nrf_wifi_umac_event_cmd_status"]
    NRF_WIFI_UMAC_EVENT_CMD_STATUS = 292,
    #[doc = " @ref nrf_wifi_umac_event_new_scan_results"]
    NRF_WIFI_UMAC_EVENT_BSS_INFO = 293,
    #[doc = " Send TWT response information @ref nrf_wifi_umac_cmd_config_twt"]
    NRF_WIFI_UMAC_EVENT_CONFIG_TWT = 294,
    #[doc = " Send TWT teardown information @ref nrf_wifi_umac_cmd_teardown_twt"]
    NRF_WIFI_UMAC_EVENT_TEARDOWN_TWT = 295,
    #[doc = " Send block or unblock state @ref nrf_wifi_umac_event_twt_sleep"]
    NRF_WIFI_UMAC_EVENT_TWT_SLEEP = 296,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_COALESCING = 297,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_MCAST_FILTER = 298,
    #[doc = " send connection information @ref nrf_wifi_umac_event_conn_info."]
    NRF_WIFI_UMAC_EVENT_GET_CONNECTION_INFO = 299,
    #[doc = " @ref nrf_wifi_umac_event_power_save_info"]
    NRF_WIFI_UMAC_EVENT_GET_POWER_SAVE_INFO = 300,
}
#[repr(u32)]
#[doc = " @brief Represents the values that can be used to specify the frequency band.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_band {
    #[doc = " 2.4 GHz ISM band"]
    NRF_WIFI_BAND_2GHZ = 0,
    #[doc = " Around 5 GHz band (4.9 - 5.7 GHz)"]
    NRF_WIFI_BAND_5GHZ = 1,
    #[doc = " Unused"]
    NRF_WIFI_BAND_60GHZ = 2,
    #[doc = " Invalid"]
    NRF_WIFI_BAND_INVALID = 3,
}
#[repr(u32)]
#[doc = " @brief Enable or Disable Management Frame Protection.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_mfp {
    #[doc = " Management frame protection not used"]
    NRF_WIFI_MFP_NO = 0,
    #[doc = " Management frame protection required"]
    NRF_WIFI_MFP_REQUIRED = 1,
}
#[repr(u32)]
#[doc = " @brief Enumerates the various categories of security keys.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_key_type {
    #[doc = " Group (broadcast/multicast) key"]
    NRF_WIFI_KEYTYPE_GROUP = 0,
    #[doc = " Pairwise (unicast/individual) key"]
    NRF_WIFI_KEYTYPE_PAIRWISE = 1,
    #[doc = " Peer key (DLS)"]
    NRF_WIFI_KEYTYPE_PEERKEY = 2,
    #[doc = " Number of defined key types"]
    NUM_NRF_WIFI_KEYTYPES = 3,
}
impl nrf_wifi_auth_type {
    pub const NRF_WIFI_AUTHTYPE_MAX: nrf_wifi_auth_type =
        nrf_wifi_auth_type::__NRF_WIFI_AUTHTYPE_NUM;
}
#[repr(u32)]
#[doc = " @brief Enumerates the various types of authentication mechanisms.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_auth_type {
    #[doc = " Open System authentication"]
    NRF_WIFI_AUTHTYPE_OPEN_SYSTEM = 0,
    #[doc = " Shared Key authentication (WEP only)"]
    NRF_WIFI_AUTHTYPE_SHARED_KEY = 1,
    #[doc = " Fast BSS Transition (IEEE 802.11r)"]
    NRF_WIFI_AUTHTYPE_FT = 2,
    #[doc = " Network EAP (some Cisco APs and mainly LEAP)"]
    NRF_WIFI_AUTHTYPE_NETWORK_EAP = 3,
    #[doc = " Simultaneous authentication of equals"]
    NRF_WIFI_AUTHTYPE_SAE = 4,
    #[doc = " Internal"]
    __NRF_WIFI_AUTHTYPE_NUM = 5,
    #[doc = " Determine automatically (if necessary by trying multiple times)"]
    NRF_WIFI_AUTHTYPE_AUTOMATIC = 6,
}
#[repr(u32)]
#[doc = " @brief Represents the interface's status concerning this BSS (Basic Service Set).\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_bss_status {
    #[doc = " Authenticated with this BSS\n Note that this is no longer used since cfg80211 no longer\n keeps track of whether or not authentication was done with\n a given BSS."]
    NRF_WIFI_BSS_STATUS_AUTHENTICATED = 0,
    #[doc = " Associated with this BSS"]
    NRF_WIFI_BSS_STATUS_ASSOCIATED = 1,
    #[doc = " Joined to this IBSS"]
    NRF_WIFI_BSS_STATUS_IBSS_JOINED = 2,
}
#[repr(u32)]
#[doc = " @brief Enumerates the various categories of channels.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_channel_type {
    #[doc = " 20 MHz, non-HT channel"]
    NRF_WIFI_CHAN_NO_HT = 0,
    #[doc = " 20 MHz HT channel"]
    NRF_WIFI_CHAN_HT20 = 1,
    #[doc = " HT40 channel, secondary channel below the control channel"]
    NRF_WIFI_CHAN_HT40MINUS = 2,
    #[doc = " HT40 channel, secondary channel above the control channel"]
    NRF_WIFI_CHAN_HT40PLUS = 3,
}
#[repr(u32)]
#[doc = " @brief Enumerates the various channel widths available.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_chan_width {
    #[doc = " 20 MHz, non-HT channel"]
    NRF_WIFI_CHAN_WIDTH_20_NOHT = 0,
    #[doc = " 20 MHz HT channel"]
    NRF_WIFI_CHAN_WIDTH_20 = 1,
    #[doc = " 40 MHz channel, the @ref %NRF_WIFI_ATTR_CENTER_FREQ1 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_40 = 2,
    #[doc = " 80 MHz channel, the @ref %NRF_WIFI_ATTR_CENTER_FREQ1 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_80 = 3,
    #[doc = " 80+80 MHz channel, the @ref %NRF_WIFI_ATTR_CENTER_FREQ1 and\n  @ref %NRF_WIFI_ATTR_CENTER_FREQ2 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_80P80 = 4,
    #[doc = " 160 MHz channel, the %NRF_WIFI_ATTR_CENTER_FREQ1 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_160 = 5,
    #[doc = "  5 MHz OFDM channel"]
    NRF_WIFI_CHAN_WIDTH_5 = 6,
    #[doc = " 10 MHz OFDM channel"]
    NRF_WIFI_CHAN_WIDTH_10 = 7,
}
impl nrf_wifi_iftype {
    pub const NRF_WIFI_IFTYPE_MAX: nrf_wifi_iftype = nrf_wifi_iftype::NRF_WIFI_IFTYPE_OCB;
}
#[repr(u32)]
#[doc = " @brief Interface types based on functionality.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_iftype {
    #[doc = " Unspecified type, driver decides"]
    NRF_WIFI_IFTYPE_UNSPECIFIED = 0,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_ADHOC = 1,
    #[doc = " Managed BSS member"]
    NRF_WIFI_IFTYPE_STATION = 2,
    #[doc = " Access point"]
    NRF_WIFI_IFTYPE_AP = 3,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_AP_VLAN = 4,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_WDS = 5,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_MONITOR = 6,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_MESH_POINT = 7,
    #[doc = " P2P client"]
    NRF_WIFI_IFTYPE_P2P_CLIENT = 8,
    #[doc = " P2P group owner"]
    NRF_WIFI_IFTYPE_P2P_GO = 9,
    #[doc = " P2P device use the @ref %NRF_WIFI_UMAC_CMD_START_P2P_DEVICE &\n  @ref %NRF_WIFI_UMAC_CMD_STOP_P2P_DEVICE commands to create and destroy one"]
    NRF_WIFI_IFTYPE_P2P_DEVICE = 10,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_OCB = 11,
    #[doc = " Highest interface type number currently defined"]
    NUM_NRF_WIFI_IFTYPES = 12,
}
#[repr(u32)]
#[doc = " @brief Powersave state.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_ps_state {
    #[doc = " powersave is disabled"]
    NRF_WIFI_PS_DISABLED = 0,
    #[doc = " powersave is enabled"]
    NRF_WIFI_PS_ENABLED = 1,
}
#[repr(u32)]
#[doc = " @brief WLAN security types.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_security_type {
    #[doc = " OPEN"]
    NRF_WIFI_OPEN = 0,
    #[doc = " WEP"]
    NRF_WIFI_WEP = 1,
    #[doc = " WPA"]
    NRF_WIFI_WPA = 2,
    #[doc = " WPA2"]
    NRF_WIFI_WPA2 = 3,
    #[doc = " WPA3"]
    NRF_WIFI_WPA3 = 4,
    #[doc = " WAPI"]
    NRF_WIFI_WAPI = 5,
    #[doc = " Enterprise mode"]
    NRF_WIFI_EAP = 6,
    #[doc = " WPA2 sha 256"]
    NRF_WIFI_WPA2_256 = 7,
}
#[repr(u32)]
#[doc = " @brief Denotes the originator of a regulatory domain request.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_reg_initiator {
    #[doc = " Core queried CRDA for a dynamic world regulatory domain"]
    NRF_WIFI_REGDOM_SET_BY_CORE = 0,
    #[doc = " User asked the wireless core to set the regulatory domain"]
    NRF_WIFI_REGDOM_SET_BY_USER = 1,
    #[doc = " A wireless drivers has hinted to the wireless core it thinks\n its knows the regulatory domain we should be in"]
    NRF_WIFI_REGDOM_SET_BY_DRIVER = 2,
    #[doc = " the wireless core has received an\n 802.11 country information element with regulatory information it\n thinks we should consider. cfg80211 only processes the country\n code from the IE, and relies on the regulatory domain information\n structure passed by userspace (CRDA) from our wireless-regdb\n If a channel is enabled but the country code indicates it should\n be disabled we disable the channel and re-enable it upon disassociation"]
    NRF_WIFI_REGDOM_SET_BY_COUNTRY_IE = 3,
}
#[repr(u32)]
#[doc = " @brief Specifies the type of regulatory domain.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_reg_type {
    #[doc = " the regulatory domain set is one that pertains\n to a specific country. When this is set you can count on the\n ISO / IEC 3166 alpha2 country code being valid.\n"]
    NRF_WIFI_REGDOM_TYPE_COUNTRY = 0,
    #[doc = " the regulatory set domain is the world regulatory domain"]
    NRF_WIFI_REGDOM_TYPE_WORLD = 1,
    #[doc = " the regulatory domain set is a custom\n driver specific world regulatory domain. These do not apply system-wide\n and are only applicable to the individual devices which have requested\n them to be applied."]
    NRF_WIFI_REGDOM_TYPE_CUSTOM_WORLD = 2,
    #[doc = " the regulatory domain set is the product\n of an intersection between two regulatory domains -- the previously\n set regulatory domain on the system and the last accepted regulatory\n domain request to be processed."]
    NRF_WIFI_REGDOM_TYPE_INTERSECTION = 3,
}
#[doc = " @brief This structure provides details about the SSID.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ssid {
    #[doc = " length of SSID"]
    pub nrf_wifi_ssid_len: ::core::ffi::c_uchar,
    #[doc = " SSID string"]
    pub nrf_wifi_ssid: [::core::ffi::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_ssid() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_ssid> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_ssid>(),
        33usize,
        concat!("Size of: ", stringify!(nrf_wifi_ssid))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_ssid>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_ssid))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_ssid_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ssid),
            "::",
            stringify!(nrf_wifi_ssid_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_ssid) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ssid),
            "::",
            stringify!(nrf_wifi_ssid)
        )
    );
}
#[doc = " @brief This structure contains data related to the Information Elements (IEs).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ie {
    #[doc = " length of IE"]
    pub ie_len: ::core::ffi::c_ushort,
    #[doc = " Information element data"]
    pub ie: [::core::ffi::c_schar; 400usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_ie() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_ie> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_ie>(),
        402usize,
        concat!("Size of: ", stringify!(nrf_wifi_ie))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_ie>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_ie))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ie),
            "::",
            stringify!(ie_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ie),
            "::",
            stringify!(ie)
        )
    );
}
#[doc = " @brief Transmit key sequence number.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_seq {
    #[doc = " Length of the seq parameter"]
    pub nrf_wifi_seq_len: ::core::ffi::c_int,
    #[doc = " Key sequence number data"]
    pub nrf_wifi_seq: [::core::ffi::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_seq() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_seq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_seq>(),
        260usize,
        concat!("Size of: ", stringify!(nrf_wifi_seq))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_seq>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_seq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_seq_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_seq),
            "::",
            stringify!(nrf_wifi_seq_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_seq),
            "::",
            stringify!(nrf_wifi_seq)
        )
    );
}
#[doc = " @brief This structure holds information related to a security key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_key {
    #[doc = " Length of the key data"]
    pub nrf_wifi_key_len: ::core::ffi::c_uint,
    #[doc = " Key data"]
    pub nrf_wifi_key: [::core::ffi::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_key() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_key>(),
        260usize,
        concat!("Size of: ", stringify!(nrf_wifi_key))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_key>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_key_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_key),
            "::",
            stringify!(nrf_wifi_key_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_key),
            "::",
            stringify!(nrf_wifi_key)
        )
    );
}
#[doc = " @brief This structure represents SAE elements in Authentication frame.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sae {
    #[doc = " Length of SAE element data"]
    pub sae_data_len: ::core::ffi::c_int,
    #[doc = " SAE element data"]
    pub sae_data: [::core::ffi::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_sae() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sae> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sae>(),
        260usize,
        concat!("Size of: ", stringify!(nrf_wifi_sae))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sae>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sae))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sae_data_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sae),
            "::",
            stringify!(sae_data_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sae_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sae),
            "::",
            stringify!(sae_data)
        )
    );
}
#[doc = " @brief This structure defines the frame that is intended for transmission.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_frame {
    #[doc = " Length of the frame"]
    pub frame_len: ::core::ffi::c_int,
    #[doc = " frame data"]
    pub frame: [::core::ffi::c_schar; 400usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_frame() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_frame> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_frame>(),
        404usize,
        concat!("Size of: ", stringify!(nrf_wifi_frame))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_frame>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_frame))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_frame),
            "::",
            stringify!(frame_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_frame),
            "::",
            stringify!(frame)
        )
    );
}
#[doc = " @brief This structure contains details about the interface information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_index_ids {
    #[doc = " Indicate which properties below are set"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " wdev id"]
    pub ifaceindex: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub nrf_wifi_wiphy_idx: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub wdev_id: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_index_ids() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_index_ids> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_index_ids>(),
        20usize,
        concat!("Size of: ", stringify!(nrf_wifi_index_ids))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_index_ids>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_index_ids))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_index_ids),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifaceindex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_index_ids),
            "::",
            stringify!(ifaceindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_wiphy_idx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_index_ids),
            "::",
            stringify!(nrf_wifi_wiphy_idx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wdev_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_index_ids),
            "::",
            stringify!(wdev_id)
        )
    );
}
#[doc = " @brief This structure provides information about the rate parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_supp_rates {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency band, see &enum nrf_wifi_band"]
    pub band: ::core::ffi::c_int,
    #[doc = " Number of values in rates parameter"]
    pub nrf_wifi_num_rates: ::core::ffi::c_int,
    #[doc = " List of supported rates as defined by IEEE 802.11 7.3.2.2"]
    pub rates: [::core::ffi::c_uchar; 60usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_supp_rates() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_supp_rates> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_supp_rates>(),
        72usize,
        concat!("Size of: ", stringify!(nrf_wifi_supp_rates))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_supp_rates>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_supp_rates))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supp_rates),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supp_rates),
            "::",
            stringify!(band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_num_rates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supp_rates),
            "::",
            stringify!(nrf_wifi_num_rates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rates) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supp_rates),
            "::",
            stringify!(rates)
        )
    );
}
#[doc = " @brief This structure contains details about a channel's information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_channel {
    #[doc = " band this channel belongs to"]
    pub band: ::core::ffi::c_int,
    #[doc = " center frequency in MHz"]
    pub center_frequency: ::core::ffi::c_uint,
    #[doc = " channel flags from see &enum nrf_wifi_channel_flags"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " maximum antenna gain in dBi"]
    pub nrf_wifi_max_antenna_gain: ::core::ffi::c_int,
    #[doc = " maximum transmission power (in dBm)"]
    pub nrf_wifi_max_power: ::core::ffi::c_int,
    #[doc = " maximum regulatory transmission power (in dBm)"]
    pub nrf_wifi_max_reg_power: ::core::ffi::c_int,
    #[doc = " channel flags at registration time, used by regulatory\n  code to support devices with additional restrictions"]
    pub nrf_wifi_orig_flags: ::core::ffi::c_uint,
    #[doc = " internal use"]
    pub nrf_wifi_orig_mag: ::core::ffi::c_int,
    #[doc = " internal use"]
    pub nrf_wifi_orig_mpwr: ::core::ffi::c_int,
    #[doc = " hardware-specific value for the channel"]
    pub hw_value: ::core::ffi::c_ushort,
    #[doc = " helper to regulatory code to indicate when a beacon\n  has been found on this channel. Use regulatory_hint_found_beacon()\n  to enable this, this is useful only on 5 GHz band."]
    pub nrf_wifi_beacon_found: ::core::ffi::c_schar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_channel() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_channel> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_channel>(),
        39usize,
        concat!("Size of: ", stringify!(nrf_wifi_channel))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_channel>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_channel))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(center_frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_max_antenna_gain) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_max_antenna_gain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_max_power) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_max_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_max_reg_power) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_max_reg_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_orig_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_orig_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_orig_mag) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_orig_mag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_orig_mpwr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_orig_mpwr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_value) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(hw_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_beacon_found) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_channel),
            "::",
            stringify!(nrf_wifi_beacon_found)
        )
    );
}
#[doc = " @brief This structure provides details about the parameters required for a scan request.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_scan_params {
    #[doc = " If 0x1, RPU force passive scan on all channels"]
    pub passive_scan: ::core::ffi::c_ushort,
    #[doc = " Number of ssid's in scan_ssids parameter"]
    pub num_scan_ssids: ::core::ffi::c_uchar,
    #[doc = " Specific SSID's to scan for"]
    pub scan_ssids: [nrf_wifi_ssid; 2usize],
    #[doc = " used to send probe requests at non CCK rate in 2GHz band"]
    pub no_cck: ::core::ffi::c_uchar,
    #[doc = "  Bitmap of bands to be scanned. Value Zero will scan both 2.4 and 5 GHZ"]
    pub bands: ::core::ffi::c_uchar,
    #[doc = " Information element(s) data @ref nrf_wifi_ie"]
    pub ie: nrf_wifi_ie,
    #[doc = " MAC address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Max scan duration in active scan. If zero rpu programs 50msec"]
    pub dwell_time_active: ::core::ffi::c_ushort,
    #[doc = " Max scan duration in passive scan. If zero rpu programs 150msec"]
    pub dwell_time_passive: ::core::ffi::c_ushort,
    #[doc = " Number of channels to be scanned"]
    pub num_scan_channels: ::core::ffi::c_ushort,
    #[doc = " specific channels to be scanned"]
    pub center_frequency: __IncompleteArrayField<::core::ffi::c_uint>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_scan_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_scan_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_scan_params>(),
        485usize,
        concat!("Size of: ", stringify!(nrf_wifi_scan_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_scan_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_scan_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).passive_scan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(passive_scan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_scan_ssids) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(num_scan_ssids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_ssids) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(scan_ssids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_cck) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(no_cck)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(bands)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(ie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        473usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwell_time_active) as usize - ptr as usize },
        479usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(dwell_time_active)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwell_time_passive) as usize - ptr as usize },
        481usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(dwell_time_passive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_scan_channels) as usize - ptr as usize },
        483usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(num_scan_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency) as usize - ptr as usize },
        485usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_scan_params),
            "::",
            stringify!(center_frequency)
        )
    );
}
#[doc = " @brief This structure contains specific information about the VHT (Very High Throughput)\n  and HT ((High Throughput)) capabilities.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ht_vht_capabilities {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Indicate which capabilities have been specified"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " HT Capability information element (from association request when\n  used with NRF_WIFI_UMAC_CMD_NEW_STATION)."]
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Specify which bits of the ht_capability are masked"]
    pub ht_capability_mask: [::core::ffi::c_uchar; 256usize],
    #[doc = " VHT Capability information element"]
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Specify which bits in vht_capability to which attention should be paid"]
    pub vht_capability_mask: [::core::ffi::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_ht_vht_capabilities() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_ht_vht_capabilities> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_ht_vht_capabilities>(),
        1030usize,
        concat!("Size of: ", stringify!(nrf_wifi_ht_vht_capabilities))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_ht_vht_capabilities>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_ht_vht_capabilities))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ht_vht_capabilities),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ht_vht_capabilities),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ht_capability) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ht_vht_capabilities),
            "::",
            stringify!(ht_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ht_capability_mask) as usize - ptr as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ht_vht_capabilities),
            "::",
            stringify!(ht_capability_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_capability) as usize - ptr as usize },
        518usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ht_vht_capabilities),
            "::",
            stringify!(vht_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_capability_mask) as usize - ptr as usize },
        774usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ht_vht_capabilities),
            "::",
            stringify!(vht_capability_mask)
        )
    );
}
#[doc = " @brief This structure represents information related to the signal strength.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct nrf_wifi_signal {
    #[doc = " MBM or unspecified"]
    pub signal_type: ::core::ffi::c_uint,
    pub signal: nrf_wifi_signal__bindgen_ty_1,
}
#[doc = " signal"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union nrf_wifi_signal__bindgen_ty_1 {
    #[doc = " If MBM signal strength of probe response/beacon\n  in mBm (100 * dBm) (s32)"]
    pub mbm_signal: ::core::ffi::c_uint,
    #[doc = " If unspecified signal strength of the probe response/beacon\n  in unspecified units, scaled to 0..100 (u8)."]
    pub unspec_signal: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_signal__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_signal__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_signal__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_signal__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_signal__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_signal__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mbm_signal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_signal__bindgen_ty_1),
            "::",
            stringify!(mbm_signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unspec_signal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_signal__bindgen_ty_1),
            "::",
            stringify!(unspec_signal)
        )
    );
}
#[test]
fn bindgen_test_layout_nrf_wifi_signal() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_signal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_signal>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_signal))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_signal>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_signal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_signal),
            "::",
            stringify!(signal_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_signal),
            "::",
            stringify!(signal)
        )
    );
}
#[doc = " @brief This structure contains parameters related to the connection.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_connect_common_info {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency of the selected channel in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Frequency of the recommended initial BSS"]
    pub freq_hint: ::core::ffi::c_uint,
    #[doc = " Indicates which WPA version(s)"]
    pub wpa_versions: ::core::ffi::c_uint,
    #[doc = " Number of pairwise cipher suites"]
    pub num_cipher_suites_pairwise: ::core::ffi::c_int,
    #[doc = " For crypto settings, indicates which pairwise cipher suites are used"]
    pub cipher_suites_pairwise: [::core::ffi::c_uint; 7usize],
    #[doc = " For crypto settings, indicates which group cipher suite is used"]
    pub cipher_suite_group: ::core::ffi::c_uint,
    #[doc = " Number of groupwise cipher suites"]
    pub num_akm_suites: ::core::ffi::c_uint,
    #[doc = " Indicate which key management algorithm(s) to use"]
    pub akm_suites: [::core::ffi::c_uint; 2usize],
    #[doc = " Whether management frame protection (IEEE 802.11w) is used for the association"]
    pub use_mfp: ::core::ffi::c_int,
    #[doc = " Flag for indicating whether the current connection\n  shall support Radio Resource Measurements (11k)"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Background scan period in seconds or 0 to disable background scan"]
    pub bg_scan_period: ::core::ffi::c_ushort,
    #[doc = " MAC address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " MAC address recommendation as initial BSS"]
    pub mac_addr_hint: [::core::ffi::c_uchar; 6usize],
    #[doc = " SSID (binary attribute, 0..32 octets)"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " IE's @ref nrf_wifi_ie"]
    pub wpa_ie: nrf_wifi_ie,
    #[doc = " VHT Capability information element @ref nrf_wifi_ht_vht_capabilities"]
    pub ht_vht_capabilities: nrf_wifi_ht_vht_capabilities,
    #[doc = " A 16-bit value indicating the ethertype that will be used for key negotiation.\n  If it is not specified, the value defaults to 0x888E."]
    pub control_port_ether_type: ::core::ffi::c_ushort,
    #[doc = " When included along with control_port_ether_type, indicates that the custom\n  ethertype frames used for key negotiation must not be encrypted."]
    pub control_port_no_encrypt: ::core::ffi::c_uchar,
    #[doc = " Indicating whether user space controls IEEE 802.1X port, If set, the RPU will\n  assume that the port is unauthorized until authorized by user space.\n  Otherwise, port is marked authorized by default in station mode."]
    pub control_port: ::core::ffi::c_schar,
    #[doc = " previous BSSID, used to specify a request to reassociate\n  within an ESS that is, to use Reassociate Request frame (with the value of\n  this attribute in the Current AP address field) instead of Association\n  Request frame which is used for the initial association to an ESS."]
    pub prev_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = " Bss max idle timeout value in sec which will be encapsulated into\n  BSS MAX IDLE IE in assoc request frame."]
    pub maxidle_insec: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_connect_common_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_connect_common_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_connect_common_info>(),
        1563usize,
        concat!("Size of: ", stringify!(nrf_wifi_connect_common_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_connect_common_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_connect_common_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_hint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(freq_hint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wpa_versions) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(wpa_versions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_cipher_suites_pairwise) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(num_cipher_suites_pairwise)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_suites_pairwise) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(cipher_suites_pairwise)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_suite_group) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(cipher_suite_group)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_akm_suites) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(num_akm_suites)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).akm_suites) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(akm_suites)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_mfp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(use_mfp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bg_scan_period) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(bg_scan_period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr_hint) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(mac_addr_hint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wpa_ie) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(wpa_ie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ht_vht_capabilities) as usize - ptr as usize },
        521usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(ht_vht_capabilities)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_port_ether_type) as usize - ptr as usize },
        1551usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(control_port_ether_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_port_no_encrypt) as usize - ptr as usize },
        1553usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(control_port_no_encrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_port) as usize - ptr as usize },
        1554usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(control_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_bssid) as usize - ptr as usize },
        1555usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(prev_bssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxidle_insec) as usize - ptr as usize },
        1561usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_connect_common_info),
            "::",
            stringify!(maxidle_insec)
        )
    );
}
#[doc = " @brief This structure provides information about beacon and probe data.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_beacon_data {
    #[doc = " length of head"]
    pub head_len: ::core::ffi::c_uint,
    #[doc = " length of tail"]
    pub tail_len: ::core::ffi::c_uint,
    #[doc = " length of probe response template (probe_resp)"]
    pub probe_resp_len: ::core::ffi::c_uint,
    #[doc = "  head portion of beacon (before TIM IE) or %NULL if not changed"]
    pub head: [::core::ffi::c_uchar; 256usize],
    #[doc = " tail portion of beacon (after TIM IE) or %NULL if not changed"]
    pub tail: [::core::ffi::c_uchar; 512usize],
    #[doc = " probe response template"]
    pub probe_resp: [::core::ffi::c_uchar; 400usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_beacon_data() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_beacon_data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_beacon_data>(),
        1180usize,
        concat!("Size of: ", stringify!(nrf_wifi_beacon_data))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_beacon_data>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_beacon_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_beacon_data),
            "::",
            stringify!(head_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_beacon_data),
            "::",
            stringify!(tail_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe_resp_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_beacon_data),
            "::",
            stringify!(probe_resp_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_beacon_data),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_beacon_data),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe_resp) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_beacon_data),
            "::",
            stringify!(probe_resp)
        )
    );
}
#[doc = " @brief This structure provides information regarding station flags.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_flag_update {
    #[doc = " Mask of station flags to set"]
    pub nrf_wifi_mask: ::core::ffi::c_uint,
    #[doc = " Values to set them to. NRF_WIFI_STA_FLAG_AUTHORIZED"]
    pub nrf_wifi_set: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_sta_flag_update() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sta_flag_update> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sta_flag_update>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_sta_flag_update))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sta_flag_update>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sta_flag_update))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_flag_update),
            "::",
            stringify!(nrf_wifi_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_set) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_flag_update),
            "::",
            stringify!(nrf_wifi_set)
        )
    );
}
#[doc = " @brief This structure contains information about rate parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_rate_info {
    #[doc = " Valid fields with in this structure"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " bitrate"]
    pub bitrate: ::core::ffi::c_uint,
    #[doc = " Bitrate compatible"]
    pub bitrate_compat: ::core::ffi::c_ushort,
    #[doc = " Modulation and Coding Scheme(MCS)"]
    pub nrf_wifi_mcs: ::core::ffi::c_uchar,
    #[doc = " MCS related to VHT"]
    pub vht_mcs: ::core::ffi::c_uchar,
    #[doc = " NSS related to VHT"]
    pub vht_nss: ::core::ffi::c_uchar,
    #[doc = " Rate flags NRF_WIFI_RATE_INFO_0_MHZ_WIDTH"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_rate_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_rate_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_rate_info>(),
        17usize,
        concat!("Size of: ", stringify!(nrf_wifi_rate_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_rate_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_rate_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rate_info),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rate_info),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitrate_compat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rate_info),
            "::",
            stringify!(bitrate_compat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_mcs) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rate_info),
            "::",
            stringify!(nrf_wifi_mcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_mcs) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rate_info),
            "::",
            stringify!(vht_mcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_nss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rate_info),
            "::",
            stringify!(vht_nss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_rate_info),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
}
#[doc = " @brief This structure provides information about the Basic Service Set (BSS)\n  parameters for the attached station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_bss_parameters {
    #[doc = " bitfields of flags NRF_WIFI_BSS_PARAM_FLAGS_CTS_PROT"]
    pub nrf_wifi_flags: ::core::ffi::c_uchar,
    #[doc = " DTIM period for the BSS"]
    pub dtim_period: ::core::ffi::c_uchar,
    #[doc = " beacon interval"]
    pub beacon_interval: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_sta_bss_parameters() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sta_bss_parameters> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sta_bss_parameters>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_sta_bss_parameters))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sta_bss_parameters>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sta_bss_parameters))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_bss_parameters),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dtim_period) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_bss_parameters),
            "::",
            stringify!(dtim_period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_interval) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_bss_parameters),
            "::",
            stringify!(beacon_interval)
        )
    );
}
#[doc = " @brief This structure contains information about a Station (STA).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_info {
    #[doc = " Valid fields with in this structure"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " time since the station is last connected"]
    pub connected_time: ::core::ffi::c_uint,
    #[doc = " time since last activity, in msec"]
    pub inactive_time: ::core::ffi::c_uint,
    #[doc = " total received bytes from this station"]
    pub rx_bytes: ::core::ffi::c_uint,
    #[doc = " total transmitted bytes to this station"]
    pub tx_bytes: ::core::ffi::c_uint,
    #[doc = " per-chain signal mask value"]
    pub chain_signal_mask: ::core::ffi::c_uint,
    #[doc = " per-chain signal strength of last PPDU"]
    pub chain_signal: [::core::ffi::c_uchar; 4usize],
    #[doc = " per-chain signal strength average mask value"]
    pub chain_signal_avg_mask: ::core::ffi::c_uint,
    #[doc = " per-chain signal strength average"]
    pub chain_signal_avg: [::core::ffi::c_uchar; 4usize],
    #[doc = "@ref nrf_wifi_rate_info"]
    pub tx_bitrate: nrf_wifi_rate_info,
    #[doc = "@ref nrf_wifi_rate_info"]
    pub rx_bitrate: nrf_wifi_rate_info,
    #[doc = " Not used"]
    pub llid: ::core::ffi::c_ushort,
    #[doc = " Not used"]
    pub plid: ::core::ffi::c_ushort,
    #[doc = " Not used"]
    pub plink_state: ::core::ffi::c_uchar,
    #[doc = " signal strength of last received PPDU, in dbm"]
    pub signal: ::core::ffi::c_int,
    #[doc = " signal strength average, in dbm"]
    pub signal_avg: ::core::ffi::c_int,
    #[doc = " total received packet from this station"]
    pub rx_packets: ::core::ffi::c_uint,
    #[doc = " total transmitted packets to this station"]
    pub tx_packets: ::core::ffi::c_uint,
    #[doc = " total retries to this station"]
    pub tx_retries: ::core::ffi::c_uint,
    #[doc = " total failed packets to this station"]
    pub tx_failed: ::core::ffi::c_uint,
    #[doc = " expected throughput in kbps"]
    pub expected_throughput: ::core::ffi::c_uint,
    #[doc = " count of times beacon loss was detected"]
    pub beacon_loss_count: ::core::ffi::c_uint,
    #[doc = " Not used"]
    pub local_pm: ::core::ffi::c_uint,
    #[doc = " Not used"]
    pub peer_pm: ::core::ffi::c_uint,
    #[doc = " Not used"]
    pub nonpeer_pm: ::core::ffi::c_uint,
    #[doc = " station flags @ref nrf_wifi_sta_flag_update"]
    pub sta_flags: nrf_wifi_sta_flag_update,
    #[doc = " timing offset with respect to this STA"]
    pub t_offset: ::core::ffi::c_ulonglong,
    #[doc = " count of times other(non beacon) loss was detected"]
    pub rx_dropped_misc: ::core::ffi::c_ulonglong,
    #[doc = " count of times beacon"]
    pub rx_beacon: ::core::ffi::c_ulonglong,
    #[doc = " average of beacon signal"]
    pub rx_beacon_signal_avg: ::core::ffi::c_longlong,
    #[doc = " Station connected BSS params. @ref nrf_wifi_sta_bss_parameters"]
    pub bss_param: nrf_wifi_sta_bss_parameters,
}
#[test]
fn bindgen_test_layout_nrf_wifi_sta_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sta_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sta_info>(),
        163usize,
        concat!("Size of: ", stringify!(nrf_wifi_sta_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sta_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sta_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connected_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(connected_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inactive_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(inactive_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_bytes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chain_signal_mask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(chain_signal_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chain_signal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(chain_signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chain_signal_avg_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(chain_signal_avg_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chain_signal_avg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(chain_signal_avg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bitrate) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(tx_bitrate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_bitrate) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(rx_bitrate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llid) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(llid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plid) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(plid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plink_state) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(plink_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal_avg) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(signal_avg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packets) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packets) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_retries) as usize - ptr as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(tx_retries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_failed) as usize - ptr as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(tx_failed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expected_throughput) as usize - ptr as usize },
        99usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(expected_throughput)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_loss_count) as usize - ptr as usize },
        103usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(beacon_loss_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_pm) as usize - ptr as usize },
        107usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(local_pm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_pm) as usize - ptr as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(peer_pm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonpeer_pm) as usize - ptr as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(nonpeer_pm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_flags) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(sta_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t_offset) as usize - ptr as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(t_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_dropped_misc) as usize - ptr as usize },
        135usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(rx_dropped_misc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_beacon) as usize - ptr as usize },
        143usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(rx_beacon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_beacon_signal_avg) as usize - ptr as usize },
        151usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(rx_beacon_signal_avg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bss_param) as usize - ptr as usize },
        159usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_info),
            "::",
            stringify!(bss_param)
        )
    );
}
#[doc = " @brief The command header expected by UMAC to handle requests from the control interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_hdr {
    #[doc = " unused"]
    pub portid: ::core::ffi::c_uint,
    #[doc = " unused"]
    pub seq: ::core::ffi::c_uint,
    #[doc = " UMAC command/event value see &enum nrf_wifi_umac_commands\n  see &enum nrf_wifi_umac_events"]
    pub cmd_evnt: ::core::ffi::c_uint,
    #[doc = " unused"]
    pub rpu_ret_val: ::core::ffi::c_int,
    #[doc = " Interface information @ref nrf_wifi_index_ids"]
    pub ids: nrf_wifi_index_ids,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_hdr() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_hdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_hdr>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_hdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).portid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_hdr),
            "::",
            stringify!(portid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_hdr),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_evnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_hdr),
            "::",
            stringify!(cmd_evnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rpu_ret_val) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_hdr),
            "::",
            stringify!(rpu_ret_val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ids) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_hdr),
            "::",
            stringify!(ids)
        )
    );
}
#[doc = " @brief This structure contains information about a security key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_key_info {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Key cipher suite (as defined by IEEE 802.11 section 7.3.2.25.1)"]
    pub cipher_suite: ::core::ffi::c_uint,
    #[doc = " Specify what a key should be set as default as example NRF_WIFI_KEY_DEFAULT_MGMT"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Key Type, see &enum nrf_wifi_key_type"]
    pub key_type: ::core::ffi::c_int,
    #[doc = " Key data @ref nrf_wifi_key"]
    pub key: nrf_wifi_key,
    #[doc = " Transmit key sequence number (IV/PN) for TKIP and CCMP keys,\n  each six bytes in little endian @ref nrf_wifi_seq"]
    pub seq: nrf_wifi_seq,
    #[doc = " Key ID (0-3)"]
    pub key_idx: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_key_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_key_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_key_info>(),
        535usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_key_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_key_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_key_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_key_info),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_suite) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_key_info),
            "::",
            stringify!(cipher_suite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_key_info),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_type) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_key_info),
            "::",
            stringify!(key_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_key_info),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        274usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_key_info),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_idx) as usize - ptr as usize },
        534usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_key_info),
            "::",
            stringify!(key_idx)
        )
    );
}
#[repr(u32)]
#[doc = " @brief This enum describes the different types of scan.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum scan_reason {
    #[doc = " scan for display purpose in user space"]
    SCAN_DISPLAY = 0,
    #[doc = " scan for connection purpose"]
    SCAN_CONNECT = 1,
}
#[doc = " @brief This structure contains details about scan request information.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_scan_info {
    #[doc = " scan type see &enum scan_reason"]
    pub scan_reason: ::core::ffi::c_int,
    #[doc = " scan parameters @ref nrf_wifi_scan_params"]
    pub scan_params: nrf_wifi_scan_params,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_scan_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_scan_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_scan_info>(),
        489usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_scan_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_scan_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_scan_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_reason) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_scan_info),
            "::",
            stringify!(scan_reason)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_scan_info),
            "::",
            stringify!(scan_params)
        )
    );
}
#[doc = " @brief This structure defines a command scan request.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_cmd_scan {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref nrf_wifi_umac_scan_info"]
    pub info: nrf_wifi_umac_scan_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_scan() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_scan> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_scan>(),
        525usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_scan))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_scan>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_scan))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_scan),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_scan),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure defines a command to abort a scan request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_abort_scan {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_abort_scan() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_abort_scan> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_abort_scan>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_abort_scan))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_abort_scan>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_abort_scan))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_abort_scan),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief TThis structure defines a command to request scan results.\n This command should be executed only if we have received a\n NRF_WIFI_UMAC_EVENT_SCAN_DONE event for a previous scan.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_scan_results {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " scan type see &enum scan_reason"]
    pub scan_reason: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_get_scan_results() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_get_scan_results> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_get_scan_results>(),
        40usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_get_scan_results))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_get_scan_results>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_get_scan_results)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_scan_results),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_reason) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_scan_results),
            "::",
            stringify!(scan_reason)
        )
    );
}
#[doc = " @brief This structure provides details about the \"Scan Done\" event.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_scan_done {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " status, 0=Scan successful & 1=Scan aborted"]
    pub status: ::core::ffi::c_int,
    #[doc = " scan type see &enum scan_reason"]
    pub scan_type: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_scan_done() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_scan_done> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_scan_done>(),
        44usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_scan_done))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_scan_done>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_scan_done))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_scan_done),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_scan_done),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_scan_done),
            "::",
            stringify!(scan_type)
        )
    );
}
#[doc = " @brief This structure represents the parameters used to configure the multicast address filter.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_mcast_cfg {
    #[doc = " Add (0) or Delete (1)"]
    pub type_: ::core::ffi::c_uint,
    #[doc = " multicast address to be added/deleted"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_mcast_cfg() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_mcast_cfg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_mcast_cfg>(),
        10usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_mcast_cfg))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_mcast_cfg>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_mcast_cfg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mcast_cfg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mcast_cfg),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure defines a command used to set multicast (mcast) addresses.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_mcast_filter {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref nrf_wifi_umac_mcast_cfg"]
    pub info: nrf_wifi_umac_mcast_cfg,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_mcast_filter() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_mcast_filter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_mcast_filter>(),
        46usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_mcast_filter))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_mcast_filter>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_mcast_filter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_mcast_filter),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_mcast_filter),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the parameters used to change the MAC address.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_change_macaddr_info {
    #[doc = " MAC address to be set"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_change_macaddr_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_change_macaddr_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_change_macaddr_info>(),
        6usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_change_macaddr_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_change_macaddr_info>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_change_macaddr_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_change_macaddr_info),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure describes command to change MAC address.\n  This has to be used only when the interface is down.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_change_macaddr {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref nrf_wifi_umac_change_macaddr_info"]
    pub macaddr_info: nrf_wifi_umac_change_macaddr_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_change_macaddr() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_change_macaddr> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_change_macaddr>(),
        42usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_change_macaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_change_macaddr>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_change_macaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_change_macaddr),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).macaddr_info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_change_macaddr),
            "::",
            stringify!(macaddr_info)
        )
    );
}
#[doc = " @brief This structure specifies the parameters to be used when sending an authentication request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_auth_info {
    #[doc = " Frequency of the selected channel in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Flag attribute to indicate that a command is requesting a local\n  authentication/association state change without invoking actual management\n  frame exchange. This can be used with NRF_WIFI_UMAC_CMD_AUTHENTICATE\n  NRF_WIFI_UMAC_CMD_DEAUTHENTICATE."]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Authentication type. see &enum nrf_wifi_auth_type"]
    pub auth_type: ::core::ffi::c_int,
    #[doc = " Key information"]
    pub key_info: nrf_wifi_umac_key_info,
    #[doc = " SSID (binary attribute, 0..32 octets)"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " Information element(s) data"]
    pub ie: nrf_wifi_ie,
    #[doc = " SAE elements in Authentication frames. This starts\n  with the Authentication transaction sequence number field."]
    pub sae: nrf_wifi_sae,
    #[doc = " MAC address (various uses)"]
    pub nrf_wifi_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = " The following parameters will be used to construct bss database in case of\n cfg80211 offload to host case.\n/\n/** scanning width"]
    pub scan_width: ::core::ffi::c_int,
    #[doc = " Signal strength"]
    pub nrf_wifi_signal: ::core::ffi::c_int,
    #[doc = " Received elements from beacon or probe response"]
    pub from_beacon: ::core::ffi::c_int,
    #[doc = " BSS information element data"]
    pub bss_ie: nrf_wifi_ie,
    #[doc = " BSS capability"]
    pub capability: ::core::ffi::c_ushort,
    #[doc = " Beacon interval(ms)"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " Beacon tsf"]
    pub tsf: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_auth_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_auth_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_auth_info>(),
        1672usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_auth_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_auth_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_auth_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_type) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(auth_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_info) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(key_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        545usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie) as usize - ptr as usize },
        578usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(ie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sae) as usize - ptr as usize },
        980usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(sae)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_bssid) as usize - ptr as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(nrf_wifi_bssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_width) as usize - ptr as usize },
        1246usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(scan_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_signal) as usize - ptr as usize },
        1250usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(nrf_wifi_signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from_beacon) as usize - ptr as usize },
        1254usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(from_beacon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bss_ie) as usize - ptr as usize },
        1258usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(bss_ie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        1660usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_interval) as usize - ptr as usize },
        1662usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(beacon_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tsf) as usize - ptr as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_auth_info),
            "::",
            stringify!(tsf)
        )
    );
}
#[doc = " @brief This structure defines a command used to send an authentication request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_auth {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information to be passed in the authentication command @ref nrf_wifi_umac_auth_info"]
    pub info: nrf_wifi_umac_auth_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_auth() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_auth> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_auth>(),
        1712usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_auth))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_auth>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_auth))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_auth),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_auth),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_auth),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure specifies the parameters to be used when sending an association request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_assoc_info {
    #[doc = " Frequency of the selected channel in MHz"]
    pub center_frequency: ::core::ffi::c_uint,
    #[doc = " ssid @ref nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " MAC address (various uses)"]
    pub nrf_wifi_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = "  WPA information element data. @ref nrf_wifi_ie"]
    pub wpa_ie: nrf_wifi_ie,
    #[doc = " Whether management frame protection (IEEE 802.11w) is used for the association"]
    pub use_mfp: ::core::ffi::c_uchar,
    #[doc = " Indicating whether user space controls IEEE 802.1X port. If set, the RPU will\n  assume that the port is unauthorized until authorized by user space.\n  Otherwise, port is marked authorized by default in station mode."]
    pub control_port: ::core::ffi::c_schar,
    #[doc = " Previous BSSID used in flag"]
    pub prev_bssid_flag: ::core::ffi::c_uint,
    #[doc = " Previous BSSID used in Re-assoc."]
    pub prev_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = " Bss max idle timeout value in sec wich will be encapsulated into\n  BSS MAX IDLE IE in assoc request frame."]
    pub bss_max_idle_time: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_assoc_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_assoc_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_assoc_info>(),
        459usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_assoc_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_assoc_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_assoc_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(center_frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_bssid) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(nrf_wifi_bssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wpa_ie) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(wpa_ie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_mfp) as usize - ptr as usize },
        445usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(use_mfp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_port) as usize - ptr as usize },
        446usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(control_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_bssid_flag) as usize - ptr as usize },
        447usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(prev_bssid_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_bssid) as usize - ptr as usize },
        451usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(prev_bssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bss_max_idle_time) as usize - ptr as usize },
        457usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_assoc_info),
            "::",
            stringify!(bss_max_idle_time)
        )
    );
}
#[doc = " @brief This structure specifies the parameters to be used when sending an association request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_assoc {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " @ref nrf_wifi_connect_common_info"]
    pub connect_common_info: nrf_wifi_connect_common_info,
    #[doc = " Previous BSSID, to be used by in ASSOCIATE commands to specify\n using a reassociate frame."]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_assoc() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_assoc> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_assoc>(),
        1609usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_assoc))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_assoc>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_assoc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_assoc),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_assoc),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connect_common_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_assoc),
            "::",
            stringify!(connect_common_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        1603usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_assoc),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure specifies the parameters to be passed while sending a\n  deauthentication request (NRF_WIFI_UMAC_CMD_DEAUTHENTICATE).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_disconn_info {
    #[doc = " Indicates that a command is requesting a local deauthentication/disassociation\n  state change without invoking actual management frame exchange."]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Reason code for disassociation or deauthentication"]
    pub reason_code: ::core::ffi::c_ushort,
    #[doc = " MAC address (various uses)"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_disconn_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_disconn_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_disconn_info>(),
        10usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_disconn_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_disconn_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_disconn_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_disconn_info),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason_code) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_disconn_info),
            "::",
            stringify!(reason_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_disconn_info),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure specifies the parameters to be used when sending a disconnect request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_disconn {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " @ref nrf_wifi_umac_disconn_info"]
    pub info: nrf_wifi_umac_disconn_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_disconn() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_disconn> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_disconn>(),
        50usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_disconn))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_disconn>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_disconn))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_disconn),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_disconn),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_disconn),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure contains the information to be passed to the RPU\n  to create a new virtual interface using the NRF_WIFI_UMAC_CMD_NEW_INTERFACE command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_add_vif_info {
    #[doc = " Interface type, see enum nrf_wifi_sys_iftype"]
    pub iftype: ::core::ffi::c_int,
    #[doc = " Use 4-address frames on a virtual interface"]
    pub nrf_wifi_use_4addr: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub mon_flags: ::core::ffi::c_uint,
    #[doc = " MAC Address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_add_vif_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_add_vif_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_add_vif_info>(),
        34usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_add_vif_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_add_vif_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_add_vif_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iftype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_vif_info),
            "::",
            stringify!(iftype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_use_4addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_vif_info),
            "::",
            stringify!(nrf_wifi_use_4addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_vif_info),
            "::",
            stringify!(mon_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_vif_info),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifacename) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_vif_info),
            "::",
            stringify!(ifacename)
        )
    );
}
#[doc = " @brief This structure defines a command used to create a new virtual interface\n  using the NRF_WIFI_UMAC_CMD_NEW_INTERFACE command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_add_vif {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " VIF specific information to be passed to the RPU @ref nrf_wifi_umac_add_vif_info"]
    pub info: nrf_wifi_umac_add_vif_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_add_vif() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_add_vif> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_add_vif>(),
        74usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_add_vif))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_add_vif>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_add_vif))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_add_vif),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_add_vif),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_add_vif),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure defines a command used to delete a virtual interface.\n  However, this command is not allowed on the default interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_del_vif {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_del_vif() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_del_vif> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_del_vif>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_del_vif))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_del_vif>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_del_vif))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_del_vif),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure represents the data of management frame that must be matched for\n  processing in userspace.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_frame_match {
    #[doc = " Length of data"]
    pub frame_match_len: ::core::ffi::c_uint,
    #[doc = " Data to match"]
    pub frame_match: [::core::ffi::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_frame_match() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_frame_match> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_frame_match>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_frame_match))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_frame_match>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_frame_match))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_match_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_frame_match),
            "::",
            stringify!(frame_match_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_match) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_frame_match),
            "::",
            stringify!(frame_match)
        )
    );
}
#[doc = " @brief This structure contains information about the type of management frame\n  that should be passed to the driver for processing in userspace.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_mgmt_frame_info {
    #[doc = " Frame type/subtype"]
    pub frame_type: ::core::ffi::c_ushort,
    #[doc = " Match information Refer &struct nrf_wifi_umac_frame_match"]
    pub frame_match: nrf_wifi_umac_frame_match,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_mgmt_frame_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_mgmt_frame_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_mgmt_frame_info>(),
        14usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_mgmt_frame_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_mgmt_frame_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_mgmt_frame_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_frame_info),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_match) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_frame_info),
            "::",
            stringify!(frame_match)
        )
    );
}
#[doc = " @brief This structure defines a command to inform the RPU to register a management frame,\n  which must not be filtered by the RPU and should instead be passed to the host for\n  userspace processing.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_mgmt_frame_reg {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Management frame specific information to be passed to the RPU.\n @ref nrf_wifi_umac_mgmt_frame_info"]
    pub info: nrf_wifi_umac_mgmt_frame_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_mgmt_frame_reg() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_mgmt_frame_reg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_mgmt_frame_reg>(),
        50usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_mgmt_frame_reg))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_mgmt_frame_reg>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_mgmt_frame_reg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_mgmt_frame_reg),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_mgmt_frame_reg),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents command to add a new key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_key {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Key information. @ref nrf_wifi_umac_key_info"]
    pub key_info: nrf_wifi_umac_key_info,
    #[doc = " MAC address associated with the key"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_key() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_key> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_key>(),
        581usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_key))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_key>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_key),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_key),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_key),
            "::",
            stringify!(key_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        575usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_key),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure defines a command that is used to add a new key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_key {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Key information , @ref nrf_wifi_umac_key_info"]
    pub key_info: nrf_wifi_umac_key_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_key() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_key> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_key>(),
        571usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_set_key))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_key>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_set_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_key),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_key),
            "::",
            stringify!(key_info)
        )
    );
}
#[doc = " @brief This structure contains parameters that describe the BSS (Basic Service Set) information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_bss_info {
    #[doc = " P2P GO Client Traffic Window, used with\n  the START_AP and SET_BSS commands."]
    pub p2p_go_ctwindow: ::core::ffi::c_uint,
    #[doc = " P2P GO opportunistic PS, used with the\n  START_AP and SET_BSS commands. This can have the values 0 or 1;\n  if not given in START_AP 0 is assumed, if not given in SET_BSS\n  no change is made."]
    pub p2p_opp_ps: ::core::ffi::c_uint,
    #[doc = " Number of basic rate elements"]
    pub num_basic_rates: ::core::ffi::c_uint,
    #[doc = " HT operation mode"]
    pub ht_opmode: ::core::ffi::c_ushort,
    #[doc = " Whether CTS protection is enabled (0 or 1)"]
    pub nrf_wifi_cts: ::core::ffi::c_uchar,
    #[doc = " Whether short preamble is enabled (0 or 1)"]
    pub preamble: ::core::ffi::c_uchar,
    #[doc = " Whether short slot time enabled (0 or 1)"]
    pub nrf_wifi_slot: ::core::ffi::c_uchar,
    #[doc = " (AP mode) Do not forward traffic between stations connected to this BSS"]
    pub ap_isolate: ::core::ffi::c_uchar,
    #[doc = " Basic rates, array of basic rates in format defined by IEEE 802.11 7.3.2.2"]
    pub basic_rates: [::core::ffi::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_bss_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_bss_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_bss_info>(),
        50usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_bss_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_bss_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_bss_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p2p_go_ctwindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(p2p_go_ctwindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p2p_opp_ps) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(p2p_opp_ps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_basic_rates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(num_basic_rates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ht_opmode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(ht_opmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_cts) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(nrf_wifi_cts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).preamble) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(preamble)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_slot) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(nrf_wifi_slot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ap_isolate) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(ap_isolate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).basic_rates) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_bss_info),
            "::",
            stringify!(basic_rates)
        )
    );
}
#[doc = " @brief This structure represents a command used to set BSS (Basic Service Set) parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_bss {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " BSS specific information to be passed to the RPU @ref nrf_wifi_umac_bss_info"]
    pub bss_info: nrf_wifi_umac_bss_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_bss() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_bss> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_bss>(),
        90usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_set_bss))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_bss>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_set_bss))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_bss),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_bss),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bss_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_bss),
            "::",
            stringify!(bss_info)
        )
    );
}
#[doc = " @brief This structure contains information about frequency parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct freq_params {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Value in MHz"]
    pub frequency: ::core::ffi::c_int,
    #[doc = " Width of the channel @see &enu nrf_wifi_chan_width"]
    pub channel_width: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub center_frequency1: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub center_frequency2: ::core::ffi::c_int,
    #[doc = " Type of channel see &enum nrf_wifi_channel_type"]
    pub channel_type: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_freq_params() {
    const UNINIT: ::core::mem::MaybeUninit<freq_params> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<freq_params>(),
        24usize,
        concat!("Size of: ", stringify!(freq_params))
    );
    assert_eq!(
        ::core::mem::align_of::<freq_params>(),
        1usize,
        concat!("Alignment of ", stringify!(freq_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(freq_params),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(freq_params),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(freq_params),
            "::",
            stringify!(channel_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(freq_params),
            "::",
            stringify!(center_frequency1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(freq_params),
            "::",
            stringify!(center_frequency2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(freq_params),
            "::",
            stringify!(channel_type)
        )
    );
}
#[doc = " @brief This structure contains information about transmit queue parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_txq_params {
    #[doc = " Transmit oppurtunity"]
    pub txop: ::core::ffi::c_ushort,
    #[doc = " Minimum contention window"]
    pub cwmin: ::core::ffi::c_ushort,
    #[doc = " Maximum contention window"]
    pub cwmax: ::core::ffi::c_ushort,
    #[doc = " Arbitration interframe spacing"]
    pub aifs: ::core::ffi::c_uchar,
    #[doc = " Access category"]
    pub ac: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_txq_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_txq_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_txq_params>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_txq_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_txq_params>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_txq_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_txq_params),
            "::",
            stringify!(txop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cwmin) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_txq_params),
            "::",
            stringify!(cwmin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cwmax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_txq_params),
            "::",
            stringify!(cwmax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aifs) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_txq_params),
            "::",
            stringify!(aifs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ac) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_txq_params),
            "::",
            stringify!(ac)
        )
    );
}
#[repr(u32)]
#[doc = " @brief Types of transmit power settings.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_tx_power_type {
    #[doc = " Automatically determine transmit power"]
    NRF_WIFI_TX_POWER_AUTOMATIC = 0,
    #[doc = " Limit TX power by the mBm parameter"]
    NRF_WIFI_TX_POWER_LIMITED = 1,
    #[doc = " Fix TX power to the mBm parameter"]
    NRF_WIFI_TX_POWER_FIXED = 2,
}
#[doc = " @brief This structure contains the parameters related to the transmit power setting.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_power_setting {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Power value type, see nrf_wifi_tx_power_type"]
    pub type_: ::core::ffi::c_int,
    #[doc = " Transmit power level in signed mBm units"]
    pub tx_power_level: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_tx_power_setting() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_tx_power_setting> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_tx_power_setting>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_tx_power_setting))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_tx_power_setting>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_tx_power_setting))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_power_setting),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_power_setting),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_tx_power_setting),
            "::",
            stringify!(tx_power_level)
        )
    );
}
#[doc = " @brief This structure contains information about the configuration parameters\n  needed to set up and configure the wireless Physical Layer.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_set_wiphy_info {
    #[doc = " RTS threshold, TX frames with length larger than or equal to this use RTS/CTS handshake\n  allowed range: 0..65536, disable with -1."]
    pub rts_threshold: ::core::ffi::c_uint,
    #[doc = " Fragmentation threshold, maximum length in octets for frames.\n  allowed range: 256..8000, disable fragmentation with (u32)-1."]
    pub frag_threshold: ::core::ffi::c_uint,
    #[doc = " Bitmap of allowed antennas for transmitting. This can be used to mask out\n  antennas which are not attached or should not be used for transmitting.\n  If an antenna is not selected in this bitmap the hardware is not allowed\n  to transmit on this antenna."]
    pub antenna_tx: ::core::ffi::c_uint,
    #[doc = " Bitmap of allowed antennas for receiving. This can be used to mask out antennas\n  which are not attached or should not be used for receiving. If an antenna is\n  not selected in this bitmap the hardware should not be configured to receive\n  on this antenna."]
    pub antenna_rx: ::core::ffi::c_uint,
    #[doc = " Frequency information of the a channel see &struct freq_params"]
    pub freq_params: freq_params,
    #[doc = " TX queue parameters @ref nrf_wifi_txq_params"]
    pub txq_params: nrf_wifi_txq_params,
    #[doc = " Tx power settings @ref nrf_wifi_tx_power_setting @ref nrf_wifi_tx_power_setting"]
    pub tx_power_setting: nrf_wifi_tx_power_setting,
    #[doc = " TX retry limit for frames whose length is less than or equal to the RTS threshold\n  allowed range: 1..255."]
    pub retry_short: ::core::ffi::c_uchar,
    #[doc = " TX retry limit for frames whose length is greater than the RTS threshold\n  allowed range: 1..255."]
    pub retry_long: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub coverage_class: ::core::ffi::c_uchar,
    #[doc = " WIPHY name (used for renaming)"]
    pub wiphy_name: [::core::ffi::c_schar; 32usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_set_wiphy_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_set_wiphy_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_set_wiphy_info>(),
        95usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_set_wiphy_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_set_wiphy_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_set_wiphy_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rts_threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(rts_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frag_threshold) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(frag_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).antenna_tx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(antenna_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).antenna_rx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(antenna_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_params) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(freq_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txq_params) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(txq_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power_setting) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(tx_power_setting)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retry_short) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(retry_short)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retry_long) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(retry_long)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coverage_class) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(coverage_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wiphy_name) as usize - ptr as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_wiphy_info),
            "::",
            stringify!(wiphy_name)
        )
    );
}
#[doc = " @brief This structure defines the command to set the wireless PHY configuration.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_wiphy {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicates which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " @ref nrf_wifi_umac_set_wiphy_info"]
    pub info: nrf_wifi_umac_set_wiphy_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_wiphy() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_wiphy> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_wiphy>(),
        135usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_set_wiphy))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_wiphy>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_set_wiphy))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_wiphy),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_wiphy),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_wiphy),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure contains the parameters to delete a station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_del_sta_info {
    #[doc = " MAC address of the station"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Management frame subtype"]
    pub mgmt_subtype: ::core::ffi::c_uchar,
    #[doc = " Reason code for DEAUTHENTICATION and DISASSOCIATION"]
    pub reason_code: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_del_sta_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_del_sta_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_del_sta_info>(),
        9usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_del_sta_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_del_sta_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_del_sta_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_del_sta_info),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mgmt_subtype) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_del_sta_info),
            "::",
            stringify!(mgmt_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason_code) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_del_sta_info),
            "::",
            stringify!(reason_code)
        )
    );
}
#[doc = " @brief This structure defines the command to delete a station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_del_sta {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information regarding the station to be deleted @ref nrf_wifi_umac_del_sta_info"]
    pub info: nrf_wifi_umac_del_sta_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_del_sta() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_del_sta> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_del_sta>(),
        49usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_del_sta))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_del_sta>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_del_sta))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_del_sta),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_del_sta),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_del_sta),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure contains the information required for obtaining station details.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_get_sta_info {
    #[doc = " MAC address of the station"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_get_sta_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_get_sta_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_get_sta_info>(),
        6usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_get_sta_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_get_sta_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_get_sta_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_get_sta_info),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure defines the command to get station information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_sta {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Information regarding the station to get @ref nrf_wifi_umac_get_sta_info"]
    pub info: nrf_wifi_umac_get_sta_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_get_sta() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_get_sta> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_get_sta>(),
        42usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_get_sta))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_get_sta>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_get_sta))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_sta),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_sta),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief Extended capability information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ext_capability {
    #[doc = " length"]
    pub ext_capability_len: ::core::ffi::c_uint,
    #[doc = " Extended capability info"]
    pub ext_capability: [::core::ffi::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_ext_capability() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_ext_capability> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_ext_capability>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_ext_capability))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_ext_capability>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_ext_capability))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_capability_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ext_capability),
            "::",
            stringify!(ext_capability_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_capability) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_ext_capability),
            "::",
            stringify!(ext_capability)
        )
    );
}
#[doc = " @brief Supported channels."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_supported_channels {
    #[doc = " number of channels"]
    pub supported_channels_len: ::core::ffi::c_uint,
    #[doc = " channels info"]
    pub supported_channels: [::core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_supported_channels() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_supported_channels> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_supported_channels>(),
        68usize,
        concat!("Size of: ", stringify!(nrf_wifi_supported_channels))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_supported_channels>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_supported_channels))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_channels_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supported_channels),
            "::",
            stringify!(supported_channels_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supported_channels),
            "::",
            stringify!(supported_channels)
        )
    );
}
#[doc = " @brief Operating classes information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_supported_oper_classes {
    #[doc = " length"]
    pub supported_oper_classes_len: ::core::ffi::c_uint,
    #[doc = " oper_class info"]
    pub supported_oper_classes: [::core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_supported_oper_classes() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_supported_oper_classes> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_supported_oper_classes>(),
        68usize,
        concat!("Size of: ", stringify!(nrf_wifi_supported_oper_classes))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_supported_oper_classes>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_supported_oper_classes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_oper_classes_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supported_oper_classes),
            "::",
            stringify!(supported_oper_classes_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_oper_classes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_supported_oper_classes),
            "::",
            stringify!(supported_oper_classes)
        )
    );
}
#[doc = " @brief Station flags."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_flags2 {
    #[doc = " length"]
    pub sta_flags2_len: ::core::ffi::c_uint,
    #[doc = " flags"]
    pub sta_flags2: [::core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_sta_flags2() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_sta_flags2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_sta_flags2>(),
        68usize,
        concat!("Size of: ", stringify!(nrf_wifi_sta_flags2))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_sta_flags2>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_sta_flags2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_flags2_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_flags2),
            "::",
            stringify!(sta_flags2_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_flags2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_sta_flags2),
            "::",
            stringify!(sta_flags2)
        )
    );
}
#[doc = " @brief This structure represents the information needed to update a station entry\n in the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_chg_sta_info {
    #[doc = " Listen interval as defined by IEEE 802.11 7.3.1.6"]
    pub nrf_wifi_listen_interval: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub sta_vlan: ::core::ffi::c_uint,
    #[doc = " AID or zero for no change"]
    pub aid: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub nrf_wifi_peer_aid: ::core::ffi::c_ushort,
    #[doc = " Station capability"]
    pub sta_capability: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub spare: ::core::ffi::c_ushort,
    #[doc = " Supported rates in IEEE 802.11 format @ref nrf_wifi_supp_rates"]
    pub supp_rates: nrf_wifi_supp_rates,
    #[doc = " Extended capabilities of the station @ref nrf_wifi_ext_capability"]
    pub ext_capability: nrf_wifi_ext_capability,
    #[doc = " Supported channels in IEEE 802.11 format @ref nrf_wifi_supported_channels"]
    pub supported_channels: nrf_wifi_supported_channels,
    #[doc = " Supported oper classes in IEEE 802.11 format @ref nrf_wifi_supported_oper_classes"]
    pub supported_oper_classes: nrf_wifi_supported_oper_classes,
    #[doc = " station flags mask/set @ref nrf_wifi_sta_flag_update @ref nrf_wifi_sta_flag_update"]
    pub sta_flags2: nrf_wifi_sta_flag_update,
    #[doc = " HT capabilities of station"]
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " VHT capabilities of station"]
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Station mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Information if operating mode field is used"]
    pub opmode_notif: ::core::ffi::c_uchar,
    #[doc = " Bitmap of queues configured for uapsd. Same format\n  as the AC bitmap in the QoS info field."]
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    #[doc = " Max Service Period. same format as the MAX_SP in the\n  QoS info field (but already shifted down)."]
    pub wme_max_sp: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_chg_sta_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_chg_sta_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_chg_sta_info>(),
        789usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_chg_sta_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_chg_sta_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_chg_sta_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_listen_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(nrf_wifi_listen_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_vlan) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(sta_vlan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(aid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_peer_aid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(nrf_wifi_peer_aid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_capability) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(sta_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spare) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(spare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supp_rates) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(supp_rates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_capability) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(ext_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_channels) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(supported_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_oper_classes) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(supported_oper_classes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_flags2) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(sta_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ht_capability) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(ht_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_capability) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(vht_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opmode_notif) as usize - ptr as usize },
        786usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(opmode_notif)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wme_uapsd_queues) as usize - ptr as usize },
        787usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(wme_uapsd_queues)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wme_max_sp) as usize - ptr as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_sta_info),
            "::",
            stringify!(wme_max_sp)
        )
    );
}
#[doc = " @brief This structure defines the command for updating the parameters of a station entry.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_chg_sta {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " @ref nrf_wifi_umac_chg_sta_info"]
    pub info: nrf_wifi_umac_chg_sta_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_chg_sta() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_chg_sta> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_chg_sta>(),
        829usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_chg_sta))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_chg_sta>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_chg_sta))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_sta),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_sta),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_sta),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure describes the parameters for adding a new station entry to the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_add_sta_info {
    #[doc = " Listen interval as defined by IEEE 802.11 7.3.1.6"]
    pub nrf_wifi_listen_interval: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub sta_vlan: ::core::ffi::c_uint,
    #[doc = " AID or zero for no change"]
    pub aid: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub nrf_wifi_peer_aid: ::core::ffi::c_ushort,
    #[doc = " Station capability"]
    pub sta_capability: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub spare: ::core::ffi::c_ushort,
    #[doc = " Supported rates in IEEE 802.11 format @ref nrf_wifi_supp_rates"]
    pub supp_rates: nrf_wifi_supp_rates,
    #[doc = " Extended capabilities of the station @ref nrf_wifi_ext_capability"]
    pub ext_capability: nrf_wifi_ext_capability,
    #[doc = " Supported channels in IEEE 802.11 format @ref nrf_wifi_supported_channels"]
    pub supported_channels: nrf_wifi_supported_channels,
    #[doc = " Supported oper classes in IEEE 802.11 format @ref nrf_wifi_supported_oper_classes"]
    pub supported_oper_classes: nrf_wifi_supported_oper_classes,
    #[doc = " station flags mask/set @ref nrf_wifi_sta_flag_update"]
    pub sta_flags2: nrf_wifi_sta_flag_update,
    #[doc = " HT capabilities of station"]
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " VHT capabilities of station"]
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Station mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Information if operating mode field is used"]
    pub opmode_notif: ::core::ffi::c_uchar,
    #[doc = " Bitmap of queues configured for uapsd. same format\n  as the AC bitmap in the QoS info field."]
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    #[doc = " Max Service Period. same format as the MAX_SP in the\n  QoS info field (but already shifted down)."]
    pub wme_max_sp: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_add_sta_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_add_sta_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_add_sta_info>(),
        789usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_add_sta_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_add_sta_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_add_sta_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_listen_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(nrf_wifi_listen_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_vlan) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(sta_vlan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(aid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_peer_aid) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(nrf_wifi_peer_aid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_capability) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(sta_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spare) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(spare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supp_rates) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(supp_rates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_capability) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(ext_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_channels) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(supported_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_oper_classes) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(supported_oper_classes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_flags2) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(sta_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ht_capability) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(ht_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_capability) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(vht_capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opmode_notif) as usize - ptr as usize },
        786usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(opmode_notif)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wme_uapsd_queues) as usize - ptr as usize },
        787usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(wme_uapsd_queues)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wme_max_sp) as usize - ptr as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_add_sta_info),
            "::",
            stringify!(wme_max_sp)
        )
    );
}
#[doc = " @brief This structure defines the command for adding a new station entry.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_add_sta {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " @ref nrf_wifi_umac_add_sta_info"]
    pub info: nrf_wifi_umac_add_sta_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_add_sta() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_add_sta> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_add_sta>(),
        829usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_add_sta))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_add_sta>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_add_sta))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_add_sta),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_add_sta),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_add_sta),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure describes the parameters required to be passed to the RPU when\n  initiating a SoftAP (Soft Access Point).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_start_ap_info {
    #[doc = " Beacon frame interval"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " DTIM count"]
    pub dtim_period: ::core::ffi::c_uchar,
    #[doc = " Send beacons with wildcard sssid"]
    pub hidden_ssid: ::core::ffi::c_int,
    #[doc = " Authentication type, see &enum nrf_wifi_auth_type"]
    pub auth_type: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub smps_mode: ::core::ffi::c_int,
    #[doc = " Beacon info flags"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Beacon frame, @ref nrf_wifi_beacon_data"]
    pub beacon_data: nrf_wifi_beacon_data,
    #[doc = " SSID string, @ref nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " Connect params, @ref nrf_wifi_connect_common_info"]
    pub connect_common_info: nrf_wifi_connect_common_info,
    #[doc = " Channel info, see &struct freq_params"]
    pub freq_params: freq_params,
    #[doc = " Time to stop ap after inactivity period"]
    pub inactivity_timeout: ::core::ffi::c_ushort,
    #[doc = " P2P GO Client Traffic Window"]
    pub p2p_go_ctwindow: ::core::ffi::c_uchar,
    #[doc = " Opportunistic power save allows P2P Group Owner to save power\n  when all its associated clients are sleeping."]
    pub p2p_opp_ps: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_start_ap_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_start_ap_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_start_ap_info>(),
        2823usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_start_ap_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_start_ap_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_start_ap_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(beacon_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dtim_period) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(dtim_period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hidden_ssid) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(hidden_ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_type) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(auth_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smps_mode) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(smps_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_data) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(beacon_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        1199usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connect_common_info) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(connect_common_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_params) as usize - ptr as usize },
        2795usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(freq_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inactivity_timeout) as usize - ptr as usize },
        2819usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(inactivity_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p2p_go_ctwindow) as usize - ptr as usize },
        2821usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(p2p_go_ctwindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p2p_opp_ps) as usize - ptr as usize },
        2822usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_start_ap_info),
            "::",
            stringify!(p2p_opp_ps)
        )
    );
}
#[doc = " @brief This structure defines the command for starting the SoftAP using\n  NRF_WIFI_UMAC_CMD_NEW_BEACON and NRF_WIFI_UMAC_CMD_START_AP.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_start_ap {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Parameters that need to be passed to the RPU when starting a SoftAP.\n  @ref nrf_wifi_umac_start_ap_info"]
    pub info: nrf_wifi_umac_start_ap_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_start_ap() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_start_ap> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_start_ap>(),
        2863usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_start_ap))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_start_ap>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_start_ap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_start_ap),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_start_ap),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_start_ap),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure defines the command used to stop Soft AP operation.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_stop_ap {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_stop_ap() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_stop_ap> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_stop_ap>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_stop_ap))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_stop_ap>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_stop_ap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_stop_ap),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure represents the parameters that must be passed to the RPU when\n  configuring Beacon and Probe response data.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_set_beacon_info {
    #[doc = " Beacon frame, @ref nrf_wifi_beacon_data"]
    pub beacon_data: nrf_wifi_beacon_data,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_set_beacon_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_set_beacon_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_set_beacon_info>(),
        1180usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_set_beacon_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_set_beacon_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_set_beacon_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_beacon_info),
            "::",
            stringify!(beacon_data)
        )
    );
}
#[doc = " @brief This structure defines the command for setting the beacon data using\n  NRF_WIFI_UMAC_CMD_SET_BEACON.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_beacon {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref nrf_wifi_umac_set_beacon_info"]
    pub info: nrf_wifi_umac_set_beacon_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_beacon() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_beacon> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_beacon>(),
        1216usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_set_beacon))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_beacon>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_set_beacon))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_beacon),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_beacon),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure contains the information that needs to be provided to the RPU\n  when modifying the attributes of a virtual interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_chg_vif_attr_info {
    #[doc = " Interface type, see &enum nrf_wifi_iftype"]
    pub iftype: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub nrf_wifi_use_4addr: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_chg_vif_attr_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_chg_vif_attr_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_chg_vif_attr_info>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_chg_vif_attr_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_chg_vif_attr_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_chg_vif_attr_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iftype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_vif_attr_info),
            "::",
            stringify!(iftype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_use_4addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_vif_attr_info),
            "::",
            stringify!(nrf_wifi_use_4addr)
        )
    );
}
#[doc = " @brief This structure defines the command used to change the interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_chg_vif_attr {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Interface attributes to be changed @ref nrf_wifi_umac_chg_vif_attr_info"]
    pub info: nrf_wifi_umac_chg_vif_attr_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_chg_vif_attr() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_chg_vif_attr> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_chg_vif_attr>(),
        48usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_chg_vif_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_chg_vif_attr>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_chg_vif_attr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_vif_attr),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_vif_attr),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_vif_attr),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure contains the information that needs to be passed to the RPU\n  when changing the interface state, specifically when bringing it up or down\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_chg_vif_state_info {
    #[doc = " Interface state (1 = UP / 0 = DOWN)"]
    pub state: ::core::ffi::c_int,
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_chg_vif_state_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_chg_vif_state_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_chg_vif_state_info>(),
        20usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_chg_vif_state_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_chg_vif_state_info>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_chg_vif_state_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_vif_state_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifacename) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_chg_vif_state_info),
            "::",
            stringify!(ifacename)
        )
    );
}
#[doc = " @brief This structure defines the command used to change the interface state.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_chg_vif_state {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref nrf_wifi_umac_chg_vif_state_info"]
    pub info: nrf_wifi_umac_chg_vif_state_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_chg_vif_state() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_chg_vif_state> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_chg_vif_state>(),
        56usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_chg_vif_state))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_chg_vif_state>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_chg_vif_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_vif_state),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_chg_vif_state),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure defines an event-to-command mapping for NRF_WIFI_UMAC_CMD_SET_IFFLAGS.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_vif_state {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Status to command NRF_WIFI_UMAC_CMD_SET_IFFLAGS"]
    pub status: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_vif_state() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_vif_state> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_vif_state>(),
        40usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_vif_state))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_vif_state>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_vif_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_vif_state),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_vif_state),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " @brief This structure defines the command used to start P2P (Peer-to-Peer) mode on an interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_start_p2p {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_start_p2p() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_start_p2p> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_start_p2p>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_start_p2p))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_start_p2p>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_start_p2p))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_start_p2p),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure represents the command for stopping P2P mode on an interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_stop_p2p_dev {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_stop_p2p_dev() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_stop_p2p_dev> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_stop_p2p_dev>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_stop_p2p_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_stop_p2p_dev>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_stop_p2p_dev))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_stop_p2p_dev),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure describes the parameters required to transmit a\n  management frame from the host.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_mgmt_tx_info {
    #[doc = " OFFCHANNEL_TX_OK, NO_CCK_RATE, DONT_WAIT_FOR_ACK"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Channel frequency"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Duration field value"]
    pub dur: ::core::ffi::c_uint,
    #[doc = " Management frame to transmit, @ref nrf_wifi_frame"]
    pub frame: nrf_wifi_frame,
    #[doc = " Frequency configuration, see &struct freq_params"]
    pub freq_params: freq_params,
    #[doc = " Identifier to be used for processing event,\n  NRF_WIFI_UMAC_EVENT_FRAME_TX_STATUS."]
    pub host_cookie: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_mgmt_tx_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_mgmt_tx_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_mgmt_tx_info>(),
        448usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_mgmt_tx_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_mgmt_tx_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_mgmt_tx_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_tx_info),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_tx_info),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dur) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_tx_info),
            "::",
            stringify!(dur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_tx_info),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_params) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_tx_info),
            "::",
            stringify!(freq_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_cookie) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_mgmt_tx_info),
            "::",
            stringify!(host_cookie)
        )
    );
}
#[doc = " @brief This structure defines the command used to transmit a management frame.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_mgmt_tx {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information about the management frame to be transmitted.\n  @ref nrf_wifi_umac_mgmt_tx_info"]
    pub info: nrf_wifi_umac_mgmt_tx_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_mgmt_tx() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_mgmt_tx> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_mgmt_tx>(),
        488usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_mgmt_tx))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_mgmt_tx>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_mgmt_tx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_mgmt_tx),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_mgmt_tx),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_mgmt_tx),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the information regarding the power save state.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_set_power_save_info {
    #[doc = " power save is disabled or enabled, see enum nrf_wifi_ps_state"]
    pub ps_state: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_set_power_save_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_set_power_save_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_set_power_save_info>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_set_power_save_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_set_power_save_info>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_set_power_save_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ps_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_set_power_save_info),
            "::",
            stringify!(ps_state)
        )
    );
}
#[doc = " @brief This structure represents the command used to enable or disable the power save\n  functionality.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_power_save {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Power save setting parameters.\n @ref nrf_wifi_umac_set_power_save_info"]
    pub info: nrf_wifi_umac_set_power_save_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_power_save() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_power_save> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_power_save>(),
        40usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_set_power_save))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_power_save>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_set_power_save)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_power_save),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_power_save),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the command to configure power save timeout value.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_power_save_timeout {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Timeout value in milli seconds\n if timeout < 0 RPU will set timeout to 100ms"]
    pub timeout: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_power_save_timeout() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_power_save_timeout> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_power_save_timeout>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(nrf_wifi_umac_cmd_set_power_save_timeout)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_power_save_timeout>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_set_power_save_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_power_save_timeout),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_power_save_timeout),
            "::",
            stringify!(timeout)
        )
    );
}
#[doc = " @brief This structure represents the information of qos_map.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_qos_map_info {
    #[doc = " length of qos_map info field"]
    pub qos_map_info_len: ::core::ffi::c_uint,
    #[doc = " contains qos_map info as received from stack"]
    pub qos_map_info: [::core::ffi::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_qos_map_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_qos_map_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_qos_map_info>(),
        260usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_qos_map_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_qos_map_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_qos_map_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qos_map_info_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_qos_map_info),
            "::",
            stringify!(qos_map_info_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qos_map_info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_qos_map_info),
            "::",
            stringify!(qos_map_info)
        )
    );
}
#[doc = " @brief This structure represents the information related to the Quality of Service (QoS) map.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_qos_map {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " qos map info. @ref nrf_wifi_umac_qos_map_info"]
    pub info: nrf_wifi_umac_qos_map_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_qos_map() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_qos_map> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_qos_map>(),
        296usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_set_qos_map))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_qos_map>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_set_qos_map))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_qos_map),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_qos_map),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure defines the command used to retrieve the transmit power information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_tx_power {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_get_tx_power() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_get_tx_power> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_get_tx_power>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_get_tx_power))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_get_tx_power>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_get_tx_power))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_tx_power),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure defines the command used to obtain the regulatory domain information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_reg {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_get_reg() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_get_reg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_get_reg>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_get_reg))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_get_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_get_reg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_reg),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure defines the command used to retrieve channel information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_channel {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_get_channel() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_get_channel> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_get_channel>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_get_channel))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_get_channel>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_get_channel))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_channel),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[repr(u32)]
#[doc = " @brief TWT setup commands and events.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_twt_setup_cmd_type {
    #[doc = " STA requests to join a TWT without specifying a target wake time"]
    NRF_WIFI_REQUEST_TWT = 0,
    #[doc = " STA requests to join a TWT with specifying a target wake time and\n  other params, these values can change during negotiation."]
    NRF_WIFI_SUGGEST_TWT = 1,
    #[doc = " requests to join a TWT with demanded a target wake time\n and other params. STA rejects if AP not scheduling those params."]
    NRF_WIFI_DEMAND_TWT = 2,
    #[doc = " Response to the STA request(suggest/demand), these may be different params"]
    NRF_WIFI_GROUPING_TWT = 3,
    #[doc = " AP accept the STA requested params"]
    NRF_WIFI_ACCEPT_TWT = 4,
    #[doc = " AP may suggest the params, these may be different from STA requested"]
    NRF_WIFI_ALTERNATE_TWT = 5,
    #[doc = " AP may suggest the params, these may be different from STA requested"]
    NRF_WIFI_DICTATE_TWT = 6,
    #[doc = " AP may reject the STA requested params"]
    NRF_WIFI_REJECT_TWT = 7,
}
#[doc = " @brief This structure describes the TWT information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_config_twt_info {
    #[doc = " TWT flow Id"]
    pub twt_flow_id: ::core::ffi::c_uchar,
    #[doc = " Negotiation type\n  NRF_WIFI_TWT_NEGOTIATION_TYPE_INDIVIDUAL or\n  NRF_WIFI_TWT_NEGOTIATION_TYPE_BROADAST"]
    pub neg_type: ::core::ffi::c_uchar,
    #[doc = " see &enum nrf_wifi_twt_setup_cmd_type"]
    pub setup_cmd: ::core::ffi::c_int,
    #[doc = " indicating AP to initiate a trigger frame (ps_poll/Null) before data transfer"]
    pub ap_trigger_frame: ::core::ffi::c_uchar,
    #[doc = " 1->implicit(same negotiated values to be used),\n  0->AP sends new calculated TWT values for every service period."]
    pub is_implicit: ::core::ffi::c_uchar,
    #[doc = " Whether STA has to send the PS-Poll/Null frame\n  indicating that it's in wake period(NRF_WIFI_TWT_FLOW_TYPE_ANNOUNCED)"]
    pub twt_flow_type: ::core::ffi::c_uchar,
    #[doc = " wake interval exponent value"]
    pub twt_target_wake_interval_exponent: ::core::ffi::c_uchar,
    #[doc = " wake interval mantissa value"]
    pub twt_target_wake_interval_mantissa: ::core::ffi::c_ushort,
    #[doc = " start of the waketime value after successful TWT negotiation"]
    pub target_wake_time: ::core::ffi::c_ulonglong,
    #[doc = " min TWT wake duration"]
    pub nominal_min_twt_wake_duration: ::core::ffi::c_uint,
    #[doc = " dialog_token of twt frame"]
    pub dialog_token: ::core::ffi::c_uchar,
    #[doc = " 0->not received 1->received"]
    pub twt_resp_status: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_config_twt_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_config_twt_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_config_twt_info>(),
        26usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_config_twt_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_config_twt_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_config_twt_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_flow_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(twt_flow_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).neg_type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(neg_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setup_cmd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(setup_cmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ap_trigger_frame) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(ap_trigger_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_implicit) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(is_implicit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_flow_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(twt_flow_type)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).twt_target_wake_interval_exponent) as usize - ptr as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(twt_target_wake_interval_exponent)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).twt_target_wake_interval_mantissa) as usize - ptr as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(twt_target_wake_interval_mantissa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target_wake_time) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(target_wake_time)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nominal_min_twt_wake_duration) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(nominal_min_twt_wake_duration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dialog_token) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(dialog_token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_resp_status) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_config_twt_info),
            "::",
            stringify!(twt_resp_status)
        )
    );
}
#[doc = " @brief This structure defines the parameters required for setting up TWT session.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_config_twt {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " TWT configuration info @ref nrf_wifi_umac_config_twt_info"]
    pub info: nrf_wifi_umac_config_twt_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_config_twt() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_config_twt> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_config_twt>(),
        62usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_config_twt))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_config_twt>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_config_twt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_config_twt),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_config_twt),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the TWT delete information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_teardown_twt_info {
    #[doc = " TWT flow Id"]
    pub twt_flow_id: ::core::ffi::c_uchar,
    #[doc = " reason for teardown"]
    pub reason_code: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_teardown_twt_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_teardown_twt_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_teardown_twt_info>(),
        2usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_teardown_twt_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_teardown_twt_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_teardown_twt_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_flow_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_teardown_twt_info),
            "::",
            stringify!(twt_flow_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason_code) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_teardown_twt_info),
            "::",
            stringify!(reason_code)
        )
    );
}
#[doc = " @brief This structure defines the command used to delete or remove a TWT session\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_teardown_twt {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref nrf_wifi_umac_teardown_twt_info"]
    pub info: nrf_wifi_umac_teardown_twt_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_teardown_twt() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_teardown_twt> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_teardown_twt>(),
        38usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_teardown_twt))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_teardown_twt>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_teardown_twt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_teardown_twt),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_teardown_twt),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the information related to Tx (transmit) block/unblock.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct twt_sleep_info {
    #[doc = " value for blocking/unblocking TX\n  (TWT_BLOCK_TX or TWT_UNBLOCK_TX)"]
    pub type_: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_twt_sleep_info() {
    const UNINIT: ::core::mem::MaybeUninit<twt_sleep_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<twt_sleep_info>(),
        4usize,
        concat!("Size of: ", stringify!(twt_sleep_info))
    );
    assert_eq!(
        ::core::mem::align_of::<twt_sleep_info>(),
        1usize,
        concat!("Alignment of ", stringify!(twt_sleep_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(twt_sleep_info),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " @brief This structure defines an event used to indicate to the host whether to block or\n  unblock Tx (transmit) packets in TWT communication.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_twt_sleep {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref twt_sleep_info"]
    pub info: twt_sleep_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_twt_sleep() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_twt_sleep> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_twt_sleep>(),
        40usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_twt_sleep))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_twt_sleep>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_twt_sleep))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_twt_sleep),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_twt_sleep),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the information about UAPSD queues.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_uapsd_info {
    #[doc = " UAPSD-Q value"]
    pub uapsd_queue: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_uapsd_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_uapsd_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_uapsd_info>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_uapsd_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_uapsd_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_uapsd_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uapsd_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_uapsd_info),
            "::",
            stringify!(uapsd_queue)
        )
    );
}
#[doc = " @brief This structure defines the command used to configure the UAPSD-Q value.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_config_uapsd {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " @ref nrf_wifi_umac_uapsd_info"]
    pub info: nrf_wifi_umac_uapsd_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_config_uapsd() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_config_uapsd> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_config_uapsd>(),
        40usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_config_uapsd))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_config_uapsd>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_config_uapsd))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_config_uapsd),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_config_uapsd),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the event used to indicate that a scan has started.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_trigger_scan {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Scan request control flags (u32). Bit values\n (NRF_WIFI_SCAN_FLAG_LOW_PRIORITY/NRF_WIFI_SCAN_FLAG_RANDOM_ADDR...)"]
    pub nrf_wifi_scan_flags: ::core::ffi::c_uint,
    #[doc = " No.of ssids in scan request"]
    pub num_scan_ssid: ::core::ffi::c_uchar,
    #[doc = " No.of frequencies in scan request"]
    pub num_scan_frequencies: ::core::ffi::c_uchar,
    #[doc = " center frequencies"]
    pub scan_frequencies: [::core::ffi::c_ushort; 64usize],
    #[doc = " @ref nrf_wifi_ssid"]
    pub scan_ssid: [nrf_wifi_ssid; 2usize],
    #[doc = " @ref nrf_wifi_ie"]
    pub ie: nrf_wifi_ie,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_trigger_scan() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_trigger_scan> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_trigger_scan>(),
        642usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_trigger_scan))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_trigger_scan>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_event_trigger_scan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_scan_flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(nrf_wifi_scan_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_scan_ssid) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(num_scan_ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_scan_frequencies) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(num_scan_frequencies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_frequencies) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(scan_frequencies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_ssid) as usize - ptr as usize },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(scan_ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_trigger_scan),
            "::",
            stringify!(ie)
        )
    );
}
#[doc = " @brief This structure serves as a response to the command NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS.\n  It contains scan results for each entry. RPU sends multiple events of this type for every\n  scan entry, and when umac_hdr->seq == 0, it indicates the last scan entry.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_event_new_scan_results {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub generation: ::core::ffi::c_uint,
    #[doc = " Frequency in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Channel width of the control channel"]
    pub chan_width: ::core::ffi::c_uint,
    #[doc = " Age of this BSS entry in ms"]
    pub seen_ms_ago: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Status, if this BSS is \"used\""]
    pub status: ::core::ffi::c_int,
    #[doc = " TSF of the received probe response/beacon (u64)"]
    pub ies_tsf: ::core::ffi::c_ulonglong,
    #[doc = " TSF of the last received beacon\n  (not present if no beacon frame has been received yet)."]
    pub beacon_ies_tsf: ::core::ffi::c_ulonglong,
    #[doc = " Beacon interval of BSS"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " Capability field"]
    pub capability: ::core::ffi::c_ushort,
    #[doc = " Signal strength, @ref nrf_wifi_signal"]
    pub signal: nrf_wifi_signal,
    #[doc = " BSSID of the BSS (6 octets)"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Indicates length of IE's present at the starting of ies[0]"]
    pub ies_len: ::core::ffi::c_uint,
    #[doc = " Indicates length of beacon_ies present after ies+ies_len"]
    pub beacon_ies_len: ::core::ffi::c_uint,
    #[doc = " contains raw information elements from the probe response/beacon.\n If beacon_ies are not present then the IEs here are from a Probe Response\n frame; otherwise they are from a Beacon frame."]
    pub ies: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_new_scan_results() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_new_scan_results> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_new_scan_results>(),
        106usize,
        concat!(
            "Size of: ",
            stringify!(nrf_wifi_umac_event_new_scan_results)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_new_scan_results>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_event_new_scan_results)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(generation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chan_width) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(chan_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seen_ms_ago) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(seen_ms_ago)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ies_tsf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(ies_tsf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_ies_tsf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(beacon_ies_tsf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_interval) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(beacon_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ies_len) as usize - ptr as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(ies_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_ies_len) as usize - ptr as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(beacon_ies_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ies) as usize - ptr as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_results),
            "::",
            stringify!(ies)
        )
    );
}
#[doc = " @brief This structure represents the response for NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS.\n  It contains the displayed scan result.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct umac_display_results {
    #[doc = " Network SSID @ref nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " BSSID of the BSS (6 octets)"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Network band of operation, refer &enum nrf_wifi_band"]
    pub nwk_band: ::core::ffi::c_int,
    #[doc = " Network channel number"]
    pub nwk_channel: ::core::ffi::c_uint,
    #[doc = "  Protocol type (NRF_WIFI_802_11A)"]
    pub protocol_flags: ::core::ffi::c_uchar,
    #[doc = " Network security mode, refer &enum nrf_wifi_security_type"]
    pub security_type: ::core::ffi::c_int,
    #[doc = " Beacon interval of the BSS"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " Capability field"]
    pub capability: ::core::ffi::c_ushort,
    #[doc = " Signal strength. Refer &struct nrf_wifi_signal"]
    pub signal: nrf_wifi_signal,
    #[doc = " TWT support"]
    pub twt_support: ::core::ffi::c_uchar,
    #[doc = " management frame protection NRF_WIFI_MFP_REQUIRED/NRF_WIFI_MFP_CAPABLE"]
    pub mfp_flag: ::core::ffi::c_uchar,
    #[doc = " reserved"]
    pub reserved3: ::core::ffi::c_uchar,
    #[doc = " reserved"]
    pub reserved4: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_umac_display_results() {
    const UNINIT: ::core::mem::MaybeUninit<umac_display_results> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<umac_display_results>(),
        68usize,
        concat!("Size of: ", stringify!(umac_display_results))
    );
    assert_eq!(
        ::core::mem::align_of::<umac_display_results>(),
        1usize,
        concat!("Alignment of ", stringify!(umac_display_results))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nwk_band) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(nwk_band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nwk_channel) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(nwk_channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_flags) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(protocol_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(security_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_interval) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(beacon_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_support) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(twt_support)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mfp_flag) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(mfp_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(umac_display_results),
            "::",
            stringify!(reserved4)
        )
    );
}
#[doc = " @brief This structure serves as a response to the command NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS\n  of display scan type. It contains a maximum of DISPLAY_BSS_TOHOST_PEREVENT scan results\n  in each event. When umac_hdr->seq == 0, it indicates the last scan event.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct nrf_wifi_umac_event_new_scan_display_results {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Number of scan results in the current event"]
    pub event_bss_count: ::core::ffi::c_uchar,
    #[doc = " Display scan results info @ref umac_display_results"]
    pub display_results: [umac_display_results; 8usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_new_scan_display_results() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_new_scan_display_results> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_new_scan_display_results>(),
        581usize,
        concat!(
            "Size of: ",
            stringify!(nrf_wifi_umac_event_new_scan_display_results)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_new_scan_display_results>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_event_new_scan_display_results)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_display_results),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_bss_count) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_display_results),
            "::",
            stringify!(event_bss_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_results) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_scan_display_results),
            "::",
            stringify!(display_results)
        )
    );
}
#[doc = " @brief This structure represent different responses received from the access point during\n  various stages of the connection process like Authentication Response and Association Response.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_event_mlme {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency of the channel in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Signal strength in dBm"]
    pub rx_signal_dbm: ::core::ffi::c_uint,
    #[doc = " Indicate whether the frame was acked or timed out"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " cookie identifier"]
    pub cookie: ::core::ffi::c_ulonglong,
    #[doc = " Frame data, including frame header and body @ref nrf_wifi_frame"]
    pub frame: nrf_wifi_frame,
    #[doc = " BSSID of the BSS"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Bitmap of uapsd queues"]
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    #[doc = " Request(AUTH/ASSOC) ie length"]
    pub req_ie_len: ::core::ffi::c_uint,
    #[doc = " ie's"]
    pub req_ie: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_mlme() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_mlme> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_mlme>(),
        475usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_mlme))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_mlme>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_mlme))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_signal_dbm) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(rx_signal_dbm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wme_uapsd_queues) as usize - ptr as usize },
        470usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(wme_uapsd_queues)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).req_ie_len) as usize - ptr as usize },
        471usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(req_ie_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).req_ie) as usize - ptr as usize },
        475usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_mlme),
            "::",
            stringify!(req_ie)
        )
    );
}
#[doc = " @brief This structure represents an event that is generated when a station is added or removed.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_new_station {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate if assoc_req ies is valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " set to 1: STA supports QoS/WME"]
    pub wme: ::core::ffi::c_uchar,
    #[doc = " Set to 1 if STA is Legacy(a/b/g)"]
    pub is_sta_legacy: ::core::ffi::c_uchar,
    #[doc = " Station mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " generation number"]
    pub generation: ::core::ffi::c_uint,
    #[doc = " Station information @ref nrf_wifi_sta_info"]
    pub sta_info: nrf_wifi_sta_info,
    #[doc = " @ref nrf_wifi_ie"]
    pub assoc_req_ies: nrf_wifi_ie,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_new_station() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_new_station> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_new_station>(),
        617usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_new_station))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_new_station>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_new_station))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wme) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(wme)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_sta_legacy) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(is_sta_legacy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(generation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_info) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(sta_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).assoc_req_ies) as usize - ptr as usize },
        215usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_new_station),
            "::",
            stringify!(assoc_req_ies)
        )
    );
}
#[doc = " @brief This structure specifies the cookie response event, which is used to receive an\n  RPU cookie associated with the host cookie passed during NRF_WIFI_UMAC_CMD_FRAME.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_cookie_rsp {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate if assoc_req ies is valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Identifier passed during NRF_WIFI_UMAC_CMD_FRAME"]
    pub host_cookie: ::core::ffi::c_ulonglong,
    #[doc = " Cookie used to indicate TX done in NRF_WIFI_UMAC_EVENT_FRAME_TX_STATUS"]
    pub cookie: ::core::ffi::c_ulonglong,
    #[doc = " Mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_cookie_rsp() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_cookie_rsp> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_cookie_rsp>(),
        62usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_cookie_rsp))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_cookie_rsp>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_cookie_rsp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cookie_rsp),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cookie_rsp),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_cookie) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cookie_rsp),
            "::",
            stringify!(host_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cookie_rsp),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cookie_rsp),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " @brief This structure represents the event that corresponds to the command\n  NRF_WIFI_UMAC_CMD_GET_TX_POWER. It is used to retrieve the transmit power\n  information from the device\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_get_tx_power {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Tx power in dbm"]
    pub txpwr_level: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_get_tx_power() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_get_tx_power> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_get_tx_power>(),
        40usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_get_tx_power))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_get_tx_power>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_event_get_tx_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_get_tx_power),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txpwr_level) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_get_tx_power),
            "::",
            stringify!(txpwr_level)
        )
    );
}
#[doc = " @brief This structure represents the response to the command NRF_WIFI_UMAC_CMD_SET_INTERFACE.\n  It contains the necessary information indicating the result or status of the interface\n  configuration operation after the command has been executed.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_set_interface {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " return value"]
    pub return_value: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_set_interface() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_set_interface> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_set_interface>(),
        40usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_set_interface))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_set_interface>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_event_set_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_set_interface),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).return_value) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_set_interface),
            "::",
            stringify!(return_value)
        )
    );
}
impl nrf_wifi_channel_flags {
    #[doc = " This channel is disabled"]
    pub const CHAN_DISABLED: nrf_wifi_channel_flags = nrf_wifi_channel_flags(1);
}
impl nrf_wifi_channel_flags {
    #[doc = " do not initiate radiation, this includes sending probe requests or beaconing"]
    pub const CHAN_NO_IR: nrf_wifi_channel_flags = nrf_wifi_channel_flags(2);
}
impl nrf_wifi_channel_flags {
    #[doc = " Radar detection is required on this channel hole at 1<<2"]
    pub const CHAN_RADAR: nrf_wifi_channel_flags = nrf_wifi_channel_flags(8);
}
impl nrf_wifi_channel_flags {
    #[doc = " extension channel above this channel is not permitted"]
    pub const CHAN_NO_HT40PLUS: nrf_wifi_channel_flags = nrf_wifi_channel_flags(16);
}
impl nrf_wifi_channel_flags {
    #[doc = " extension channel below this channel is not permitted"]
    pub const CHAN_NO_HT40MINUS: nrf_wifi_channel_flags = nrf_wifi_channel_flags(32);
}
impl nrf_wifi_channel_flags {
    #[doc = " OFDM is not allowed on this channel"]
    pub const CHAN_NO_OFDM: nrf_wifi_channel_flags = nrf_wifi_channel_flags(64);
}
impl nrf_wifi_channel_flags {
    #[doc = " If the driver supports 80 MHz on the band,\n this flag indicates that an 80 MHz channel cannot use this\n channel as the control or any of the secondary channels.\n This may be due to the driver or due to regulatory bandwidth\n restrictions."]
    pub const CHAN_NO_80MHZ: nrf_wifi_channel_flags = nrf_wifi_channel_flags(128);
}
impl nrf_wifi_channel_flags {
    #[doc = " If the driver supports 160 MHz on the band,\n this flag indicates that an 160 MHz channel cannot use this\n channel as the control or any of the secondary channels.\n This may be due to the driver or due to regulatory bandwidth\n restrictions."]
    pub const CHAN_NO_160MHZ: nrf_wifi_channel_flags = nrf_wifi_channel_flags(256);
}
impl nrf_wifi_channel_flags {
    #[doc = " @ref NL80211_FREQUENCY_ATTR_INDOOR_ONLY"]
    pub const CHAN_INDOOR_ONLY: nrf_wifi_channel_flags = nrf_wifi_channel_flags(512);
}
impl nrf_wifi_channel_flags {
    #[doc = " @ref NL80211_FREQUENCY_ATTR_GO_CONCURRENT"]
    pub const CHAN_GO_CONCURRENT: nrf_wifi_channel_flags = nrf_wifi_channel_flags(1024);
}
impl nrf_wifi_channel_flags {
    #[doc = " 20 MHz bandwidth is not permitted on this channel"]
    pub const CHAN_NO_20MHZ: nrf_wifi_channel_flags = nrf_wifi_channel_flags(2048);
}
impl nrf_wifi_channel_flags {
    #[doc = " 10 MHz bandwidth is not permitted on this channel"]
    pub const CHAN_NO_10MHZ: nrf_wifi_channel_flags = nrf_wifi_channel_flags(4096);
}
impl ::core::ops::BitOr<nrf_wifi_channel_flags> for nrf_wifi_channel_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        nrf_wifi_channel_flags(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for nrf_wifi_channel_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: nrf_wifi_channel_flags) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<nrf_wifi_channel_flags> for nrf_wifi_channel_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        nrf_wifi_channel_flags(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for nrf_wifi_channel_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: nrf_wifi_channel_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " @brief channel flags.\n\n Channel flags set by the regulatory control code.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct nrf_wifi_channel_flags(pub ::core::ffi::c_uint);
#[doc = " @brief channel definition.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_chan_definition {
    #[doc = " Frequency of the selected channel in MHz"]
    pub chan: nrf_wifi_channel,
    #[doc = " channel width"]
    pub width: ::core::ffi::c_int,
    #[doc = " center frequency of first segment"]
    pub center_frequency1: ::core::ffi::c_uint,
    #[doc = " center frequency of second segment (only with 80+80 MHz)"]
    pub center_frequency2: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_chan_definition() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_chan_definition> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_chan_definition>(),
        51usize,
        concat!("Size of: ", stringify!(nrf_wifi_chan_definition))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_chan_definition>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_chan_definition))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_chan_definition),
            "::",
            stringify!(chan)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_chan_definition),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency1) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_chan_definition),
            "::",
            stringify!(center_frequency1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency2) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_chan_definition),
            "::",
            stringify!(center_frequency2)
        )
    );
}
#[doc = " @brief This structure represents channel information and serves as the event for the\n  command NRF_WIFI_UMAC_CMD_GET_CHANNEL.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_get_channel {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Channel information.@ref nrf_wifi_chan_definition"]
    pub chan_def: nrf_wifi_chan_definition,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_get_channel() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_get_channel> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_get_channel>(),
        87usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_get_channel))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_get_channel>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_get_channel))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_get_channel),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chan_def) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_get_channel),
            "::",
            stringify!(chan_def)
        )
    );
}
#[doc = " @brief This structure represents the command used to retrieve connection information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_conn_info {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_conn_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_conn_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_conn_info>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_conn_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_conn_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_cmd_conn_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_conn_info),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum link_mode {
    NRF_WIFI_MODE_11B = 1,
    NRF_WIFI_MODE_11A = 2,
    NRF_WIFI_MODE_11G = 3,
    NRF_WIFI_MODE_11N = 4,
    NRF_WIFI_MODE_11AC = 5,
    NRF_WIFI_MODE_11AX = 6,
}
#[doc = " @brief This structure represents the information related to the connection of a station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_conn_info {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Beacon interval"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " DTIM interval"]
    pub dtim_interval: ::core::ffi::c_uchar,
    #[doc = " Station association state"]
    pub associated: ::core::ffi::c_uchar,
    #[doc = " TWT supported or not"]
    pub twt_capable: ::core::ffi::c_uchar,
    #[doc = " Refer &enum link_mode"]
    pub linkmode: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_conn_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_conn_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_conn_info>(),
        42usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_conn_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_conn_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_conn_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_conn_info),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_interval) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_conn_info),
            "::",
            stringify!(beacon_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dtim_interval) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_conn_info),
            "::",
            stringify!(dtim_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).associated) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_conn_info),
            "::",
            stringify!(associated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_capable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_conn_info),
            "::",
            stringify!(twt_capable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linkmode) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_conn_info),
            "::",
            stringify!(linkmode)
        )
    );
}
#[doc = " @brief This structure defines the command used to retrieve power save information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_power_save_info {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_get_power_save_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_get_power_save_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_get_power_save_info>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(nrf_wifi_umac_cmd_get_power_save_info)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_get_power_save_info>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_get_power_save_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_get_power_save_info),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure defines the command used to set the listen interval period.\n  It determines how frequently a device wakes up to check for any pending data or traffic\n  from the access point. By setting the listen interval, devices can adjust their power-saving\n  behavior to balance power efficiency and responsiveness to incoming data.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_listen_interval {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " listen interval"]
    pub listen_interval: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_set_listen_interval() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_set_listen_interval> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_set_listen_interval>(),
        38usize,
        concat!(
            "Size of: ",
            stringify!(nrf_wifi_umac_cmd_set_listen_interval)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_set_listen_interval>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_set_listen_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_listen_interval),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listen_interval) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_set_listen_interval),
            "::",
            stringify!(listen_interval)
        )
    );
}
#[doc = " @brief This structure represents the command used to enable or disable extended power save mode.\n  When enabled, the RPU wakes up based on the listen interval, allowing the device to spend more\n  time in a lower power state. When disabled, the RPU wakes up based on the DTIM period, which\n  may require more frequent wake-ups but can provide better responsiveness for receiving\n  multicast/broadcast traffic.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_config_extended_ps {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " 1=enable 0=disable"]
    pub enable_extended_ps: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_config_extended_ps() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_config_extended_ps> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_config_extended_ps>(),
        37usize,
        concat!(
            "Size of: ",
            stringify!(nrf_wifi_umac_cmd_config_extended_ps)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_config_extended_ps>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_config_extended_ps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_config_extended_ps),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable_extended_ps) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_config_extended_ps),
            "::",
            stringify!(enable_extended_ps)
        )
    );
}
#[doc = " @brief This structure represents an event that provides information about the RPU power save\n  mode. It contains details regarding the current power save mode and its settings.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_event_power_save_info {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Power save mode. NRF_WIFI_PS_MODE_LEGACY/NRF_WIFI_PS_MODE_WMM"]
    pub ps_mode: ::core::ffi::c_uchar,
    #[doc = " Power save enable flag"]
    pub enabled: ::core::ffi::c_uchar,
    #[doc = " Extended power save ON(1)/OFF(0)"]
    pub extended_ps: ::core::ffi::c_uchar,
    #[doc = " Is TWT responder"]
    pub twt_responder: ::core::ffi::c_uchar,
    #[doc = " Power save timed out value"]
    pub ps_timeout: ::core::ffi::c_uint,
    #[doc = " Listen interval value"]
    pub listen_interval: ::core::ffi::c_ushort,
    #[doc = " Number TWT flows"]
    pub num_twt_flows: ::core::ffi::c_uchar,
    #[doc = " TWT info of each flow @ref nrf_wifi_umac_config_twt_info"]
    pub twt_flow_info: __IncompleteArrayField<nrf_wifi_umac_config_twt_info>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_power_save_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_power_save_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_power_save_info>(),
        47usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_power_save_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_power_save_info>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_event_power_save_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ps_mode) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(ps_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_ps) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(extended_ps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_responder) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(twt_responder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ps_timeout) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(ps_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listen_interval) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(listen_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_twt_flows) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(num_twt_flows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twt_flow_info) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_power_save_info),
            "::",
            stringify!(twt_flow_info)
        )
    );
}
#[doc = " @brief This structure contains information relevant to the \"Remain on Channel\" operation.\n  It is used to specify the details related to the duration and channel on which a device\n  needs to stay without regular data transmission or reception.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct remain_on_channel_info {
    #[doc = " Amount of time to remain on specified channel"]
    pub dur: ::core::ffi::c_uint,
    #[doc = " Frequency configuration, see &struct freq_params"]
    pub nrf_wifi_freq_params: freq_params,
    #[doc = " Identifier to be used for processing NRF_WIFI_UMAC_EVENT_COOKIE_RESP event"]
    pub host_cookie: ::core::ffi::c_ulonglong,
    #[doc = " Unused"]
    pub cookie: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_remain_on_channel_info() {
    const UNINIT: ::core::mem::MaybeUninit<remain_on_channel_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<remain_on_channel_info>(),
        44usize,
        concat!("Size of: ", stringify!(remain_on_channel_info))
    );
    assert_eq!(
        ::core::mem::align_of::<remain_on_channel_info>(),
        1usize,
        concat!("Alignment of ", stringify!(remain_on_channel_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(remain_on_channel_info),
            "::",
            stringify!(dur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_freq_params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(remain_on_channel_info),
            "::",
            stringify!(nrf_wifi_freq_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_cookie) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(remain_on_channel_info),
            "::",
            stringify!(host_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(remain_on_channel_info),
            "::",
            stringify!(cookie)
        )
    );
}
#[doc = " @brief This structure represents the command used to keep the device awake on the specified\n  channel for a designated period. The command initiates the \"Remain on Channel\" operation.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_remain_on_channel {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information about channel parameters.@ref remain_on_channel_info"]
    pub info: remain_on_channel_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_remain_on_channel() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_remain_on_channel> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_remain_on_channel>(),
        84usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_cmd_remain_on_channel))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_remain_on_channel>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_remain_on_channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_remain_on_channel),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_remain_on_channel),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_remain_on_channel),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " @brief This structure represents the command to cancel \"Remain on Channel\" operation.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_cancel_remain_on_channel {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " cookie to identify remain on channel"]
    pub cookie: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_cmd_cancel_remain_on_channel() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_cmd_cancel_remain_on_channel> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_cmd_cancel_remain_on_channel>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(nrf_wifi_umac_cmd_cancel_remain_on_channel)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_cmd_cancel_remain_on_channel>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_umac_cmd_cancel_remain_on_channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_cancel_remain_on_channel),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_cancel_remain_on_channel),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_cmd_cancel_remain_on_channel),
            "::",
            stringify!(cookie)
        )
    );
}
#[doc = " @brief This structure represents the response to command \"Remain on Channel\".\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_remain_on_channel {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency of the channel"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " duration that can be requested with the remain-on-channel operation(ms)"]
    pub dur: ::core::ffi::c_uint,
    #[doc = " see &enum nrf_wifi_channel_type"]
    pub ch_type: ::core::ffi::c_uint,
    #[doc = " cookie to identify remain on channel"]
    pub cookie: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_remain_on_channel() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_remain_on_channel> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_remain_on_channel>(),
        60usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_remain_on_channel))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_remain_on_channel>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_event_remain_on_channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_remain_on_channel),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_remain_on_channel),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_remain_on_channel),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dur) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_remain_on_channel),
            "::",
            stringify!(dur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ch_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_remain_on_channel),
            "::",
            stringify!(ch_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_remain_on_channel),
            "::",
            stringify!(cookie)
        )
    );
}
#[doc = " @brief This structure defines the command used to retrieve interface information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_interface {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_get_interface() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_get_interface> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_get_interface>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_get_interface))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_get_interface>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_get_interface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_get_interface),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure represents an event that contains information about a network interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_interface_info {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Interface type, see &enum nrf_wifi_iftype"]
    pub nrf_wifi_iftype: ::core::ffi::c_int,
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
    #[doc = " Mac address"]
    pub nrf_wifi_eth_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " @ref nrf_wifi_chan_definition"]
    pub chan_def: nrf_wifi_chan_definition,
    #[doc = " @ref nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
}
#[test]
fn bindgen_test_layout_nrf_wifi_interface_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_interface_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_interface_info>(),
        150usize,
        concat!("Size of: ", stringify!(nrf_wifi_interface_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_interface_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_interface_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_info),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_info),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_iftype) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_info),
            "::",
            stringify!(nrf_wifi_iftype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifacename) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_info),
            "::",
            stringify!(ifacename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_eth_addr) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_info),
            "::",
            stringify!(nrf_wifi_eth_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chan_def) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_info),
            "::",
            stringify!(chan_def)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_interface_info),
            "::",
            stringify!(ssid)
        )
    );
}
#[doc = " @brief MCS information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_mcs_info {
    #[doc = " Highest supported RX rate"]
    pub nrf_wifi_rx_highest: ::core::ffi::c_ushort,
    #[doc = " RX mask"]
    pub nrf_wifi_rx_mask: [::core::ffi::c_uchar; 10usize],
    #[doc = " TX parameters"]
    pub nrf_wifi_tx_params: ::core::ffi::c_uchar,
    #[doc = " reserved"]
    pub nrf_wifi_reserved: [::core::ffi::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_mcs_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_mcs_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_mcs_info>(),
        16usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_mcs_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_mcs_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_mcs_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_rx_highest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_mcs_info),
            "::",
            stringify!(nrf_wifi_rx_highest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_rx_mask) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_mcs_info),
            "::",
            stringify!(nrf_wifi_rx_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_tx_params) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_mcs_info),
            "::",
            stringify!(nrf_wifi_tx_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_reserved) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_mcs_info),
            "::",
            stringify!(nrf_wifi_reserved)
        )
    );
}
#[doc = " @brief This structure represents HT capability parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_sta_ht_cap {
    #[doc = " 1 indicates HT Supported"]
    pub nrf_wifi_ht_supported: ::core::ffi::c_int,
    #[doc = " HT capabilities, as in the HT information IE"]
    pub nrf_wifi_cap: ::core::ffi::c_ushort,
    #[doc = " MCS information. @ref nrf_wifi_event_mcs_info"]
    pub mcs: nrf_wifi_event_mcs_info,
    #[doc = " A-MPDU factor, as in 11n"]
    pub nrf_wifi_ampdu_factor: ::core::ffi::c_uchar,
    #[doc = " A-MPDU density, as in 11n"]
    pub nrf_wifi_ampdu_density: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_sta_ht_cap() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_sta_ht_cap> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_sta_ht_cap>(),
        24usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_sta_ht_cap))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_sta_ht_cap>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_sta_ht_cap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_ht_supported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_ht_cap),
            "::",
            stringify!(nrf_wifi_ht_supported)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_cap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_ht_cap),
            "::",
            stringify!(nrf_wifi_cap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mcs) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_ht_cap),
            "::",
            stringify!(mcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_ampdu_factor) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_ht_cap),
            "::",
            stringify!(nrf_wifi_ampdu_factor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_ampdu_density) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_ht_cap),
            "::",
            stringify!(nrf_wifi_ampdu_density)
        )
    );
}
#[doc = " @brief This structure represents channel parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_channel {
    #[doc = " channel flags NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_IBSS"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " maximum transmission power (in dBm)"]
    pub nrf_wifi_max_power: ::core::ffi::c_int,
    #[doc = " DFS state time"]
    pub nrf_wifi_time: ::core::ffi::c_uint,
    #[doc = " DFS CAC time in ms"]
    pub dfs_cac_msec: ::core::ffi::c_uint,
    #[doc = " Channel parameters are valid or not 1=valid"]
    pub ch_valid: ::core::ffi::c_schar,
    #[doc = " Channel center frequency"]
    pub center_frequency: ::core::ffi::c_ushort,
    #[doc = " Current dfs state"]
    pub dfs_state: ::core::ffi::c_schar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_channel() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_channel> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_channel>(),
        18usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_channel))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_channel>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_channel))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_channel),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_max_power) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_channel),
            "::",
            stringify!(nrf_wifi_max_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_time) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_channel),
            "::",
            stringify!(nrf_wifi_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dfs_cac_msec) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_channel),
            "::",
            stringify!(dfs_cac_msec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ch_valid) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_channel),
            "::",
            stringify!(ch_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_channel),
            "::",
            stringify!(center_frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dfs_state) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_channel),
            "::",
            stringify!(dfs_state)
        )
    );
}
#[doc = " @brief This structure represents rate information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_rate {
    #[doc = " NRF_WIFI_EVENT_GET_WIPHY_FLAG_RATE_SHORT_PREAMBLE"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Bitrate in units of 100 kbps"]
    pub nrf_wifi_bitrate: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_rate() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_rate> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_rate>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_rate))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_rate>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_rate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_rate),
            "::",
            stringify!(nrf_wifi_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_bitrate) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_rate),
            "::",
            stringify!(nrf_wifi_bitrate)
        )
    );
}
#[doc = " @brief VHT MCS information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_vht_mcs_info {
    #[doc = " RX MCS map 2 bits for each stream, total 8 streams"]
    pub rx_mcs_map: ::core::ffi::c_ushort,
    #[doc = " Indicates highest long GI VHT PPDU data rate\n  STA can receive. Rate expressed in units of 1 Mbps.\n  If this field is 0 this value should not be used to\n  consider the highest RX data rate supported."]
    pub rx_highest: ::core::ffi::c_ushort,
    #[doc = " TX MCS map 2 bits for each stream, total 8 streams"]
    pub tx_mcs_map: ::core::ffi::c_ushort,
    #[doc = " Indicates highest long GI VHT PPDU data rate\n  STA can transmit. Rate expressed in units of 1 Mbps.\n  If this field is 0 this value should not be used to\n  consider the highest TX data rate supported."]
    pub tx_highest: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_vht_mcs_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_vht_mcs_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_vht_mcs_info>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_vht_mcs_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_vht_mcs_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_vht_mcs_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_mcs_map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_vht_mcs_info),
            "::",
            stringify!(rx_mcs_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_highest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_vht_mcs_info),
            "::",
            stringify!(rx_highest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_mcs_map) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_vht_mcs_info),
            "::",
            stringify!(tx_mcs_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_highest) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_vht_mcs_info),
            "::",
            stringify!(tx_highest)
        )
    );
}
#[doc = " @brief This structure represents VHT capability parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_sta_vht_cap {
    #[doc = " 1 indicates VHT Supported"]
    pub nrf_wifi_vht_supported: ::core::ffi::c_schar,
    #[doc = " VHT capability info"]
    pub nrf_wifi_cap: ::core::ffi::c_uint,
    #[doc = " Refer @ref nrf_wifi_event_vht_mcs_info"]
    pub vht_mcs: nrf_wifi_event_vht_mcs_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_sta_vht_cap() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_sta_vht_cap> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_sta_vht_cap>(),
        13usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_sta_vht_cap))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_sta_vht_cap>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_sta_vht_cap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_vht_supported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_vht_cap),
            "::",
            stringify!(nrf_wifi_vht_supported)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_cap) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_vht_cap),
            "::",
            stringify!(nrf_wifi_cap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_mcs) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_sta_vht_cap),
            "::",
            stringify!(vht_mcs)
        )
    );
}
#[doc = " @brief Frequency band information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_supported_band {
    #[doc = " No.of channels"]
    pub nrf_wifi_n_channels: ::core::ffi::c_ushort,
    #[doc = " No.of bitrates"]
    pub nrf_wifi_n_bitrates: ::core::ffi::c_ushort,
    #[doc = " Array of channels the hardware can operate in this band"]
    pub channels: [nrf_wifi_event_channel; 29usize],
    #[doc = " Array of bitrates the hardware can operate with in this band"]
    pub bitrates: [nrf_wifi_event_rate; 13usize],
    #[doc = " HT capabilities in this band"]
    pub ht_cap: nrf_wifi_event_sta_ht_cap,
    #[doc = " VHT capabilities in this band"]
    pub vht_cap: nrf_wifi_event_sta_vht_cap,
    #[doc = " the band this structure represents"]
    pub band: ::core::ffi::c_schar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_supported_band() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_supported_band> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_supported_band>(),
        616usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_supported_band))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_supported_band>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_supported_band))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_n_channels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_supported_band),
            "::",
            stringify!(nrf_wifi_n_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_n_bitrates) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_supported_band),
            "::",
            stringify!(nrf_wifi_n_bitrates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_supported_band),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitrates) as usize - ptr as usize },
        526usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_supported_band),
            "::",
            stringify!(bitrates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ht_cap) as usize - ptr as usize },
        578usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_supported_band),
            "::",
            stringify!(ht_cap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vht_cap) as usize - ptr as usize },
        602usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_supported_band),
            "::",
            stringify!(vht_cap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band) as usize - ptr as usize },
        615usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_supported_band),
            "::",
            stringify!(band)
        )
    );
}
#[doc = " @brief Interface limits.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_iface_limit {
    #[doc = " max interface limits"]
    pub nrf_wifi_max: ::core::ffi::c_ushort,
    #[doc = " types"]
    pub nrf_wifi_types: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_iface_limit() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_iface_limit> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_iface_limit>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_iface_limit))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_iface_limit>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_iface_limit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_max) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_limit),
            "::",
            stringify!(nrf_wifi_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_types) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_limit),
            "::",
            stringify!(nrf_wifi_types)
        )
    );
}
#[doc = " @brief This structure defines an event that represents interface combinations.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_iface_combination {
    #[doc = " channels count"]
    pub nrf_wifi_num_different_channels: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub beacon_int_infra_match: ::core::ffi::c_int,
    #[doc = " @ref nrf_wifi_event_iface_limit"]
    pub limits: [nrf_wifi_event_iface_limit; 2usize],
    #[doc = " Max interfaces"]
    pub nrf_wifi_max_interfaces: ::core::ffi::c_ushort,
    #[doc = " Not used"]
    pub nrf_wifi_radar_detect_widths: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub nrf_wifi_n_limits: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub nrf_wifi_radar_detect_regions: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub comb_valid: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_iface_combination() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_iface_combination> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_iface_combination>(),
        22usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_iface_combination))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_iface_combination>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(nrf_wifi_event_iface_combination)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nrf_wifi_num_different_channels) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(nrf_wifi_num_different_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beacon_int_infra_match) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(beacon_int_infra_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(limits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_max_interfaces) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(nrf_wifi_max_interfaces)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nrf_wifi_radar_detect_widths) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(nrf_wifi_radar_detect_widths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_n_limits) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(nrf_wifi_n_limits)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nrf_wifi_radar_detect_regions) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(nrf_wifi_radar_detect_regions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comb_valid) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_iface_combination),
            "::",
            stringify!(comb_valid)
        )
    );
}
#[doc = " @brief This structure represents wiphy parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_get_wiphy {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Unused"]
    pub nrf_wifi_frag_threshold: ::core::ffi::c_uint,
    #[doc = " RTS threshold value"]
    pub nrf_wifi_rts_threshold: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_available_antennas_tx: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_available_antennas_rx: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_probe_resp_offload: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub tx_ant: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub rx_ant: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub split_start2_flags: ::core::ffi::c_uint,
    #[doc = " Maximum ROC duration"]
    pub max_remain_on_channel_duration: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub ap_sme_capa: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub features: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub max_acl_mac_addresses: ::core::ffi::c_uint,
    #[doc = " maximum number of associated stations supported in AP mode"]
    pub max_ap_assoc_sta: ::core::ffi::c_uint,
    #[doc = " supported cipher suites"]
    pub cipher_suites: [::core::ffi::c_uint; 30usize],
    #[doc = " wiphy flags NRF_WIFI_EVENT_GET_WIPHY_AP_UAPSD"]
    pub get_wiphy_flags: ::core::ffi::c_uint,
    #[doc = " valid parameters NRF_WIFI_GET_WIPHY_VALID_WIPHY_NAME"]
    pub params_valid: ::core::ffi::c_uint,
    #[doc = " Maximum scan IE length"]
    pub max_scan_ie_len: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub max_sched_scan_ie_len: ::core::ffi::c_ushort,
    #[doc = " bit mask of interface value of see &enum nrf_wifi_iftype"]
    pub interface_modes: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub iface_com: [nrf_wifi_event_iface_combination; 6usize],
    #[doc = " Unused"]
    pub supp_commands: [::core::ffi::c_schar; 40usize],
    #[doc = " Retry limit for short frames"]
    pub retry_short: ::core::ffi::c_uchar,
    #[doc = " Retry limit for long frames"]
    pub retry_long: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub coverage_class: ::core::ffi::c_uchar,
    #[doc = " Maximum ssids supported in scan"]
    pub max_scan_ssids: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub max_sched_scan_ssids: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub max_match_sets: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub n_cipher_suites: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub max_num_pmkids: ::core::ffi::c_uchar,
    #[doc = " length of the extended capabilities"]
    pub extended_capabilities_len: ::core::ffi::c_uchar,
    #[doc = " Extended capabilities"]
    pub extended_capabilities: [::core::ffi::c_uchar; 10usize],
    #[doc = " Extended capabilities mask"]
    pub extended_capabilities_mask: [::core::ffi::c_uchar; 10usize],
    #[doc = " Unused"]
    pub ext_features: [::core::ffi::c_uchar; 8usize],
    #[doc = " Unused"]
    pub ext_features_len: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub num_iface_com: ::core::ffi::c_schar,
    #[doc = " Wiphy name"]
    pub wiphy_name: [::core::ffi::c_schar; 32usize],
    #[doc = " Supported bands info. @ref nrf_wifi_event_supported_band"]
    pub sband: [nrf_wifi_event_supported_band; 2usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_event_get_wiphy() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_event_get_wiphy> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_event_get_wiphy>(),
        1697usize,
        concat!("Size of: ", stringify!(nrf_wifi_event_get_wiphy))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_event_get_wiphy>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_event_get_wiphy))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_frag_threshold) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(nrf_wifi_frag_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_rts_threshold) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(nrf_wifi_rts_threshold)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nrf_wifi_available_antennas_tx) as usize - ptr as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(nrf_wifi_available_antennas_tx)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nrf_wifi_available_antennas_rx) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(nrf_wifi_available_antennas_rx)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nrf_wifi_probe_resp_offload) as usize - ptr as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(nrf_wifi_probe_resp_offload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_ant) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(tx_ant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ant) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(rx_ant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).split_start2_flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(split_start2_flags)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).max_remain_on_channel_duration) as usize - ptr as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_remain_on_channel_duration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ap_sme_capa) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(ap_sme_capa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_acl_mac_addresses) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_acl_mac_addresses)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_ap_assoc_sta) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_ap_assoc_sta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_suites) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(cipher_suites)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_wiphy_flags) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(get_wiphy_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params_valid) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(params_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_scan_ie_len) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_scan_ie_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_sched_scan_ie_len) as usize - ptr as usize },
        218usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_sched_scan_ie_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface_modes) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(interface_modes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iface_com) as usize - ptr as usize },
        222usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(iface_com)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supp_commands) as usize - ptr as usize },
        354usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(supp_commands)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retry_short) as usize - ptr as usize },
        394usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(retry_short)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retry_long) as usize - ptr as usize },
        395usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(retry_long)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coverage_class) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(coverage_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_scan_ssids) as usize - ptr as usize },
        397usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_scan_ssids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_sched_scan_ssids) as usize - ptr as usize },
        398usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_sched_scan_ssids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_match_sets) as usize - ptr as usize },
        399usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_match_sets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_cipher_suites) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(n_cipher_suites)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_num_pmkids) as usize - ptr as usize },
        401usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(max_num_pmkids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_capabilities_len) as usize - ptr as usize },
        402usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(extended_capabilities_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_capabilities) as usize - ptr as usize },
        403usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(extended_capabilities)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_capabilities_mask) as usize - ptr as usize },
        413usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(extended_capabilities_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_features) as usize - ptr as usize },
        423usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(ext_features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_features_len) as usize - ptr as usize },
        431usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(ext_features_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_iface_com) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(num_iface_com)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wiphy_name) as usize - ptr as usize },
        433usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(wiphy_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sband) as usize - ptr as usize },
        465usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_event_get_wiphy),
            "::",
            stringify!(sband)
        )
    );
}
#[doc = " @brief This structure represents the command used to retrieve Wireless PHY (wiphy) information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_wiphy {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_get_wiphy() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_get_wiphy> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_get_wiphy>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_get_wiphy))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_get_wiphy>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_get_wiphy))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_get_wiphy),
            "::",
            stringify!(umac_hdr)
        )
    );
}
#[doc = " @brief This structure represents the command to get hardware address.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_ifhwaddr {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_get_ifhwaddr() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_get_ifhwaddr> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_get_ifhwaddr>(),
        52usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_get_ifhwaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_get_ifhwaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_get_ifhwaddr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_get_ifhwaddr),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifacename) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_get_ifhwaddr),
            "::",
            stringify!(ifacename)
        )
    );
}
#[doc = " @brief This structure represents the command used to retrieve the hardware address or\n  MAC address of the device.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_set_ifhwaddr {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
    #[doc = " Hardware address to be set"]
    pub nrf_wifi_hwaddr: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_set_ifhwaddr() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_set_ifhwaddr> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_set_ifhwaddr>(),
        58usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_set_ifhwaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_set_ifhwaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_set_ifhwaddr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_set_ifhwaddr),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifacename) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_set_ifhwaddr),
            "::",
            stringify!(ifacename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_hwaddr) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_set_ifhwaddr),
            "::",
            stringify!(nrf_wifi_hwaddr)
        )
    );
}
#[doc = " @brief This structure represents the information related to the regulatory domain\n  of a wireless device. The regulatory domain defines the specific rules and regulations\n  that govern the usage of radio frequencies in a particular geographical region.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_reg_rules {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " NRF_WIFI_RULE_FLAGS_NO_CCK and NRF_WIFI_RULE_FLAGS_NO_INDOOR"]
    pub rule_flags: ::core::ffi::c_uint,
    #[doc = " starting frequencry for the regulatory rule in KHz"]
    pub freq_range_start: ::core::ffi::c_uint,
    #[doc = " ending frequency for the regulatory rule in KHz"]
    pub freq_range_end: ::core::ffi::c_uint,
    #[doc = " maximum allowed bandwidth for this frequency range"]
    pub freq_range_max_bw: ::core::ffi::c_uint,
    #[doc = " maximum allowed EIRP mBm (100 * dBm)"]
    pub pwr_max_eirp: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_reg_rules() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_reg_rules> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_reg_rules>(),
        24usize,
        concat!("Size of: ", stringify!(nrf_wifi_reg_rules))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_reg_rules>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_reg_rules))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg_rules),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rule_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg_rules),
            "::",
            stringify!(rule_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_range_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg_rules),
            "::",
            stringify!(freq_range_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_range_end) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg_rules),
            "::",
            stringify!(freq_range_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq_range_max_bw) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg_rules),
            "::",
            stringify!(freq_range_max_bw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pwr_max_eirp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg_rules),
            "::",
            stringify!(pwr_max_eirp)
        )
    );
}
#[doc = " @brief This structure represents channels information like maximum power,\n  center frequency, channel supported and active or passive scan.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_get_reg_chn_info {
    #[doc = " center frequency in MHz"]
    pub center_frequency: ::core::ffi::c_uint,
    #[doc = " maximum transmission power (in dBm)"]
    pub max_power: ::core::ffi::c_uint,
    #[doc = " Particular channel is supported or not"]
    pub supported: ::core::ffi::c_char,
    #[doc = " Particular channel is supports passive scanning or not"]
    pub passive_channel: ::core::ffi::c_char,
    #[doc = " Particular channel is dfs or not"]
    pub dfs: ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_nrf_wifi_get_reg_chn_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_get_reg_chn_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_get_reg_chn_info>(),
        11usize,
        concat!("Size of: ", stringify!(nrf_wifi_get_reg_chn_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_get_reg_chn_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_get_reg_chn_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center_frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_get_reg_chn_info),
            "::",
            stringify!(center_frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_power) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_get_reg_chn_info),
            "::",
            stringify!(max_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_get_reg_chn_info),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).passive_channel) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_get_reg_chn_info),
            "::",
            stringify!(passive_channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dfs) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_get_reg_chn_info),
            "::",
            stringify!(dfs)
        )
    );
}
#[doc = " @brief This structure represents an event that contains regulatory domain information.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_reg {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Country code"]
    pub nrf_wifi_alpha2: [::core::ffi::c_uchar; 2usize],
    #[doc = " Number of channel list information"]
    pub num_channels: ::core::ffi::c_uint,
    #[doc = " channels list information"]
    pub chn_info: __IncompleteArrayField<nrf_wifi_get_reg_chn_info>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_reg() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_reg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_reg>(),
        42usize,
        concat!("Size of: ", stringify!(nrf_wifi_reg))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_reg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_alpha2) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg),
            "::",
            stringify!(nrf_wifi_alpha2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg),
            "::",
            stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chn_info) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_reg),
            "::",
            stringify!(chn_info)
        )
    );
}
#[doc = " @brief This structure represents the command used to set the regulatory domain\n  for a wireless device. It allows configuring the device to adhere to the rules\n  and regulations specific to the geographical region in which it is operating.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_req_set_reg {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Type of regulatory hint passed from userspace"]
    pub nrf_wifi_user_reg_hint_type: ::core::ffi::c_uint,
    #[doc = " Country code"]
    pub nrf_wifi_alpha2: [::core::ffi::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_cmd_req_set_reg() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_cmd_req_set_reg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_cmd_req_set_reg>(),
        46usize,
        concat!("Size of: ", stringify!(nrf_wifi_cmd_req_set_reg))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_cmd_req_set_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_cmd_req_set_reg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_req_set_reg),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid_fields) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_req_set_reg),
            "::",
            stringify!(valid_fields)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nrf_wifi_user_reg_hint_type) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_req_set_reg),
            "::",
            stringify!(nrf_wifi_user_reg_hint_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrf_wifi_alpha2) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_cmd_req_set_reg),
            "::",
            stringify!(nrf_wifi_alpha2)
        )
    );
}
#[doc = " @brief This structure represents the status code for a command. It is used to indicate\n  the outcome or result of executing a specific command. The status code provides valuable\n  information about the success, failure, or any errors encountered during the execution\n  of the command, helping to understand the current state of the device.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_cmd_status {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Command id. see &enum nrf_wifi_umac_commands"]
    pub cmd_id: ::core::ffi::c_uint,
    #[doc = " Status codes"]
    pub cmd_status: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_umac_event_cmd_status() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_umac_event_cmd_status> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_umac_event_cmd_status>(),
        44usize,
        concat!("Size of: ", stringify!(nrf_wifi_umac_event_cmd_status))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_umac_event_cmd_status>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_umac_event_cmd_status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cmd_status),
            "::",
            stringify!(umac_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cmd_status),
            "::",
            stringify!(cmd_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_umac_event_cmd_status),
            "::",
            stringify!(cmd_status)
        )
    );
}
#[doc = " @brief Structure to hold host specific statistics.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_host_stats {
    #[doc = " Total number of TX frames transmitted."]
    pub total_tx_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of TX dones received."]
    pub total_tx_done_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of TX frames dropped."]
    pub total_tx_drop_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of RX frames received."]
    pub total_rx_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of RX frames dropped."]
    pub total_rx_drop_pkts: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_rpu_host_stats() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_host_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_host_stats>(),
        40usize,
        concat!("Size of: ", stringify!(rpu_host_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_host_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rpu_host_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_tx_pkts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_host_stats),
            "::",
            stringify!(total_tx_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_tx_done_pkts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_host_stats),
            "::",
            stringify!(total_tx_done_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_tx_drop_pkts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_host_stats),
            "::",
            stringify!(total_tx_drop_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_rx_pkts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_host_stats),
            "::",
            stringify!(total_rx_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_rx_drop_pkts) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_host_stats),
            "::",
            stringify!(total_rx_drop_pkts)
        )
    );
}
#[doc = " @brief - Structure to hold per device host and firmware statistics.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_op_stats {
    #[doc = " Host statistics."]
    pub host: rpu_host_stats,
    #[doc = " Firmware statistics."]
    pub fw: rpu_fw_stats,
}
#[test]
fn bindgen_test_layout_rpu_op_stats() {
    const UNINIT: ::core::mem::MaybeUninit<rpu_op_stats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpu_op_stats>(),
        680usize,
        concat!("Size of: ", stringify!(rpu_op_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<rpu_op_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rpu_op_stats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_op_stats),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rpu_op_stats),
            "::",
            stringify!(fw)
        )
    );
}
#[doc = " @brief Structure to hold FW patch information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fw_info {
    #[doc = " Pointer to the FW patch data."]
    pub data: *mut ::core::ffi::c_void,
    #[doc = " Size of the FW patch data."]
    pub size: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fw_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fw_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fw_info>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_fw_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fw_info>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fw_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fw_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fw_info),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " @brief Structure to hold FW patch information for LMAC and UMAC.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_fw_info {
    #[doc = " Primary LMAC FW patch information."]
    pub lmac_patch_pri: nrf_wifi_fw_info,
    #[doc = " Secondary LMAC FW patch information."]
    pub lmac_patch_sec: nrf_wifi_fw_info,
    #[doc = " Primary UMAC FW patch information."]
    pub umac_patch_pri: nrf_wifi_fw_info,
    #[doc = " Secondary UMAC FW patch information."]
    pub umac_patch_sec: nrf_wifi_fw_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_fw_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_fw_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_fw_info>(),
        32usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_fw_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_fw_info>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_fw_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_patch_pri) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_fw_info),
            "::",
            stringify!(lmac_patch_pri)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmac_patch_sec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_fw_info),
            "::",
            stringify!(lmac_patch_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_patch_pri) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_fw_info),
            "::",
            stringify!(umac_patch_pri)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).umac_patch_sec) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_fw_info),
            "::",
            stringify!(umac_patch_sec)
        )
    );
}
#[doc = " @brief Structure to hold OTP region information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_otp_info {
    #[doc = " OTP region information."]
    pub info: host_rpu_umac_info,
    #[doc = " Flags indicating which OTP regions are valid."]
    pub flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_otp_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_otp_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_otp_info>(),
        188usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_otp_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_otp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_otp_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_otp_info),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_otp_info),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief Structure to hold Regulatory parameter data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_reg_info {
    #[doc = " ISO IEC Country code."]
    pub alpha2: [::core::ffi::c_uchar; 2usize],
    #[doc = " Forcefully set regulatory."]
    pub force: bool,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_reg_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_reg_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_reg_info>(),
        3usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_reg_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_reg_info>(),
        1usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_reg_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_reg_info),
            "::",
            stringify!(alpha2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).force) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_reg_info),
            "::",
            stringify!(force)
        )
    );
}
#[doc = " @brief Structure to hold common fmac priv parameter data.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct nrf_wifi_fmac_priv {
    #[doc = " Handle to the OS abstraction layer."]
    pub opriv: *mut nrf_wifi_osal_priv,
    #[doc = " Handle to the HAL layer."]
    pub hpriv: *mut nrf_wifi_hal_priv,
    #[doc = " Data pointer to mode specific parameters"]
    pub priv_: __IncompleteArrayField<::core::ffi::c_char>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_priv() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_priv> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_priv>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_priv))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_priv>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_priv))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opriv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv),
            "::",
            stringify!(opriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hpriv) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv),
            "::",
            stringify!(hpriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " @brief Structure to hold common fmac dev context parameter data.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct nrf_wifi_fmac_dev_ctx {
    #[doc = " Handle to the FMAC IF abstraction layer."]
    pub fpriv: *mut nrf_wifi_fmac_priv,
    #[doc = " Handle to the OS abstraction layer."]
    pub os_dev_ctx: *mut ::core::ffi::c_void,
    #[doc = " Handle to the HAL layer."]
    pub hal_dev_ctx: *mut ::core::ffi::c_void,
    #[doc = " Firmware statistics."]
    pub fw_stats: *mut rpu_fw_stats,
    #[doc = " Firmware statistics requested."]
    pub stats_req: bool,
    #[doc = " Firmware boot done."]
    pub fw_boot_done: bool,
    #[doc = " Firmware init done."]
    pub fw_init_done: bool,
    #[doc = " Firmware deinit done."]
    pub fw_deinit_done: bool,
    #[doc = " Alpha2 valid."]
    pub alpha2_valid: bool,
    #[doc = " Alpha2 country code, last byte is reserved for null character."]
    pub alpha2: [::core::ffi::c_uchar; 3usize],
    #[doc = " Data pointer to mode specific parameters"]
    pub priv_: __IncompleteArrayField<::core::ffi::c_char>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_dev_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_dev_ctx> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_dev_ctx>(),
        24usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_dev_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_dev_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_dev_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpriv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(fpriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).os_dev_ctx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(os_dev_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hal_dev_ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(hal_dev_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_stats) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(fw_stats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stats_req) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(stats_req)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_boot_done) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(fw_boot_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_init_done) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(fw_init_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_deinit_done) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(fw_deinit_done)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha2_valid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(alpha2_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha2) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(alpha2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(u32)]
#[doc = " @brief WLAN access categories.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_ac {
    #[doc = " Background access category."]
    NRF_WIFI_FMAC_AC_BK = 0,
    #[doc = " Best-effort access category."]
    NRF_WIFI_FMAC_AC_BE = 1,
    #[doc = " Video access category."]
    NRF_WIFI_FMAC_AC_VI = 2,
    #[doc = " Voice access category."]
    NRF_WIFI_FMAC_AC_VO = 3,
    #[doc = " Multicast access category."]
    NRF_WIFI_FMAC_AC_MC = 4,
    #[doc = " Maximum number of WLAN access categories."]
    NRF_WIFI_FMAC_AC_MAX = 5,
}
#[repr(u32)]
#[doc = " @brief The operational state of an interface.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_if_op_state {
    #[doc = " Interface is non-operational."]
    NRF_WIFI_FMAC_IF_OP_STATE_DOWN = 0,
    #[doc = " Interface is operational."]
    NRF_WIFI_FMAC_IF_OP_STATE_UP = 1,
    #[doc = " Invalid value. Used for error checks."]
    NRF_WIFI_FMAC_IF_OP_STATE_INVALID = 2,
}
#[repr(u32)]
#[doc = " @brief The carrier state of an interface.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_if_carr_state {
    #[doc = " Interface is not ready."]
    NRF_WIFI_FMAC_IF_CARR_STATE_OFF = 0,
    #[doc = " Interface is ready."]
    NRF_WIFI_FMAC_IF_CARR_STATE_ON = 1,
    #[doc = " Invalid value. Used for error checks."]
    NRF_WIFI_FMAC_IF_CARR_STATE_INVALID = 2,
}
#[doc = " @brief Callback functions to be invoked by UMAC IF layer when a particular event occurs.\n\n This structure contains function pointers to all the callback functions that\n the UMAC IF layer needs to invoke for various events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_callbk_fns {
    #[doc = " Callback function to be called when a scan is started."]
    pub scan_start_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_start_event: *mut nrf_wifi_umac_event_trigger_scan,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a scan is done."]
    pub scan_done_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_done_event: *mut nrf_wifi_umac_event_trigger_scan,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a scan is aborted."]
    pub scan_abort_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_done_event: *mut nrf_wifi_umac_event_trigger_scan,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a scan result is received."]
    pub scan_res_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_res: *mut nrf_wifi_umac_event_new_scan_results,
            event_len: ::core::ffi::c_uint,
            more_res: bool,
        ),
    >,
    #[doc = " Callback function to be called when a display scan result is received."]
    pub disp_scan_res_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_res: *mut nrf_wifi_umac_event_new_scan_display_results,
            event_len: ::core::ffi::c_uint,
            more_res: bool,
        ),
    >,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_callbk_fns() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_callbk_fns> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_callbk_fns>(),
        20usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_callbk_fns))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_callbk_fns>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_callbk_fns))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_start_callbk_fn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_callbk_fns),
            "::",
            stringify!(scan_start_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_done_callbk_fn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_callbk_fns),
            "::",
            stringify!(scan_done_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_abort_callbk_fn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_callbk_fns),
            "::",
            stringify!(scan_abort_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_res_callbk_fn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_callbk_fns),
            "::",
            stringify!(scan_res_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disp_scan_res_callbk_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_callbk_fns),
            "::",
            stringify!(disp_scan_res_callbk_fn)
        )
    );
}
#[doc = " @brief Structure to hold context information for the UMAC IF layer.\n\n This structure maintains the context information necessary for the\n operation of the UMAC IF layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_priv_def {
    #[doc = " Callback functions to be called on various events."]
    pub callbk_fns: nrf_wifi_fmac_callbk_fns,
    #[doc = " Data path configuration parameters."]
    pub data_config: nrf_wifi_data_config_params,
    #[doc = " RX buffer pool configuration data."]
    pub rx_buf_pools: [rx_buf_pool_params; 3usize],
    #[doc = " Starting RX descriptor number for a RX buffer pool."]
    pub rx_desc: [::core::ffi::c_uint; 3usize],
    #[doc = " Maximum number of host buffers needed for RX frames."]
    pub num_rx_bufs: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_priv_def() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_priv_def> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_priv_def>(),
        60usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_priv_def))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_priv_def>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_priv_def))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callbk_fns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv_def),
            "::",
            stringify!(callbk_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_config) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv_def),
            "::",
            stringify!(data_config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf_pools) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv_def),
            "::",
            stringify!(rx_buf_pools)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_desc) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv_def),
            "::",
            stringify!(rx_desc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_rx_bufs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_priv_def),
            "::",
            stringify!(num_rx_bufs)
        )
    );
}
#[doc = " @brief Structure to hold per device context information for the UMAC IF layer.\n\n This structure maintains the context information necessary for the\n a single instance of an FullMAC based RPU."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_dev_ctx_def {
    #[doc = " Array of pointers to virtual interfaces created on this device."]
    pub vif_ctx: [*mut nrf_wifi_fmac_vif_ctx; 2usize],
    #[doc = " Host statistics."]
    pub host_stats: rpu_host_stats,
    #[doc = " Number of interfaces in STA mode."]
    pub num_sta: ::core::ffi::c_uchar,
    #[doc = " Number of interfaces in AP mode."]
    pub num_ap: ::core::ffi::c_uchar,
    #[doc = " Queue for storing mapping info of RX buffers."]
    pub rx_buf_info: *mut nrf_wifi_fmac_buf_map_info,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_dev_ctx_def() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_dev_ctx_def> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_dev_ctx_def>(),
        56usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_dev_ctx_def))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_dev_ctx_def>(),
        8usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_dev_ctx_def))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vif_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx_def),
            "::",
            stringify!(vif_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_stats) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx_def),
            "::",
            stringify!(host_stats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_sta) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx_def),
            "::",
            stringify!(num_sta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_ap) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx_def),
            "::",
            stringify!(num_ap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf_info) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_dev_ctx_def),
            "::",
            stringify!(rx_buf_info)
        )
    );
}
#[doc = " @brief Structure to hold per VIF context information for the UMAC IF layer.\n\n This structure maintains the context information necessary for the\n a single instance of an VIF."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_vif_ctx {
    #[doc = " Handle to the FMAC IF abstraction layer."]
    pub fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
    #[doc = " Handle to the OS abstraction layer."]
    pub os_vif_ctx: *mut ::core::ffi::c_void,
    #[doc = " MAC address of the VIF."]
    pub mac_addr: [::core::ffi::c_char; 6usize],
    #[doc = " Groupwise cipher being used on this VIF."]
    pub groupwise_cipher: ::core::ffi::c_int,
    #[doc = " Interface flags related to this VIF."]
    pub ifflags: bool,
    #[doc = " Interface type of this VIF."]
    pub if_type: ::core::ffi::c_int,
    #[doc = " BSSID of the AP to which this VIF is connected (applicable only in STA mode)."]
    pub bssid: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_vif_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_vif_ctx> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_vif_ctx>(),
        36usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_vif_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_vif_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_vif_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fmac_dev_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_vif_ctx),
            "::",
            stringify!(fmac_dev_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).os_vif_ctx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_vif_ctx),
            "::",
            stringify!(os_vif_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_vif_ctx),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).groupwise_cipher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_vif_ctx),
            "::",
            stringify!(groupwise_cipher)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifflags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_vif_ctx),
            "::",
            stringify!(ifflags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).if_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_vif_ctx),
            "::",
            stringify!(if_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bssid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_vif_ctx),
            "::",
            stringify!(bssid)
        )
    );
}
#[doc = " @brief Structure to hold TX/RX buffer pool configuration data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_buf_map_info {
    #[doc = " Flag indicating whether the buffer is mapped or not."]
    pub mapped: bool,
    #[doc = " The number of words in the buffer."]
    pub nwb: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_fmac_buf_map_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_fmac_buf_map_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_fmac_buf_map_info>(),
        8usize,
        concat!("Size of: ", stringify!(nrf_wifi_fmac_buf_map_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_fmac_buf_map_info>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_fmac_buf_map_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mapped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_buf_map_info),
            "::",
            stringify!(mapped)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nwb) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_fmac_buf_map_info),
            "::",
            stringify!(nwb)
        )
    );
}
extern "C" {
    pub fn umac_cmd_alloc(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        type_: ::core::ffi::c_int,
        size: ::core::ffi::c_int,
    ) -> *mut host_rpu_msg;
}
extern "C" {
    pub fn umac_cmd_cfg(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        params: *mut ::core::ffi::c_void,
        len: ::core::ffi::c_int,
    ) -> nrf_wifi_status;
}
extern "C" {
    pub fn umac_cmd_init(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        rf_params: *mut ::core::ffi::c_uchar,
        rf_params_valid: bool,
        config: *mut nrf_wifi_data_config_params,
        phy_calib: ::core::ffi::c_uint,
        op_band: op_band,
        beamforming: bool,
        tx_pwr_ctrl_params: *mut nrf_wifi_tx_pwr_ctrl_params,
    ) -> nrf_wifi_status;
}
extern "C" {
    pub fn umac_cmd_deinit(fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx) -> nrf_wifi_status;
}
extern "C" {
    pub fn umac_cmd_btcoex(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        cmd: *mut ::core::ffi::c_void,
        cmd_len: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    pub fn umac_cmd_he_ltf_gi(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        he_ltf: ::core::ffi::c_uchar,
        he_gi: ::core::ffi::c_uchar,
        enabled: ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    pub fn umac_cmd_prog_stats_get(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        stat_type: ::core::ffi::c_int,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " nrf_wifi_fmac_event_callback() - RPU event classifier and handler.\n @data: Pointer to the device driver context.\n @event_data: Pointer to event data.\n @len: Length of event data pointed to by @event_data.\n\n This callback classifies and processes an event. This classification of the\n event is based on whether it contains data or control messages\n and invokes further handlers based on that.\n\n Return: Status\n\t\tPass: NRF_WIFI_STATUS_SUCCESS\n\t\tFail: NRF_WIFI_STATUS_FAIL"]
    pub fn nrf_wifi_fmac_event_callback(
        data: *mut ::core::ffi::c_void,
        event_data: *mut ::core::ffi::c_void,
        len: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    pub fn nrf_wifi_fmac_vif_check_if_limit(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        if_type: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nrf_wifi_fmac_vif_incr_if_type(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        if_type: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn nrf_wifi_fmac_vif_decr_if_type(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        if_type: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn nrf_wifi_fmac_vif_clear_ctx(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn nrf_wifi_fmac_vif_update_if_type(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        if_type: ::core::ffi::c_int,
    );
}
extern "C" {
    pub fn nrf_wifi_fmac_get_num_vifs(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn bb_init(fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx);
}
extern "C" {
    #[doc = " @brief Adds a RPU instance.\n @param fpriv Pointer to the context of the UMAC IF layer.\n @param os_dev_ctx Pointer to the OS specific context of the RPU instance.\n\n This function adds an RPU instance. This function will return the\n\t    pointer to the context of the RPU instance. This pointer will need to be\n\t    supplied while invoking further device specific APIs,\n\t    for example, nrf_wifi_fmac_scan() etc.\n\n @return Pointer to the context of the RPU instance."]
    pub fn nrf_wifi_fmac_dev_add(
        fpriv: *mut nrf_wifi_fmac_priv,
        os_dev_ctx: *mut ::core::ffi::c_void,
    ) -> *mut nrf_wifi_fmac_dev_ctx;
}
extern "C" {
    #[doc = " @brief Issue a request to get stats from the RPU.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param op_mode RPU operation mode.\n @param stats Pointer to memory where the stats are to be copied.\n\n This function is used to send a command to\n\t    instruct the firmware to return the current RPU statistics. The RPU will\n\t    send the event with the current statistics.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_stats_get(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        op_mode: rpu_op_mode,
        stats: *mut rpu_op_stats,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Loads the Firmware(s) to the RPU WLAN device.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device,\n      which was passed as \\p fmac_dev_ctx parameter via the\n      \\p add_dev_callbk_fn() callback function.\n @param fmac_fw Information about the FullMAC firmware(s) to be loaded.\n\n This function loads the FullMAC firmware(s) to the RPU WLAN device.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_fw_load(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        fmac_fw: *mut nrf_wifi_fmac_fw_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get FW versions from the RPU.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param fw_ver Pointer to the address where the FW versions needs to be copied.\n\n This function is used to get Firmware versions from the RPU.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_ver_get(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        fw_ver: *mut ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure HE LTF and GI parameters.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param he_ltf HE LTF parameter which will be configured in RPU.\n @param he_gi HE GI parameter which will be configured in RPU.\n @param enabled enable/disable HE LTF and GI parameter configured.\n\n This function is used to send a command to RPU\n\t    to configure HE LTF and GI parameters in RPU.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_conf_ltf_gi(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        he_ltf: ::core::ffi::c_uchar,
        he_gi: ::core::ffi::c_uchar,
        enabled: ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure Bluetooth coexistence parameters in RPU.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param cmd Bluetooth coexistence parameters which will be configured in RPU.\n @param cmd_len Command length.\n\n This function is used to send a command to RPU to configure\n\t    Bluetooth coexistence parameters in RPU.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_conf_btcoex(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        cmd: *mut ::core::ffi::c_void,
        cmd_len: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Set the Multicast filter address.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface whose state needs to be changed.\n @param mcast_info Multicast information to be set.\n\n This function is used to send a command (%NRF_WIFI_UMAC_CMD_MCAST_FILTER) to\n\t    instruct the firmware to set the multicast filter address to an interface\n\t    with index \\p if_idx and parameters specified by \\p mcast_info.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_set_mcast_addr(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        if_idx: ::core::ffi::c_uchar,
        mcast_info: *mut nrf_wifi_umac_mcast_cfg,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Fetch MAC address from OTP.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param vif_idx Interface index for which the MAC address is to be fetched.\n @param mac_addr Pointer to the address where the MAC address needs to be copied.\n\n This function is used to fetch MAC address from the OTP.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_otp_mac_addr_get(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        vif_idx: ::core::ffi::c_uchar,
        mac_addr: *mut ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get the RF parameters to be programmed to the RPU.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param rf_params Pointer to the address where the RF params information needs to be copied.\n @param tx_pwr_ceil_params Pointer to the address where TX ceil information is available for\n\t\t   both frequency bands.\n\n This function is used to fetch RF parameters information from the RPU and\n\t    update the default RF parameter with the OTP values. The updated RF\n\t    parameters are then returned in the \\p f_params.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_rf_params_get(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        rf_params: *mut ::core::ffi::c_uchar,
        tx_pwr_ceil_params: *mut nrf_wifi_tx_pwr_ceil_params,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Set regulatory domain in RPU.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param reg_info Pointer to the address where the regulatory domain information.\n\t\t   needs to be copied.\n This function is used to set regulatory domain in the RPU.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_set_reg(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        reg_info: *mut nrf_wifi_fmac_reg_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get regulatory domain from RPU.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param reg_info Pointer to the address where the regulatory domain information.\n\t\t   needs to be copied.\n This function is used to get regulatory domain from the RPU.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_get_reg(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        reg_info: *mut nrf_wifi_fmac_reg_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get the current power save information.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which power management is to be set.\n\n This function is used to send a command\n\t    to RPU to Enable/Disable WLAN Power management.\n\n @return Command execution status"]
    pub fn nrf_wifi_fmac_get_power_save_info(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Initializes the UMAC IF layer.\n\n @param data_config Pointer to configuration of data queues.\n @param rx_buf_pools Pointer to configuration of Rx queue buffers.\n\t\t       See rx_buf_pool_params\n @param callbk_fns Pointer to callback functions for addressing events\n                   from the UMAC layer. e.g. callback function to process\n                   packet received from RPU firmware, scan result etc\n\n This function initializes the UMAC IF layer.It does the following:\n\t    - Creates and initializes the context for the UMAC IF layer.\n\t    - Initializes the HAL layer.\n\t    - Initializes the OS abstraction Layer.\n\t    - Initializes TX queue token sizes.\n\t    - Initializes the RX buffer pool.\n\n @return Pointer to the context of the UMAC IF layer."]
    pub fn nrf_wifi_fmac_init(
        data_config: *mut nrf_wifi_data_config_params,
        rx_buf_pools: *mut rx_buf_pool_params,
        callbk_fns: *mut nrf_wifi_fmac_callbk_fns,
    ) -> *mut nrf_wifi_fmac_priv;
}
extern "C" {
    #[doc = " @brief Issue a scan request to the RPU firmware.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the scan is to be performed.\n @param scan_info The parameters needed by the RPU for scan operation.\n\n This function is used to send a command to:\n\t    Instruct the RPU firmware to trigger a scan. The scan can be performed in two\n\t    modes:\n\n\t    Auto Mode (%AUTO_SCAN):\n             In this mode, the host does not need to specify any scan specific\n          parameters. The RPU firmware will perform the scan on all the channels\n          permitted by and abiding by the regulations imposed by the\n          WORLD (common denominator of all regulatory domains) regulatory domain.\n          The scan will be performed using the wildcard SSID.\n\n\t    Channel Map Mode (%CHANNEL_MAPPING_SCAN):\n             In this mode the host can have fine grained control over the scan\n          specific parameters to be used (for example, Passive/Active scan selection,\n          Number of probe requests per active scan, Channel list to scan,\n          Permanence on each channel, SSIDs to scan etc.). This mode expects\n          the regulatory restrictions to be taken care by the invoker of the\n          API.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_scan(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        scan_info: *mut nrf_wifi_umac_scan_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Issue a scan results request to the RPU firmware.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the scan results are to be fetched.\n @param scan_type The scan type (i.e. DISPLAY or CONNECT scan).\n\n This function is used to send a command to:\n\t- Instruct the RPU firmware to return the results of a scan.\n\t- scan_type defines if the scan is performed for a\n\t  connection request (SCAN_CONNECT) or to display the\n\t  scan results to user (SCAN_DISPLAY)\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_scan_res_get(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        scan_type: ::core::ffi::c_int,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Issue abort of an ongoing scan to the RPU firmware.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the ongoing scan is to be aborted.\n\n This function is used to send a command to:\n\t- Instruct the RPU firmware to abort an ongoing scan request\n\t- The \\p if_idx provides the interface index on which the ongoing scan is\n\t  to be aborted\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_abort_scan(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get unused MAC address from base mac address.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param addr Memory to copy the mac address to.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_mac_addr(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        addr: *mut ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Assign a index for a new VIF.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n\n This function searches for an unused VIF index and returns it.\n\n @return Index to be used for the new VIF\n         In case of error MAX_NUM_VIFS will be returned."]
    pub fn nrf_wifi_fmac_vif_idx_get(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
    ) -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " @brief Add a new virtual interface.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param os_vif_ctx Pointer to VIF context that the UMAC IF passes\n                   up the stack during invocation of callback functions like\n                   rx_frm_callbk_fn() etc.\n @param vif_info Information regarding the interface to be added.\n\n This function is used to send a command to:\n\t    - Instruct the RPU firmware to add a new interface with parameters specified by\n             \\p vif_info.\n\n @return Index (maintained by the UMAC IF layer) of the VIF that was added.\n         In case of error MAX_NUM_VIFS will be returned."]
    pub fn nrf_wifi_fmac_add_vif(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        os_vif_ctx: *mut ::core::ffi::c_void,
        vif_info: *mut nrf_wifi_umac_add_vif_info,
    ) -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " @brief Deletes a virtual interface.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface to be deleted.\n\n This function is used to send a command to:\n     - Instruct the RPU firmware to delete an interface which was added using\n       \\p nrf_wifi_fmac_add_vif.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_del_vif(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Change the attributes of an interface.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the functionality is to be\n               bound.\n @param vif_info Interface specific information which needs to be passed to the\n                 RPU firmware.\n\n This function is used to change the attributes of an interface identified\n     with \\p if_idx.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_chg_vif(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        vif_info: *mut nrf_wifi_umac_chg_vif_attr_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Change the state of a virtual interface.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface whose state needs to be changed.\n @param vif_info State information to be changed for the interface.\n\n This function is used to send a command to:\n     - Instruct the RPU firmware to change the state of an interface identified by an index\n       \\p if_idx and parameters specified by \\p vif_info.\n     - The different states that can be configured are\n         - NRF_WIFI_FMAC_IF_OP_STATE_DOWN\n         - NRF_WIFI_FMAC_IF_OP_STATE_UP\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_chg_vif_state(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        vif_info: *mut nrf_wifi_umac_chg_vif_state_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Set MAC address on interface.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface whose MAC address is to be changed.\n @param mac_addr MAC address to set.\n\n This function is used to set the MAC address of an interface identified\n\t    with \\p if_idx.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_vif_macaddr(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        mac_addr: *mut ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Transmit a frame to the RPU.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the frame is to be\n               transmitted.\n @param netbuf Pointer to the OS specific network buffer.\n\n This function takes care of transmitting a frame to the RPU firmware.\n It does the following:\n\n\t- Queues the frames to a transmit queue.\n\t- Based on token availability, sends one or more frames to the RPU using\n\t  the command for transmission.\n\t- The firmware sends an event once the command has\n\t  been processed to indicate whether the frame(s) have been\n\t  transmitted/aborted.\n\t- The driver can cleanup the frame buffers after receiving this event.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_start_xmit(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        netbuf: *mut ::core::ffi::c_void,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Inform the RPU firmware that host is going to suspend state.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n\n This function is used to send a command to:\n\t    - Inform the RPU firmware that host is going to suspend state.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_suspend(fmac_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Notify RPU firmware that host has resumed from a suspended state.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n\n This function is used to send a command to:\n\t    - Inform the RPU firmware that host has resumed from a suspended state.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_resume(fmac_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get tx power\n\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx VIF index.\n\n This function is used to send a command to:\n\t    - Get the transmit power on a particular interface given\n\t      by \\p if_idx.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_get_tx_power(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get channel definition.\n\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx VIF index.\n\n This function is used to send a command to:\n\t    - Get the channel configured on a particular interface given by /p if_idx.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_get_channel(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get station statistics\n\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx: VIF index.\n @param mac MAC address of the station.\n\n This function is used to send a command to:\n\t    - Get station statistics using a MAC address.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_get_station(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uint,
        mac: *mut ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    pub fn nrf_wifi_fmac_get_interface(
        dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure WLAN power management.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which power management is to be set.\n @param state Enable/Disable of WLAN power management.\n\n This function is used to send a command to:\n\t     - The RPU firmware to Enable/Disable WLAN Power management.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_power_save(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        state: bool,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure WLAN U-APSD queue.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which power management is to be set.\n @param uapsd_queue Queue to be set for U-APSD.\n\n This function is used to send a command (%NRF_WIFI_UMAC_CMD_CONFIG_UAPSD) to:\n\t    - The RPU firmware to set a U-APSD queue value.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_uapsd_queue(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        uapsd_queue: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure Power save timeout.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which power management is to be set.\n @param ps_timeout Power save inactivity time.\n\n This function is used to send a command (%NRF_WIFI_UMAC_CMD_SET_POWER_SAVE_TIMEOUT) to:\n          - The RPU firmware to set power save inactivity time.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_power_save_timeout(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        ps_timeout: ::core::ffi::c_int,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure qos_map of for data\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the qos map be set.\n @param qos_info qos_map information.\n\n This function is used to send a command to:\n\t    - The RPU firmware to set QOS map information.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_qos_map(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        qos_info: *mut nrf_wifi_umac_qos_map_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure WoWLAN.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param var Wakeup trigger condition.\n\n This function is used to send a command to the RPU firmware to:\n\t    - Configure wakeup trigger condition in RPU.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_wowlan(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        var: ::core::ffi::c_uint,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get PHY configuration.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the CMD needs to be sent.\n\n This function is used to get PHY configuration from the RPU firmware.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_get_wiphy(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Register to get MGMT frames.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the CMD needs to be sent.\n @param frame_info Information regarding the management frame.\n\n Register with the RPU firmware to receive specific MGMT frames from the RPU to the host side.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_register_frame(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        frame_info: *mut nrf_wifi_umac_mgmt_frame_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Set wiphy parameters\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the CMD needs to be sent.\n @param wiphy_info wiphy parameters\n\n This function is used to send a command to the RPU firmware to:\n\t    - Configure parameters interface specific parameters on an interface identified\n\t      by \\p if_idx\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_wiphy_params(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        wiphy_info: *mut nrf_wifi_umac_set_wiphy_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief TWT setup command\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the TWT parameters be set.\n @param twt_info TWT parameters.\n\n This function is used to send a command to the RPU firmware to:\n\t    - Configure TWT setup specific parameters.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_twt_setup(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        twt_info: *mut nrf_wifi_umac_config_twt_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief TWT teardown command\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which the TWT parameters are to be set.\n @param twt_info TWT parameters.\n\n This function is used to send a command to the RPU firmware to:\n\t    - Tear down an existing TWT session.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_twt_teardown(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        twt_info: *mut nrf_wifi_umac_config_twt_info,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Get connection info from RPU\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface.\n\n This function is used to send a command to the RPU firmware to:\n\t    - Fetch connection information.\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_get_conn_info(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief De-initializes the UMAC IF layer.\n @param fpriv Pointer to the context of the UMAC IF layer.\n\n This function de-initializes the UMAC IF layer of the RPU WLAN FullMAC\n\t    driver. It does the following:\n\t\t- De-initializes the HAL layer.\n\t\t- Frees the context for the UMAC IF layer.\n\n @return None"]
    pub fn nrf_wifi_fmac_deinit(fpriv: *mut nrf_wifi_fmac_priv);
}
extern "C" {
    #[doc = " @brief Removes a RPU instance.\n @param fmac_dev_ctx Pointer to the context of the RPU instance to be removed.\n\n This is a wrapper function which frees the memory for\n an RPU instance at the UMAC layer.\n\n @return None."]
    pub fn nrf_wifi_fmac_dev_rem(fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx);
}
extern "C" {
    #[doc = " @brief Initializes a RPU instance.\n @param fmac_dev_ctx Pointer to the context of the RPU instance to be removed.\n @param rf_params_usr RF parameters (if any) to be passed to the RPU.\n @param sleep_type Type of RPU sleep.\n @param phy_calib PHY calibration flags to be passed to the RPU.\n @param op_band Operating band of the RPU.\n @param beamforming Enable/disable Wi-Fi beamforming.\n @param tx_pwr_ctrl_params TX power control parameters to be passed to the RPU.\n @param tx_pwr_ceil_params TX power ceil parameters for both frequency bands.\n\n This function initializes the firmware of an RPU instance. The following is addressed\n              - BAL layer device initialization\n              - HAL layer device initialization\n              - FW initialization and PHY calibration data is sent to PHY\n              - RX and TX buffers are initialized, tasklets assigned\n\n @retval\tNRF_WIFI_STATUS_SUCCESS On success\n @retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_dev_init(
        fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
        rf_params_usr: *mut ::core::ffi::c_uchar,
        phy_calib: ::core::ffi::c_uint,
        op_band: op_band,
        beamforming: bool,
        tx_pwr_ctrl_params: *mut nrf_wifi_tx_pwr_ctrl_params,
        tx_pwr_ceil_params: *mut nrf_wifi_tx_pwr_ceil_params,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief De-initializes a RPU instance.\n @param fmac_dev_ctx Pointer to the context of the RPU instance to be removed.\n\n This function de-initializes the firmware of an RPU instance.\n\t\t- RPU UMAC deinitialization command is executed\n\t\t- RX and TX is deallocated for firmware via UMAC command\n\n @return None."]
    pub fn nrf_wifi_fmac_dev_deinit(fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx);
}
extern "C" {
    #[doc = " @brief Configure WLAN listen interval.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which power management is to be set.\n @param listen_interval listen interval to be configured.\n\n This function is used to send a command to RPU to configure listen interval.\n Refer section 9.4.1.6 is 802.11-2020 standard for details on listen interval\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_listen_interval(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        listen_interval: ::core::ffi::c_ushort,
    ) -> nrf_wifi_status;
}
extern "C" {
    #[doc = " @brief Configure WLAN PS wakeup mode to DTIM interval or listen interval.\n @param fmac_dev_ctx Pointer to the UMAC IF context for a RPU WLAN device.\n @param if_idx Index of the interface on which power management is to be set.\n @param ps_wakeup_mode Enable listen interval based ps(default is DTIM based)\n\n This function is used to configure PS wakeup mode,  PS wakeup mode can be\n         configured to:\n            - DTIM interval based PS mode\n            - Listen interval based PS mode\n         Default mode is set to DTIM interval based PS mode\n\n@retval\tNRF_WIFI_STATUS_SUCCESS On success\n@retval\tNRF_WIFI_STATUS_FAIL On failure to execute command"]
    pub fn nrf_wifi_fmac_set_ps_wakeup_mode(
        fmac_dev_ctx: *mut ::core::ffi::c_void,
        if_idx: ::core::ffi::c_uchar,
        ps_wakeup_mode: bool,
    ) -> nrf_wifi_status;
}
#[doc = " struct nrf_wifi_osal_ops - Ops to be provided by a specific OS implementation.\n @init: Initialize the OS shim. This is expected to return any OS Shim\n specific context information that might be needed.\n\n @mem_alloc: Allocate memory of @size bytes and return a pointer to the start\n             of the memory allocated.\n @mem_zalloc: Allocate memory of @size bytes, zero out the memory and return\n              a pointer to the start of the zeroed out memory.\n @mem_free: Free up memory which has been allocated using @mem_alloc or\n            @mem_zalloc.\n @mem_cpy: Copy @count number of bytes from @src location in memory to @dest\n           location in memory.\n @mem_set: Fill a block of memory of @size bytes starting at @start with a\n           particular value represented by @val.\n @mem_cmp: Compares @size bytes starting at @addr1 with @addr2 location in\n\t     memory.\n\n @iomem_mmap: Map IO memory of @size pointed to by @addr into CPU\n              space.\n @iomem_unmap: Unmap IO memory from CPU space that was mapped using\n               @iomem_mmap.\n @iomem_read_reg32: Read the value from a 32 bit device register using a memory\n                    mapped address(@addr).\n @iomem_write_reg32: Write a 32 bit value (@val) to a 32 bit device register\n                     using a memory mapped address(@addr).\n @iomem_cpy_from: Copy a block of data of size @count bytes from memory\n                  mapped device memory(@src) to host memory(@dest).\n @iomem_cpy_to: Copy a block of data of size @count bytes from host\n                memory (@src) to memory mapped device memory(@dest).\n\n @spinlock_alloc: Allocate a busy lock.\n @spinlock_free: Free a busy lock (@lock) allocated by @spinlock_alloc\n @spinlock_init: Initialize a busy lock (@lock) allocated by @spinlock_alloc.\n @spinlock_take: Acquire a busy lock (@lock) allocated by @spinlock_alloc.\n @spinlock_rel: Release a busy lock (@lock) acquired by @spinlock_take.\n\n @spinlock_irq_take: Save interrupt states (@flags), disable interrupts and\n\t\t       take a lock (@lock).\n @spinlock_irq_rel: Restore interrupt states (@flags) and release lock (@lock)\n\t\t      acquired using @spinlock_irq_take.\n\n @log_dbg: Log a debug message.\n @log_info: Log an informational message.\n @log_err: Log an error message.\n\n @llist_node_alloc: Allocate a linked list node.\n @llist_node_free: Free a linked list node which was allocated by\n                   @llist_node_alloc.\n @llist_node_data_get: Get the pointer to the data which the linked list node\n                       points to.\n @llist_node_data_set: Store the pointer to the data in the linked list node.\n\n @llist_alloc: Allocate a linked list.\n @llist_free: Free a linked list allocated by @llist_alloc.\n @llist_init: Initialize a linked list allocated by @llist_alloc.\n @llist_add_node_tail: Add a linked list node allocated by @llist_node_alloc\n                       to the tail of a linked list allocated by @llist_alloc.\n @llist_add_node_head: Add a linked list node allocated by @llist_node_alloc\n\t\t\t\t\t to the head of a linked list allocated by @llist_alloc.\n @llist_get_node_head: Return the head node from a linked list while still\n                       leaving the node as part of the linked list. If the\n                       linked list is empty return NULL.\n @llist_get_node_nxt: Return the node next to the node passed in the\n                      @llist_node parameter. The node returned is not removed\n                      from the linked list.\n @llist_del_node: Remove the node passed in the @llist_node parameter from the\n                  linked list passed in the @llist parameter.\n @llist_len: Return the length of the linked list.\n\n @nbuf_alloc: Allocate a network buffer of size @size.\n @nbuf_free: Free a network buffer(@nbuf) which was allocated by @nbuf_alloc.\n @nbuf_headroom_res: Reserve headroom at the beginning of the data area of a\n                     network buffer(@nbuf).\n @nbuf_headroom_get: Get the size of the reserved headroom at the beginning\n                     of the data area of a network buffer(@nbuf).\n @nbuf_data_size: Get the size of the data area of a network buffer(@nbuf).\n @nbuf_data_get: Get the pointer to the data area of a network buffer(@nbuf).\n @nbuf_data_put: Increase the data area of a network buffer(@nbuf) by @size\n                 bytes at the end of the area and return the pointer to the\n                 beginning of the data area.\n @nbuf_data_push: Increase the data area of a network buffer(@nbuf) by @size\n                  bytes at the start of the area and return the pointer to the\n                  beginning of the data area.\n @nbuf_data_pull: Decrease the data area of a network buffer(@nbuf) by @size\n                  bytes at the start of the area and return the pointer to the\n                  beginning of the data area.\n @nbuf_get_priority: Get the priority of a network buffer(@nbuf).\n\n @tasklet_alloc: Allocate a tasklet structure and return a pointer to it.\n @tasklet_free: Free a tasklet structure that had been allocated using\n                @tasklet_alloc.\n @tasklet_init: Initialize a tasklet structure(@tasklet) that had been\n                allocated using @tasklet_alloc. Need to pass a callback\n                function (@callback) which should get invoked when the\n                tasklet is scheduled and the data(@data) to be passed to the\n                callback function.\n @tasklet_schedule: Schedule a tasklet that had been allocated using\n                    @tasklet_alloc and initialized using @tasklet_init.\n @tasklet_kill: Terminate a tasklet that had been scheduled\n                @tasklet_schedule.\n\n\n @sleep_ms: Sleep for @msecs milliseconds.\n @delay_us: Delay for @usecs microseconds.\n\n @time_get_curr_us: Get the current time of the day in microseconds.\n @time_elapsed_us: Return the time elapsed in microseconds since\n                   some time instant (@start_time_us).\n\n @bus_pcie_reg_drv: This Op will be called when a PCIe device driver is to be\n                    registered to the OS's PCIe core.\n @bus_pcie_unreg_drv: This Op will be called when the PCIe device driver is\n                      to be unregistered from the OS's PCIe core.\n @bus_pcie_dev_add: This Op will be called when a new PCIe device has\n\t\t      been detected. This will return a pointer to a OS\n\t\t      specific PCIe device context.\n @bus_pcie_dev_rem: This Op will be called when a PCIe device has been\n\t\t      removed.\n @bus_pcie_dev_intr_reg: Register the interrupt to the OS for a PCIe device.\n\t\t\t   This Op also passes the callback data and the\n\t\t\t   function to be called with this data when an\n                         interrupt is received.\n @bus_pcie_dev_intr_unreg: Unregister the interrupt that was registered using\n\t\t\t     @bus_pcie_dev_intr_reg.\n @bus_pcie_dev_dma_map: Map host memory of size @size pointed to by the virtual address\n\t\t\t  @virt_addr to be used by the PCIe device for DMAing contents.\n\t\t\t  The contents are available for DMAing to the device if @dir has a\n\t\t\t  value of @NRF_WIFI_OSAL_DMA_DIR_TO_DEV. Conversely the device can DMA\n\t\t\t  contents to the host memory if @dir has a value of\n\t\t\t  @NRF_WIFI_OSAL_DMA_DIR_FROM_DEV. The function returns the DMA address\n\t\t\t  of the mapped memory.\n @bus_pcie_dev_dma_unmap: Unmap the host memory which was mapped for DMA using\n\t\t\t    @bus_pcie_dev_dma_map.\n\t\t\t    The address that will be passed to this Op to be unmapped will\n\t\t\t    be the DMA address returned by @dma_bus_pcie_dev_map.\n @bus_pcie_dev_host_map_get: Get the host mapped address for a PCIe device.\n\n @timer_alloc: Allocates a timer and returns a pointer.\n @timer_free: Frees/Deallocates a timer that has been allocated\n\t\tusing @timer_alloc.\n @timer_init: Initializes a timer that has been allocated using @timer_alloc\n\t\tNeed to pass (@callback) callback function with\n\t\tthe data(@data) to be passed to the callback function,\n\t\twhenever the timer expires.\n @timer_schedule: Schedules a timer with a @duration\n\t\tthat has been allocated using @timer_alloc and\n\t\tinitialized with @timer_init.\n @timer_kill: Kills a timer that has been scheduled @timer_schedule.\n\n @assert: Asserts a @test_val with the @val for operation @op.\n\t    If true prints @assert_msg.\n\n @strlen: Calculate the length of the string @str.\n\n This structure exposes Ops which need to be implemented by the underlying OS\n in order for the WLAN driver to work. The Ops can be directly mapped to OS\n primitives where a one-to-one mapping is available. In case a mapping is not\n available an equivalent function will need to be implemented and that\n function will then need to be mapped to the corresponding Op.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_osal_ops {
    pub mem_alloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    pub mem_zalloc:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    pub mem_free: ::core::option::Option<unsafe extern "C" fn(buf: *mut ::core::ffi::c_void)>,
    pub mem_cpy: ::core::option::Option<
        unsafe extern "C" fn(
            dest: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub mem_set: ::core::option::Option<
        unsafe extern "C" fn(
            start: *mut ::core::ffi::c_void,
            val: ::core::ffi::c_int,
            size: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub mem_cmp: ::core::option::Option<
        unsafe extern "C" fn(
            addr1: *const ::core::ffi::c_void,
            addr2: *const ::core::ffi::c_void,
            size: usize,
        ) -> ::core::ffi::c_int,
    >,
    pub iomem_mmap: ::core::option::Option<
        unsafe extern "C" fn(
            addr: ::core::ffi::c_ulong,
            size: ::core::ffi::c_ulong,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub iomem_unmap: ::core::option::Option<unsafe extern "C" fn(addr: *mut ::core::ffi::c_void)>,
    pub iomem_read_reg32: ::core::option::Option<
        unsafe extern "C" fn(addr: *const ::core::ffi::c_void) -> ::core::ffi::c_uint,
    >,
    pub iomem_write_reg32: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, val: ::core::ffi::c_uint),
    >,
    pub iomem_cpy_from: ::core::option::Option<
        unsafe extern "C" fn(
            dest: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
        ),
    >,
    pub iomem_cpy_to: ::core::option::Option<
        unsafe extern "C" fn(
            dest: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
        ),
    >,
    pub qspi_read_reg32: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
        ) -> ::core::ffi::c_uint,
    >,
    pub qspi_write_reg32: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            val: ::core::ffi::c_uint,
        ),
    >,
    pub qspi_cpy_from: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            dest: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            count: usize,
        ),
    >,
    pub qspi_cpy_to: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            src: *const ::core::ffi::c_void,
            count: usize,
        ),
    >,
    pub spi_read_reg32: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
        ) -> ::core::ffi::c_uint,
    >,
    pub spi_write_reg32: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            val: ::core::ffi::c_uint,
        ),
    >,
    pub spi_cpy_from: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            dest: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            count: usize,
        ),
    >,
    pub spi_cpy_to: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            src: *const ::core::ffi::c_void,
            count: usize,
        ),
    >,
    pub spinlock_alloc: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub spinlock_free: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    pub spinlock_init: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    pub spinlock_take: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    pub spinlock_rel: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    pub spinlock_irq_take: ::core::option::Option<
        unsafe extern "C" fn(lock: *mut ::core::ffi::c_void, flags: *mut ::core::ffi::c_ulong),
    >,
    pub spinlock_irq_rel: ::core::option::Option<
        unsafe extern "C" fn(lock: *mut ::core::ffi::c_void, flags: *mut ::core::ffi::c_ulong),
    >,
    pub log_dbg: ::core::option::Option<
        unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, args: va_list) -> ::core::ffi::c_int,
    >,
    pub log_info: ::core::option::Option<
        unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, args: va_list) -> ::core::ffi::c_int,
    >,
    pub log_err: ::core::option::Option<
        unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, args: va_list) -> ::core::ffi::c_int,
    >,
    pub llist_node_alloc:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub llist_node_free:
        ::core::option::Option<unsafe extern "C" fn(node: *mut ::core::ffi::c_void)>,
    pub llist_node_data_get: ::core::option::Option<
        unsafe extern "C" fn(node: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    >,
    pub llist_node_data_set: ::core::option::Option<
        unsafe extern "C" fn(node: *mut ::core::ffi::c_void, data: *mut ::core::ffi::c_void),
    >,
    pub llist_alloc: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub llist_free: ::core::option::Option<unsafe extern "C" fn(llist: *mut ::core::ffi::c_void)>,
    pub llist_init: ::core::option::Option<unsafe extern "C" fn(llist: *mut ::core::ffi::c_void)>,
    pub llist_add_node_tail: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void, llist_node: *mut ::core::ffi::c_void),
    >,
    pub llist_add_node_head: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void, llist_node: *mut ::core::ffi::c_void),
    >,
    pub llist_get_node_head: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    >,
    pub llist_get_node_nxt: ::core::option::Option<
        unsafe extern "C" fn(
            llist: *mut ::core::ffi::c_void,
            llist_node: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub llist_del_node: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void, llist_node: *mut ::core::ffi::c_void),
    >,
    pub llist_len: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void) -> ::core::ffi::c_uint,
    >,
    pub nbuf_alloc: ::core::option::Option<
        unsafe extern "C" fn(size: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void,
    >,
    pub nbuf_free: ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void)>,
    pub nbuf_headroom_res: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void, size: ::core::ffi::c_uint),
    >,
    pub nbuf_headroom_get: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> ::core::ffi::c_uint,
    >,
    pub nbuf_data_size: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> ::core::ffi::c_uint,
    >,
    pub nbuf_data_get: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    >,
    pub nbuf_data_put: ::core::option::Option<
        unsafe extern "C" fn(
            nbuf: *mut ::core::ffi::c_void,
            size: ::core::ffi::c_uint,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub nbuf_data_push: ::core::option::Option<
        unsafe extern "C" fn(
            nbuf: *mut ::core::ffi::c_void,
            size: ::core::ffi::c_uint,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub nbuf_data_pull: ::core::option::Option<
        unsafe extern "C" fn(
            nbuf: *mut ::core::ffi::c_void,
            size: ::core::ffi::c_uint,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub nbuf_get_priority: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> ::core::ffi::c_uchar,
    >,
    pub tasklet_alloc: ::core::option::Option<
        unsafe extern "C" fn(type_: ::core::ffi::c_int) -> *mut ::core::ffi::c_void,
    >,
    pub tasklet_free:
        ::core::option::Option<unsafe extern "C" fn(tasklet: *mut ::core::ffi::c_void)>,
    pub tasklet_init: ::core::option::Option<
        unsafe extern "C" fn(
            tasklet: *mut ::core::ffi::c_void,
            callback: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_ulong)>,
            data: ::core::ffi::c_ulong,
        ),
    >,
    pub tasklet_schedule:
        ::core::option::Option<unsafe extern "C" fn(tasklet: *mut ::core::ffi::c_void)>,
    pub tasklet_kill:
        ::core::option::Option<unsafe extern "C" fn(tasklet: *mut ::core::ffi::c_void)>,
    pub sleep_ms: ::core::option::Option<
        unsafe extern "C" fn(msecs: ::core::ffi::c_int) -> ::core::ffi::c_int,
    >,
    pub delay_us: ::core::option::Option<
        unsafe extern "C" fn(usecs: ::core::ffi::c_int) -> ::core::ffi::c_int,
    >,
    pub time_get_curr_us: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_ulong>,
    pub time_elapsed_us: ::core::option::Option<
        unsafe extern "C" fn(start_time_us: ::core::ffi::c_ulong) -> ::core::ffi::c_uint,
    >,
    pub bus_pcie_init: ::core::option::Option<
        unsafe extern "C" fn(
            dev_name: *const ::core::ffi::c_char,
            vendor_id: ::core::ffi::c_uint,
            sub_vendor_id: ::core::ffi::c_uint,
            device_id: ::core::ffi::c_uint,
            sub_device_id: ::core::ffi::c_uint,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub bus_pcie_deinit:
        ::core::option::Option<unsafe extern "C" fn(os_pcie_priv: *mut ::core::ffi::c_void)>,
    pub bus_pcie_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            pcie_priv: *mut ::core::ffi::c_void,
            osal_pcie_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub bus_pcie_dev_rem:
        ::core::option::Option<unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_pcie_dev_init: ::core::option::Option<
        unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
    >,
    pub bus_pcie_dev_deinit:
        ::core::option::Option<unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_pcie_dev_intr_reg: ::core::option::Option<
        unsafe extern "C" fn(
            os_pcie_dev_ctx: *mut ::core::ffi::c_void,
            callbk_data: *mut ::core::ffi::c_void,
            callback_fn: ::core::option::Option<
                unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
            >,
        ) -> nrf_wifi_status,
    >,
    pub bus_pcie_dev_intr_unreg:
        ::core::option::Option<unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_pcie_dev_dma_map: ::core::option::Option<
        unsafe extern "C" fn(
            os_pcie_dev_ctx: *mut ::core::ffi::c_void,
            virt_addr: *mut ::core::ffi::c_void,
            size: usize,
            dir: nrf_wifi_osal_dma_dir,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub bus_pcie_dev_dma_unmap: ::core::option::Option<
        unsafe extern "C" fn(
            os_pcie_dev_ctx: *mut ::core::ffi::c_void,
            dma_addr: *mut ::core::ffi::c_void,
            size: usize,
            dir: nrf_wifi_osal_dma_dir,
        ),
    >,
    pub bus_pcie_dev_host_map_get: ::core::option::Option<
        unsafe extern "C" fn(
            os_pcie_dev_ctx: *mut ::core::ffi::c_void,
            host_map: *mut nrf_wifi_osal_host_map,
        ),
    >,
    pub bus_qspi_init: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub bus_qspi_deinit:
        ::core::option::Option<unsafe extern "C" fn(os_qspi_priv: *mut ::core::ffi::c_void)>,
    pub bus_qspi_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            qspi_priv: *mut ::core::ffi::c_void,
            osal_qspi_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub bus_qspi_dev_rem:
        ::core::option::Option<unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_qspi_dev_init: ::core::option::Option<
        unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
    >,
    pub bus_qspi_dev_deinit:
        ::core::option::Option<unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_qspi_dev_intr_reg: ::core::option::Option<
        unsafe extern "C" fn(
            os_qspi_dev_ctx: *mut ::core::ffi::c_void,
            callbk_data: *mut ::core::ffi::c_void,
            callback_fn: ::core::option::Option<
                unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
            >,
        ) -> nrf_wifi_status,
    >,
    pub bus_qspi_dev_intr_unreg:
        ::core::option::Option<unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_qspi_dev_host_map_get: ::core::option::Option<
        unsafe extern "C" fn(
            os_qspi_dev_ctx: *mut ::core::ffi::c_void,
            host_map: *mut nrf_wifi_osal_host_map,
        ),
    >,
    pub bus_spi_init: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    pub bus_spi_deinit:
        ::core::option::Option<unsafe extern "C" fn(os_spi_priv: *mut ::core::ffi::c_void)>,
    pub bus_spi_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            spi_priv: *mut ::core::ffi::c_void,
            osal_spi_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub bus_spi_dev_rem:
        ::core::option::Option<unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_spi_dev_init: ::core::option::Option<
        unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
    >,
    pub bus_spi_dev_deinit:
        ::core::option::Option<unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_spi_dev_intr_reg: ::core::option::Option<
        unsafe extern "C" fn(
            os_spi_dev_ctx: *mut ::core::ffi::c_void,
            callbk_data: *mut ::core::ffi::c_void,
            callback_fn: ::core::option::Option<
                unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
            >,
        ) -> nrf_wifi_status,
    >,
    pub bus_spi_dev_intr_unreg:
        ::core::option::Option<unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void)>,
    pub bus_spi_dev_host_map_get: ::core::option::Option<
        unsafe extern "C" fn(
            os_spi_dev_ctx: *mut ::core::ffi::c_void,
            host_map: *mut nrf_wifi_osal_host_map,
        ),
    >,
    pub assert: ::core::option::Option<
        unsafe extern "C" fn(
            test_val: ::core::ffi::c_int,
            val: ::core::ffi::c_int,
            op: nrf_wifi_assert_op_type,
            assert_msg: *mut ::core::ffi::c_char,
        ),
    >,
    pub strlen: ::core::option::Option<
        unsafe extern "C" fn(str_: *const ::core::ffi::c_void) -> ::core::ffi::c_uint,
    >,
}
#[test]
fn bindgen_test_layout_nrf_wifi_osal_ops() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_osal_ops> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_osal_ops>(),
        372usize,
        concat!("Size of: ", stringify!(nrf_wifi_osal_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_osal_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_osal_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(mem_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_zalloc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(mem_zalloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(mem_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_cpy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(mem_cpy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_set) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(mem_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_cmp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(mem_cmp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iomem_mmap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(iomem_mmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iomem_unmap) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(iomem_unmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iomem_read_reg32) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(iomem_read_reg32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iomem_write_reg32) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(iomem_write_reg32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iomem_cpy_from) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(iomem_cpy_from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iomem_cpy_to) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(iomem_cpy_to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qspi_read_reg32) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(qspi_read_reg32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qspi_write_reg32) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(qspi_write_reg32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qspi_cpy_from) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(qspi_cpy_from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qspi_cpy_to) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(qspi_cpy_to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi_read_reg32) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spi_read_reg32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi_write_reg32) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spi_write_reg32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi_cpy_from) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spi_cpy_from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi_cpy_to) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spi_cpy_to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock_alloc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spinlock_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock_free) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spinlock_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock_init) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spinlock_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock_take) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spinlock_take)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock_rel) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spinlock_rel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock_irq_take) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spinlock_irq_take)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock_irq_rel) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(spinlock_irq_rel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_dbg) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(log_dbg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_info) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(log_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_err) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(log_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_node_alloc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_node_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_node_free) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_node_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_node_data_get) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_node_data_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_node_data_set) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_node_data_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_alloc) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_free) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_init) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_add_node_tail) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_add_node_tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_add_node_head) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_add_node_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_get_node_head) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_get_node_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_get_node_nxt) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_get_node_nxt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_del_node) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_del_node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).llist_len) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(llist_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_alloc) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_free) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_headroom_res) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_headroom_res)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_headroom_get) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_headroom_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_data_size) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_data_get) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_data_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_data_put) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_data_put)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_data_push) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_data_push)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_data_pull) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_data_pull)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuf_get_priority) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(nbuf_get_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tasklet_alloc) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(tasklet_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tasklet_free) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(tasklet_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tasklet_init) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(tasklet_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tasklet_schedule) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(tasklet_schedule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tasklet_kill) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(tasklet_kill)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sleep_ms) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(sleep_ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay_us) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(delay_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_get_curr_us) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(time_get_curr_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_elapsed_us) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(time_elapsed_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_init) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_deinit) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_add) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_rem) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_rem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_init) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_deinit) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_intr_reg) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_intr_reg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_intr_unreg) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_intr_unreg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_dma_map) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_dma_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_dma_unmap) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_dma_unmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_pcie_dev_host_map_get) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_pcie_dev_host_map_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_init) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_deinit) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_dev_add) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_dev_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_dev_rem) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_dev_rem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_dev_init) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_dev_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_dev_deinit) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_dev_deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_dev_intr_reg) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_dev_intr_reg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_dev_intr_unreg) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_dev_intr_unreg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_qspi_dev_host_map_get) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_qspi_dev_host_map_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_init) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_deinit) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_dev_add) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_dev_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_dev_rem) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_dev_rem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_dev_init) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_dev_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_dev_deinit) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_dev_deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_dev_intr_reg) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_dev_intr_reg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_dev_intr_unreg) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_dev_intr_unreg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_spi_dev_host_map_get) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(bus_spi_dev_host_map_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).assert) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(assert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strlen) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_osal_ops),
            "::",
            stringify!(strlen)
        )
    );
}
extern "C" {
    #[doc = " get_os_ops() - The OSAL layer expects this Op return a initialized instance\n                of OS specific Ops.\n\n This Op is expected to be implemented by a specific OS shim and is expected\n to return a pointer to a initialized instance of struct nrf_wifi_osal_ops.\n\n Returns: Pointer to instance of OS specific Ops."]
    pub fn get_os_ops() -> *const nrf_wifi_osal_ops;
}
#[doc = " struct nrf_wifi_bal_ops - Ops to be provided by a particular bus\n                           implementation.\n @init:\n @deinit:\n @dev_init:\n @dev_deinit:\n @read_word:\n @write_word:\n @read_block:\n @write_block:\n @dma_map:\n @dma_unmap:"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_ops {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            opriv: *mut nrf_wifi_osal_priv,
            cfg_params: *mut ::core::ffi::c_void,
            intr_callbk_fn: ::core::option::Option<
                unsafe extern "C" fn(hal_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
            >,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(bus_priv: *mut ::core::ffi::c_void)>,
    pub dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            bus_priv: *mut ::core::ffi::c_void,
            bal_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub dev_rem:
        ::core::option::Option<unsafe extern "C" fn(bus_dev_ctx: *mut ::core::ffi::c_void)>,
    pub dev_init: ::core::option::Option<
        unsafe extern "C" fn(bus_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
    >,
    pub dev_deinit:
        ::core::option::Option<unsafe extern "C" fn(bus_dev_ctx: *mut ::core::ffi::c_void)>,
    pub read_word: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            addr_offset: ::core::ffi::c_ulong,
        ) -> ::core::ffi::c_uint,
    >,
    pub write_word: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            addr_offset: ::core::ffi::c_ulong,
            val: ::core::ffi::c_uint,
        ),
    >,
    pub read_block: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            dest_addr: *mut ::core::ffi::c_void,
            src_addr_offset: ::core::ffi::c_ulong,
            len: usize,
        ),
    >,
    pub write_block: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            dest_addr_offset: ::core::ffi::c_ulong,
            src_addr: *const ::core::ffi::c_void,
            len: usize,
        ),
    >,
    pub dma_map: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            virt_addr: ::core::ffi::c_ulong,
            len: usize,
            dma_dir: nrf_wifi_osal_dma_dir,
        ) -> ::core::ffi::c_ulong,
    >,
    pub dma_unmap: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            phy_addr: ::core::ffi::c_ulong,
            len: usize,
            dma_dir: nrf_wifi_osal_dma_dir,
        ) -> ::core::ffi::c_ulong,
    >,
}
#[test]
fn bindgen_test_layout_nrf_wifi_bal_ops() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_bal_ops> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_bal_ops>(),
        48usize,
        concat!("Size of: ", stringify!(nrf_wifi_bal_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_bal_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_bal_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_add) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(dev_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_rem) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(dev_rem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(dev_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_deinit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(dev_deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_word) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(read_word)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_word) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(write_word)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_block) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(read_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_block) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(write_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dma_map) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(dma_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dma_unmap) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_ops),
            "::",
            stringify!(dma_unmap)
        )
    );
}
extern "C" {
    #[doc = " get_bus_ops() - The BAL layer expects this Op return a initialized instance\n                of Bus specific Ops.\n\n This Op is expected to be implemented by a specific Bus shim and is expected\n to return a pointer to a initialized instance of struct nrf_wifi_bal_ops.\n\n Returns: Pointer to instance of Bus specific Ops."]
    pub fn get_bus_ops() -> *mut nrf_wifi_bal_ops;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_cfg_params {
    pub addr_pktram_base: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_bal_cfg_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_bal_cfg_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_bal_cfg_params>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_bal_cfg_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_bal_cfg_params>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_bal_cfg_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_pktram_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_cfg_params),
            "::",
            stringify!(addr_pktram_base)
        )
    );
}
#[doc = " struct nrf_wifi_bal_priv - Structure to hold context information for the BAL\n @opriv: Pointer to the OSAL context.\n @bus_priv: Pointer to a specific bus context.\n @ops: Pointer to bus operations to be provided by a specific bus\n       implementation.\n\n This structure maintains the context information necessary for the\n operation of the BAL. Some of the elements of the structure need to be\n initialized during the initialization of the BAL while others need to\n be kept updated over the duration of the BAL operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_priv {
    pub opriv: *mut nrf_wifi_osal_priv,
    pub bus_priv: *mut ::core::ffi::c_void,
    pub ops: *mut nrf_wifi_bal_ops,
    pub init_dev_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
    >,
    pub deinit_dev_callbk_fn:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>,
    pub intr_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
    >,
}
#[test]
fn bindgen_test_layout_nrf_wifi_bal_priv() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_bal_priv> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_bal_priv>(),
        24usize,
        concat!("Size of: ", stringify!(nrf_wifi_bal_priv))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_bal_priv>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_bal_priv))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opriv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_priv),
            "::",
            stringify!(opriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_priv) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_priv),
            "::",
            stringify!(bus_priv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_priv),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_dev_callbk_fn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_priv),
            "::",
            stringify!(init_dev_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deinit_dev_callbk_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_priv),
            "::",
            stringify!(deinit_dev_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intr_callbk_fn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_priv),
            "::",
            stringify!(intr_callbk_fn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_dev_ctx {
    pub bpriv: *mut nrf_wifi_bal_priv,
    pub hal_dev_ctx: *mut ::core::ffi::c_void,
    pub bus_dev_ctx: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_nrf_wifi_bal_dev_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_bal_dev_ctx> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_bal_dev_ctx>(),
        12usize,
        concat!("Size of: ", stringify!(nrf_wifi_bal_dev_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_bal_dev_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_bal_dev_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bpriv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_dev_ctx),
            "::",
            stringify!(bpriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hal_dev_ctx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_dev_ctx),
            "::",
            stringify!(hal_dev_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_dev_ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_bal_dev_ctx),
            "::",
            stringify!(bus_dev_ctx)
        )
    );
}
extern "C" {
    #[doc = " nrf_wifi_bal_init() - Initialize the BAL layer.\n\n @intr_callbk_fn: Pointer to the callback function which the user of this\n                  layer needs to implement to handle interrupts from the\n                  RPU.\n\n This API is used to initialize the BAL layer and is expected to be called\n before using the BAL layer. This API returns a pointer to the BAL context\n which might need to be passed to further API calls.\n\n Returns: Pointer to instance of BAL layer context."]
    pub fn nrf_wifi_bal_init(
        opriv: *mut nrf_wifi_osal_priv,
        cfg_params: *mut nrf_wifi_bal_cfg_params,
        intr_callbk_fn: ::core::option::Option<
            unsafe extern "C" fn(hal_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
        >,
    ) -> *mut nrf_wifi_bal_priv;
}
extern "C" {
    #[doc = " nrf_wifi_bal_deinit() - Deinitialize the BAL layer.\n @bpriv: Pointer to the BAL layer context returned by the\n         @nrf_wifi_bal_init API.\n\n This API is used to deinitialize the BAL layer and is expected to be called\n after done using the BAL layer.\n\n Returns: None."]
    pub fn nrf_wifi_bal_deinit(bpriv: *mut nrf_wifi_bal_priv);
}
extern "C" {
    pub fn nrf_wifi_bal_dev_add(
        bpriv: *mut nrf_wifi_bal_priv,
        hal_dev_ctx: *mut ::core::ffi::c_void,
    ) -> *mut nrf_wifi_bal_dev_ctx;
}
extern "C" {
    pub fn nrf_wifi_bal_dev_rem(bal_dev_ctx: *mut nrf_wifi_bal_dev_ctx);
}
extern "C" {
    pub fn nrf_wifi_bal_dev_init(bal_dev_ctx: *mut nrf_wifi_bal_dev_ctx) -> nrf_wifi_status;
}
extern "C" {
    pub fn nrf_wifi_bal_dev_deinit(bal_dev_ctx: *mut nrf_wifi_bal_dev_ctx);
}
extern "C" {
    pub fn nrf_wifi_bal_read_word(
        ctx: *mut ::core::ffi::c_void,
        addr_offset: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn nrf_wifi_bal_write_word(
        ctx: *mut ::core::ffi::c_void,
        addr_offset: ::core::ffi::c_ulong,
        val: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn nrf_wifi_bal_read_block(
        ctx: *mut ::core::ffi::c_void,
        dest_addr: *mut ::core::ffi::c_void,
        src_addr_offset: ::core::ffi::c_ulong,
        len: usize,
    );
}
extern "C" {
    pub fn nrf_wifi_bal_write_block(
        ctx: *mut ::core::ffi::c_void,
        dest_addr_offset: ::core::ffi::c_ulong,
        src_addr: *const ::core::ffi::c_void,
        len: usize,
    );
}
extern "C" {
    pub fn nrf_wifi_bal_dma_map(
        ctx: *mut ::core::ffi::c_void,
        virt_addr: ::core::ffi::c_ulong,
        len: usize,
        dma_dir: nrf_wifi_osal_dma_dir,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn nrf_wifi_bal_dma_unmap(
        ctx: *mut ::core::ffi::c_void,
        phy_addr: ::core::ffi::c_ulong,
        len: usize,
        dma_dir: nrf_wifi_osal_dma_dir,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn nrf_wifi_bal_bus_access_rec_enab(ctx: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn nrf_wifi_bal_bus_access_rec_disab(ctx: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn nrf_wifi_bal_bus_access_cnt_print(ctx: *mut ::core::ffi::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RPU_PROC_TYPE {
    RPU_PROC_TYPE_MCU_LMAC = 0,
    RPU_PROC_TYPE_MCU_UMAC = 1,
    RPU_PROC_TYPE_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NRF_WIFI_REGION_TYPE {
    NRF_WIFI_REGION_TYPE_GRAM = 0,
    NRF_WIFI_REGION_TYPE_PKTRAM = 1,
    NRF_WIFI_REGION_TYPE_SYSBUS = 2,
    NRF_WIFI_REGION_TYPE_PBUS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NRF_WIFI_HAL_MSG_TYPE {
    NRF_WIFI_HAL_MSG_TYPE_CMD_CTRL = 0,
    NRF_WIFI_HAL_MSG_TYPE_EVENT = 1,
    NRF_WIFI_HAL_MSG_TYPE_CMD_DATA_RX = 2,
    NRF_WIFI_HAL_MSG_TYPE_CMD_DATA_MGMT = 3,
    NRF_WIFI_HAL_MSG_TYPE_CMD_DATA_TX = 4,
    NRF_WIFI_HAL_MSG_TYPE_MAX = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_cfg_params {
    pub max_cmd_size: ::core::ffi::c_uint,
    pub max_event_size: ::core::ffi::c_uint,
    pub rx_buf_headroom_sz: ::core::ffi::c_uchar,
    pub tx_buf_headroom_sz: ::core::ffi::c_uchar,
    pub rx_buf_pool: [rx_buf_pool_params; 3usize],
    pub max_tx_frm_sz: ::core::ffi::c_uint,
    pub max_ampdu_len_per_token: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_hal_cfg_params() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_hal_cfg_params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_hal_cfg_params>(),
        32usize,
        concat!("Size of: ", stringify!(nrf_wifi_hal_cfg_params))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_hal_cfg_params>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_hal_cfg_params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_cmd_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_cfg_params),
            "::",
            stringify!(max_cmd_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_event_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_cfg_params),
            "::",
            stringify!(max_event_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf_headroom_sz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_cfg_params),
            "::",
            stringify!(rx_buf_headroom_sz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_buf_headroom_sz) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_cfg_params),
            "::",
            stringify!(tx_buf_headroom_sz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf_pool) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_cfg_params),
            "::",
            stringify!(rx_buf_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tx_frm_sz) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_cfg_params),
            "::",
            stringify!(max_tx_frm_sz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_ampdu_len_per_token) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_cfg_params),
            "::",
            stringify!(max_ampdu_len_per_token)
        )
    );
}
#[doc = " struct nrf_wifi_hal_priv - Structure to hold context information for the\n                           HAL layer.\n @opriv: Pointer to the OS abstraction layer.\n @bpriv: Pointer to the Bus abstraction layer.\n @add_dev_callbk_data: Data to be passed back when invoking @add_dev_callbk_fn.\n @add_dev_callbk_fn: Callback function to be called when a new device is being added.\n @rem_dev_callbk_fn: Callback function to be called when a device is being removed.\n @init_dev_callbk_fn: Callback function to be called when a device is being initialised.\n @deinit_dev_callbk_fn: Callback function to be called when a device is being deinitialised.\n @intr_callback_fn: Pointer to the function which needs to be called when an\n                    interrupt is received.\n @max_cmd_size: Maximum size of the command that can be sent to the\n                Firmware.\n\n This structure maintains the context information necessary for the\n operation of the HAL layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_priv {
    pub opriv: *mut nrf_wifi_osal_priv,
    pub bpriv: *mut nrf_wifi_bal_priv,
    pub num_devs: ::core::ffi::c_uchar,
    pub add_dev_callbk_data: *mut ::core::ffi::c_void,
    pub add_dev_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            add_dev_callbk_data: *mut ::core::ffi::c_void,
            hal_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    pub rem_dev_callbk_fn:
        ::core::option::Option<unsafe extern "C" fn(mac_ctx: *mut ::core::ffi::c_void)>,
    pub init_dev_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(mac_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
    >,
    pub deinit_dev_callbk_fn:
        ::core::option::Option<unsafe extern "C" fn(mac_ctx: *mut ::core::ffi::c_void)>,
    pub intr_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            mac_ctx: *mut ::core::ffi::c_void,
            event_data: *mut ::core::ffi::c_void,
            len: ::core::ffi::c_uint,
        ) -> nrf_wifi_status,
    >,
    pub cfg_params: nrf_wifi_hal_cfg_params,
    pub addr_pktram_base: ::core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_nrf_wifi_hal_priv() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_hal_priv> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_hal_priv>(),
        72usize,
        concat!("Size of: ", stringify!(nrf_wifi_hal_priv))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_hal_priv>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_hal_priv))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opriv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(opriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bpriv) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(bpriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_devs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(num_devs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_dev_callbk_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(add_dev_callbk_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_dev_callbk_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(add_dev_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem_dev_callbk_fn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(rem_dev_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_dev_callbk_fn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(init_dev_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deinit_dev_callbk_fn) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(deinit_dev_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intr_callbk_fn) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(intr_callbk_fn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfg_params) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(cfg_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_pktram_base) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_priv),
            "::",
            stringify!(addr_pktram_base)
        )
    );
}
#[doc = " struct nrf_wifi_hal_info - Structure to hold RPU information.\n @hpqm_info: HPQM queue(s) related information.\n @rx_cmd_base: The base address for posting RX commands.\n @tx_cmd_base: The base address for posting TX commands.\n\n This structure contains RPU related information needed by the\n HAL layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_info {
    pub hpqm_info: host_rpu_hpqm_info,
    pub rx_cmd_base: ::core::ffi::c_uint,
    pub tx_cmd_base: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_hal_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_hal_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_hal_info>(),
        64usize,
        concat!("Size of: ", stringify!(nrf_wifi_hal_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_hal_info>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_hal_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hpqm_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_info),
            "::",
            stringify!(hpqm_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_cmd_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_info),
            "::",
            stringify!(rx_cmd_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_cmd_base) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_info),
            "::",
            stringify!(tx_cmd_base)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_buf_map_info {
    pub mapped: bool,
    pub virt_addr: ::core::ffi::c_ulong,
    pub phy_addr: ::core::ffi::c_ulong,
    pub buf_len: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_hal_buf_map_info() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_hal_buf_map_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_hal_buf_map_info>(),
        16usize,
        concat!("Size of: ", stringify!(nrf_wifi_hal_buf_map_info))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_hal_buf_map_info>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_hal_buf_map_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mapped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_buf_map_info),
            "::",
            stringify!(mapped)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).virt_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_buf_map_info),
            "::",
            stringify!(virt_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_buf_map_info),
            "::",
            stringify!(phy_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_buf_map_info),
            "::",
            stringify!(buf_len)
        )
    );
}
#[doc = " struct nrf_wifi_hal_dev_ctx - Structure to hold per device context information\n                              for the HAL layer.\n @hpriv: Pointer to the HAL abstraction layer.\n @idx: The index of the HAL instantiation (the instance of the device to\n       which this HAL instance is associated to)\n @mac_ctx: Pointer to the per device MAC context which is using the HAL layer.\n @dev_ctx: Pointer to the per device BUS context which is being used by the\n           HAL layer.\n @rpu_info: RPU specific information necessary for the operation\n            of the HAL.\n @num_cmds: Debug counter for number of commands sent by the host to the RPU.\n @cmd_q: Queue to hold commands before they are sent to the RPU.\n @event_q: Queue to hold events received from the RPU before they are\n           processed by the host.\n @curr_proc: The RPU MCU whose context is active for a given HAL operation.\n             This is needed only during FW loading and not necessary during\n             the regular operation after the FW has been loaded.\n @lock_hal: Lock to be used for atomic HAL operations.\n @lock_rx: Lock to be used for atomic RX operations.\n @event_tasklet: Pointer to the bottom half handler for RX events.\n @rpu_ps_state: PS state of the RPU.\n @rpu_ps_timer: Inactivity timer used to put RPU back to sleep after\n                waking it up.\n @rpu_ps_lock: Lock to be used for atomic RPU PS operations.\n @num_isrs: Debug counter for number of interrupts received from the RPU.\n @num_events: Debug counter for number of events received from the RPU.\n @num_events_resubmit: Debug counter for number of event pointers\n                       resubmitted back to the RPU.\n\n This structure maintains the context information necessary for the\n operation of the HAL. Some of the elements of the structure need to be\n initialized durign the initialization of the driver while others need to\n be kept updated over the duration of the driver operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_dev_ctx {
    pub hpriv: *mut nrf_wifi_hal_priv,
    pub mac_dev_ctx: *mut ::core::ffi::c_void,
    pub bal_dev_ctx: *mut ::core::ffi::c_void,
    pub idx: ::core::ffi::c_uchar,
    pub rpu_info: nrf_wifi_hal_info,
    pub num_cmds: ::core::ffi::c_uint,
    pub cmd_q: *mut ::core::ffi::c_void,
    pub event_q: *mut ::core::ffi::c_void,
    pub curr_proc: RPU_PROC_TYPE,
    pub lock_hal: *mut ::core::ffi::c_void,
    pub event_tasklet: *mut ::core::ffi::c_void,
    pub lock_rx: *mut ::core::ffi::c_void,
    pub rx_buf_info: [*mut nrf_wifi_hal_buf_map_info; 3usize],
    pub tx_buf_info: *mut nrf_wifi_hal_buf_map_info,
    pub addr_rpu_pktram_base: ::core::ffi::c_ulong,
    pub addr_rpu_pktram_base_tx: ::core::ffi::c_ulong,
    pub addr_rpu_pktram_base_rx: ::core::ffi::c_ulong,
    pub addr_rpu_pktram_base_rx_pool: [::core::ffi::c_ulong; 3usize],
    pub tx_frame_offset: ::core::ffi::c_ulong,
    pub event_data: *mut ::core::ffi::c_char,
    pub event_data_curr: *mut ::core::ffi::c_char,
    pub event_data_len: ::core::ffi::c_uint,
    pub event_data_pending: ::core::ffi::c_uint,
    pub event_resubmit: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_nrf_wifi_hal_dev_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_hal_dev_ctx> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_hal_dev_ctx>(),
        172usize,
        concat!("Size of: ", stringify!(nrf_wifi_hal_dev_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_hal_dev_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_hal_dev_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hpriv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(hpriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac_dev_ctx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(mac_dev_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bal_dev_ctx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(bal_dev_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rpu_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(rpu_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_cmds) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(num_cmds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd_q) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(cmd_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_q) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(event_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curr_proc) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(curr_proc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_hal) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(lock_hal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_tasklet) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(event_tasklet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_rx) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(lock_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf_info) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(rx_buf_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_buf_info) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(tx_buf_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_rpu_pktram_base) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(addr_rpu_pktram_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_rpu_pktram_base_tx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(addr_rpu_pktram_base_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_rpu_pktram_base_rx) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(addr_rpu_pktram_base_rx)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).addr_rpu_pktram_base_rx_pool) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(addr_rpu_pktram_base_rx_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_frame_offset) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(tx_frame_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_data) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(event_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_data_curr) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(event_data_curr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_data_len) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(event_data_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_data_pending) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(event_data_pending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_resubmit) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_dev_ctx),
            "::",
            stringify!(event_resubmit)
        )
    );
}
#[doc = " struct nrf_wifi_hal_msg - Structure to hold information about a HAL message.\n @len: Length of the HAL message.\n @data: Pointer to the buffer containing the HAL message.\n\n This structure contains information about a HAL message (command/event)."]
#[repr(C)]
#[derive(Debug)]
pub struct nrf_wifi_hal_msg {
    pub len: ::core::ffi::c_uint,
    pub data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[test]
fn bindgen_test_layout_nrf_wifi_hal_msg() {
    const UNINIT: ::core::mem::MaybeUninit<nrf_wifi_hal_msg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nrf_wifi_hal_msg>(),
        4usize,
        concat!("Size of: ", stringify!(nrf_wifi_hal_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<nrf_wifi_hal_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(nrf_wifi_hal_msg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_msg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nrf_wifi_hal_msg),
            "::",
            stringify!(data)
        )
    );
}
